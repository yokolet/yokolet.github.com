<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-03-12T22:35:30+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">yokolet’s notelets</title><subtitle>Blog site mostly for programming topics.</subtitle><entry><title type="html">Ruby on Rails Low Level Cache Programming</title><link href="http://localhost:4000/2025/03/05/rails-cache-programming.html" rel="alternate" type="text/html" title="Ruby on Rails Low Level Cache Programming" /><published>2025-03-05T22:57:00+09:00</published><updated>2025-03-05T22:57:00+09:00</updated><id>http://localhost:4000/2025/03/05/rails-cache-programming</id><content type="html" xml:base="http://localhost:4000/2025/03/05/rails-cache-programming.html"><![CDATA[<p>Ruby on Rails is known to offer really various features which are useful to create a web application.
Among those, little known API might be the low level caching API.</p>

<p>Basically, people don’t code to manipulate cached values. When the caching is on, Rails caches
view fragments, database query result or some values automatically. As you know the caching is used to
improve performance in general.</p>

<p>However, we can use Rails cache like a key-value store.
The API allows us to read/write values tied to keys, which is called a low level caching.</p>

<p>This blog post focuses on such Rails low level cache programming.</p>

<h3 id="configuration">Configuration</h3>

<p>Rails supports multiple types of cache stores. The type should be specified by <code>config_cache_store</code> in
<code>config/environments/[development|test|production].rb</code> files.</p>

<h4 id="types-of-stores">types of stores</h4>
<ul>
  <li>Memory Store
    <ul>
      <li>example: <code>config.cache_store = :memory_store, { size: 64.megabytes }</code></li>
      <li>In-memory data store which can be used within a single process.</li>
      <li>Popular type for a development environment.</li>
    </ul>
  </li>
  <li>File Store
    <ul>
      <li>example: <code>config.cache_store = :file_store, "/path/to/cache/directory"</code></li>
      <li>File system data store which can be shared among multiple processes.</li>
    </ul>
  </li>
  <li>MemCache Store
    <ul>
      <li>example: <code>config.cache_store = :mem_cache_store, "cache-1.example.com", "cache-2.example.com"</code></li>
      <li>Data store by memcached server (<a href="https://memcached.org/">https://memcached.org/</a>).</li>
      <li>Popular type for a production environment.</li>
    </ul>
  </li>
  <li>Redis Store
    <ul>
      <li>example: <code>config.cache_store = :redis_cache_store, { url: ENV["REDIS_URL"] }</code></li>
      <li>Data store by Redis (<a href="https://redis.io/">https://redis.io/</a>).</li>
    </ul>
  </li>
  <li>Solid Cache Store
    <ul>
      <li>example: see production section of <code>config/database.yml</code></li>
      <li>Data store by RDBMS which is the same as Rails database.</li>
      <li>Introduced in Rails 8.</li>
    </ul>
  </li>
  <li>Null Store
    <ul>
      <li>example: <code>config.cache_store = :null_store</code></li>
      <li>Data store whose scope is each web request.</li>
    </ul>
  </li>
</ul>

<h4 id="difference-between-rails-7-and-rails-8">Difference between Rails 7 and Rails 8</h4>

<p>The production/test environment configurations stay the same on both Rails 7 and 8.
However, the development configuration has changed.
Let’s look at the differences. The first one is Rails 7, and the second is Rail 8.</p>

<pre><code class="language-ruby"># Rails 7 config/environments/development.rb

# Enable/disable caching. By default caching is disabled.
# Run rails dev:cache to toggle caching.
if Rails.root.join("tmp/caching-dev.txt").exist?
  config.cache_store = :memory_store
  config.public_file_server.headers = {
    "Cache-Control" =&gt; "public, max-age=#{2.days.to_i}"
  }
else
  config.action_controller.perform_caching = false

  config.cache_store = :null_store
end
</code></pre>

<pre><code class="language-ruby"># Rails 8 config/environments/development.rb

# Enable/disable Action Controller caching. By default Action Controller caching is disabled.
# Run rails dev:cache to toggle Action Controller caching.
if Rails.root.join("tmp/caching-dev.txt").exist?
  config.action_controller.perform_caching = true
  config.action_controller.enable_fragment_cache_logging = true
  config.public_file_server.headers = { "cache-control" =&gt; "public, max-age=#{2.days.to_i}" }
else
  config.action_controller.perform_caching = false
end

# Change to :null_store to avoid any caching.
config.cache_store = :memory_store
</code></pre>

<p>On Rails 7, we should hit the command, <code>bin/rails dev:cache</code>, to use the cache.
The command creates an empty file, <code>tmp/caching-dev.txt</code>, so that <code>config.cache_store = :memory_store</code> works.
However, on Rails 8, <code>config.cache_store = :memory_store</code> is located on the outside of if-block.
We don’t need to use the command, <code>bin/rails dev:cache</code> anymore, if we don’t need anything in the block.</p>

<p>While using the low-level caching API, setting the cache store is enough.
That being said, the caching API is available out of the box on Rail 8.</p>

<h3 id="cache-api">Cache API</h3>

<h4 id="keys-and-values">Keys and Values</h4>

<p>Rails cache is a key-value store. A key is, internally, a string always.
However, if a Ruby object can be converted to a string, such object can be a key, for example, a symbol or Array.
API document says, if the object reacts to <code>to_param</code> method and returns a value,
the object can be a key. Also, if the object implements <code>cache_key</code> method, the object can be a key.</p>

<p>The key-value store’s values are any Ruby object if the object is serializable and deserializable.
For example, a string, Array, or Hash can be a value, but Proc object is not.
If it really needs, we can define own serializer and set to the Rails cache.</p>

<h4 id="basic-methods">Basic Methods</h4>

<p>Supported methods on all types of stores are <code>fetch</code>, <code>write</code>, <code>read</code>, <code>exist?</code> and <code>delete</code>.
The cache API has more methods such as <code>increment</code> or <code>cleanup</code>, but depending on the store types,
some methods may not be supported.</p>

<h5 id="fetch">fetch</h5>
<p>The <code>fetch</code> would be the most frequently used method. It covers both read and write.
The fetch method considers a cache miss, so it takes a block to return a value for the cache miss.
When the value from the block is returned, the value is saved as well.
However, the method doesn’t simply update the value. To make the fetch method to update the value
even though it hits the cached value, the method takes <code>force</code> option.</p>

<pre><code class="language-bash">$ bin/rails c
example(dev)&gt; Rails.cache
=&gt; #&lt;ActiveSupport::Cache::MemoryStore entries=0, size=0, options={compress: false, compress_threshold: 1024}&gt;
example(dev)&gt; Rails.cache.fetch(:my_value)
=&gt; nil
example(dev)&gt; Rails.cache.fetch(:my_value) { "Ruby" }
=&gt; "Ruby"
example(dev)&gt; Rails.cache.fetch(:my_value)
=&gt; "Ruby"
example(dev)&gt; Rails.cache.fetch(:my_value) { "JavaScript" }
=&gt; "Ruby"
example(dev)&gt; Rails.cache.fetch(:my_value, force: true) { "JavaScript" }
=&gt; "JavaScript"
example(dev)&gt; Rails.cache.fetch(:my_value)
=&gt; "JavaScript"
</code></pre>

<p>The fetch method takes an expiry option to remove a value from cache automatically.</p>

<pre><code class="language-bash">example(dev)&gt; Rails.cache.fetch(:my_value, force: true, expires_in: 5.seconds) { "Bash" }
=&gt; "Bash"
example(dev)&gt; Rails.cache.fetch(:my_value)
=&gt; "Bash"
# after 5 seconds
example(dev)&gt; Rails.cache.fetch(:my_value)
=&gt; nil
</code></pre>

<p>Aside of <code>expires_in</code>, <code>expires_at</code> is also available.
This is a handy feature when we want to save the value just temporarily.</p>

<h5 id="write">write</h5>

<p>The <code>write</code> method works the same as <code>Rails.cache.fetch(:my_value, force: true) { "JavaScript" }</code>.</p>

<pre><code class="language-bash">example(dev)&gt; Rails.cache.write(:your_value, "YAML")
=&gt; true
example(dev)&gt; Rails.cache.fetch(:your_value)
=&gt; "YAML"
</code></pre>

<p>The method takes <code>expires_in</code>, <code>expires_at</code> options.</p>

<h5 id="read">read</h5>

<p>The <code>read</code> method works the same as <code>fetch</code> without block. The method just looks up a value by key.</p>

<pre><code class="language-bash">example(dev)&gt; Rails.cache.write(:her_value, "SQL")
=&gt; true
example(dev)&gt; Rails.cache.read(:her_value)
=&gt; "SQL"
</code></pre>

<h5 id="exist">exist?</h5>

<p>The <code>exist?</code> method is useful to find that the value is nil or key doesn’t exist.
Rails cache allows to save nil as a value.
When the fetch or read method returns nil, we don’t know it is a value or not.</p>

<pre><code class="language-bash">example(dev)&gt; Rails.cache.fetch(:his_value, force: true, expires_in: 10.seconds) { nil }
=&gt; nil
example(dev)&gt; Rails.cache.read(:his_value)
=&gt; nil
example(dev)&gt; Rails.cache.exist?(:his_value)
=&gt; true
# after 10 seconds
example(dev)&gt; Rails.cache.exist?(:his_value)
=&gt; false
</code></pre>

<h5 id="delete">delete</h5>

<p>The <code>delete</code> method deletes a key-value pair from the cache.</p>

<pre><code class="language-bash">example(dev)&gt; Rails.cache.write(:their_value, "JSON")
=&gt; true
example(dev)&gt; Rails.cache.read(:their_value)
=&gt; "JSON"
example(dev)&gt; Rails.cache.delete(:their_value)
=&gt; true
example(dev)&gt; Rails.cache.read(:their_value)
=&gt; nil
example(dev)&gt; Rails.cache.exist?(:their_value)
=&gt; false
</code></pre>

<h3 id="low-level-cache-programming-for-what">Low Level Cache Programming for What</h3>

<p>So far, we have looked at the low level cache API. Well, the question would be, “what is it for?”
To save and read values, we can use database or ActiveRecord. The value saved in the database can be used
in almost everywhere. So, why or when we should use the low level cache programming?</p>

<p>I have used the low level cache API in a couple of applications.
It is good to save a short-lived small data.
The Rails cache is a simple key-value store. To save the value, we don’t create a migration.
Without explicit deleting, the values expire and disappear.</p>

<p>The sessions might be another option for a key-value store.
However, the sessions are not a mighty store.
For example, WebSocket or ActionCable is unable to use the sessions.
Another example would be a controller method used as a callback function of OAuth, payment gateway or such.
The sessions are established between Rails server and a web browser.
When the controller method gets hit by somewhere else, the sessions don’t work nicely.</p>

<p>Typical Rails applications can do without the low level cache programming.
However, it is very useful in some cases.</p>

<h3 id="references">References</h3>
<ul>
  <li><a href="https://www.honeybadger.io/blog/rails-low-level-caching/">Mastering Low Level Caching in Rails</a></li>
  <li><a href="https://guides.rubyonrails.org/caching_with_rails.html#low-level-caching-using-rails-cache">Ruby on Rails Guides: Caching: 2.4 Low-Level Caching using Rails.cache</a></li>
  <li><a href="https://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html">Ruby on Rail API: Active Support Cache Store</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[Ruby on Rails is known to offer really various features which are useful to create a web application. Among those, little known API might be the low level caching API.]]></summary></entry><entry><title type="html">Application Development by Rails Action Cable</title><link href="http://localhost:4000/2024/11/11/application-development-by-rails-action-cable.html" rel="alternate" type="text/html" title="Application Development by Rails Action Cable" /><published>2024-11-11T22:32:00+09:00</published><updated>2024-11-11T22:32:00+09:00</updated><id>http://localhost:4000/2024/11/11/application-development-by-rails-action-cable</id><content type="html" xml:base="http://localhost:4000/2024/11/11/application-development-by-rails-action-cable.html"><![CDATA[<p>The previous two blog posts introduced WebSocket and how to implement a WebSocket application on Ruby on Rails.
This blog post digs deeper. It is a memo on creating a more realistic application by Action Cable.</p>

<h3 id="real-time-application">Real-time application</h3>

<p>As a real-time application, this post picks up a classic Tic-Tac-Toe game.
The game here adopts a multi-player and multi-board design.
Multiple players can join the game.
A single player can create or join multiple game boards.
The player can play multiple games in parallel.</p>

<p>When a player registers a player name, the name appears on all players’ panels in real-time.
When a new board is created, its name appears on all players’ panels in real-time as well.
Of course, the game progress is updated in real-time.</p>

<p>When a player clicks an unregister button or closes a window/tab,
the player’s name disappears from all players’ panels.</p>

<h4 id="code-and-game-details">Code and Game Details</h4>

<ul>
  <li>GitLab: <a href="https://gitlab.com/yokolet/action-cable-tictactoe">https://gitlab.com/yokolet/action-cable-tictactoe</a></li>
  <li>GitHub: <a href="https://github.com/yokolet/action-cable-tictactoe">https://github.com/yokolet/action-cable-tictactoe</a></li>
</ul>

<h3 id="rails-side">Rails Side</h3>

<p>On the Rails side, a connection and channels are main components for the application.
It depends on the application whether the connection should be implemented or used as is.
On the other hand, a channel need to be implemented to provide a specific service.</p>

<h4 id="connection">Connection</h4>

<p>As the <a href="https://guides.rubyonrails.org/v8.0/action_cable_overview.html#server-side-components-connections">Rails Guide</a>
explains, the main purpose of the connection (ApplicationCable::Connection) is an authentication and authorization.
However, ApplicationCable::Connection itself doesn’t authenticate a user.
Its usage is to verify the already authenticated/authorized user so that channels can identify an individual user.</p>

<p>In the Tic-Tac-Toe application, an encrypted cookie is created when the application is requested for the first time.</p>
<ul>
  <li><a href="https://gitlab.com/yokolet/action-cable-tictactoe/-/blob/main/app/controllers/home_controller.rb?ref_type=heads">app/controllers/home_controller.rb</a></li>
</ul>

<p>The encrypted cookie is verified in the WebSocket connection as a player id.
After successful verification, the user is identified by <code>current_player_id</code>.</p>
<ul>
  <li><a href="https://gitlab.com/yokolet/action-cable-tictactoe/-/blob/main/app/channels/application_cable/connection.rb?ref_type=heads">app/channels/application_cable/connection.rb</a></li>
</ul>

<p>The key word, <code>identified_by</code> is provided by Rails, so we can use it without doing anything extra.</p>

<h4 id="channel">Channel</h4>

<p>Application’s main logic is implemented in a channel. The API document shows what methods are defined in
<a href="https://api.rubyonrails.org/classes/ActionCable/Connection/Base.html">ActionCable::Channel::Base</a> class.
Among those, the application mostly implement a subscribe, unsubscribe, send or other methods to perform actions.</p>

<ul>
  <li><code>subscribe</code>: when a JavaScript client creates a channel, the subscribe method is called.</li>
  <li><code>unsubscribe</code>: when a WebSocket connection is closed, the unsubscribe method is called.</li>
  <li><code>perform action</code>: when a JavaScript client sends a payload, {action: “some_method”, …}, “some_method” is called to
perform the logic.</li>
</ul>

<p>After performing the logic in the channel,
broadcast and transmit methods are used to send the result back from the Rails side to JavaScript client.</p>

<ul>
  <li>broadcast: pushes the result to all subscribed JavaScript clients</li>
  <li>transmit: sends the result back to the only one JavaScript client who sends payload to the channel.</li>
</ul>

<p>The Tic-Tac-Toe application uses 3 types of channels. The PlayerChannel would be a good example since it is simple.</p>
<ul>
  <li><a href="https://gitlab.com/yokolet/action-cable-tictactoe/-/blob/main/app/channels/player_channel.rb?ref_type=heads">app/channels/player_channel.rb</a></li>
</ul>

<p>The PlayerChannel has a subscribe, unsubscribe, register, unregister, and heads_up methods.</p>
<ul>
  <li><code>subscribe</code>: using <code>stream_from</code> method, adds the client to the player_channel, then sends back the payload to the
client who tries to subscribe</li>
  <li><code>unsubscribe</code>: after removing the player name of this connection, broadcasts the updated player list to all subscribed clients</li>
  <li>[perform action] <code>register</code>: adds a new player name to the player list and sends back the payload to the client
who tries to register. In this application, “subscribe” doesn’t mean “register”. Without registering the player name,
clients can receive the broadcast player list.</li>
  <li>[perform action] <code>unregister</code>: JavaScript client explicitly removes its player name from the list.
The result is sent back to the client who tries to unregister</li>
  <li>[perform action] <code>heads_up</code>: broadcasts the updated player list. The method is called by the JavaScript client
when the client wants to broadcast the updated player list.</li>
</ul>

<h4 id="transmit-or-broadcast">transmit or broadcast</h4>

<p>The PlayerChannel of this application uses <code>transmit</code> for subscribe, register and unregister methods, which means
the results are not broadcast.
To broadcast, the client calls <code>heads_up</code> action after receiving the payload from <code>transmit</code>. It takes double paths.
At a glance, such architecture looks an excess. What if successful register broadcast the updated player list?
Unfortunately, that confuses the client application.
For example, upon a successful registration process, the client app wants to close registration form.
If the successful registration is broadcast, the client needs to figure out
the message is about its own or someone else’s successful registration.
So that the client application can act reactively, transmitting the result payload to the only client
who tries it works well.</p>

<h3 id="rspec">RSpec</h3>

<p>When it comes to a realistic application, testing is important. Testing Action Cable using RSpec is explained at
<a href="https://github.com/palkan/action-cable-testing">https://github.com/palkan/action-cable-testing</a>.
It is a gem called action-cable-testing. But, as far as using recent versions of Rails and RSpec,
we don’t need to install the gem. It is merged in Rails 6 and RSpec 4.</p>

<h4 id="connection-specs">Connection specs</h4>

<p>The testing framework provides <code>connect</code> method, which simulates the connection.
Once the <code>connect</code> method is called, we can use <code>connection</code> instance to test <code>identified_by</code> value.
The <code>cookies</code> is available to use in the spec, so we can add a cookie to test the connection.</p>

<p>The connection spec of this application:</p>
<ul>
  <li><a href="https://gitlab.com/yokolet/action-cable-tictactoe/-/blob/main/spec/channels/connection_spec.rb?ref_type=heads">spec/channels/connection_spec.rb</a></li>
</ul>

<p>The spec here tests whether <code>current_player_id</code> is set correctly.</p>

<h4 id="channel-specs">Channel specs</h4>

<p>The testing framework provides <code>stub_connection</code> and <code>subsscribe</code> utility methods.</p>

<ul>
  <li><code>stub_connection</code>: gives a connection stub. The identifier can be given as a parameter.</li>
  <li><code>subscribe</code>: subscribes to the channel.</li>
</ul>

<p>The specs for PlayerChannel:</p>
<ul>
  <li><a href="https://gitlab.com/yokolet/action-cable-tictactoe/-/blob/main/spec/channels/player_channel_spec.rb?ref_type=heads">spec/channels/player_channel_spec.rb</a></li>
</ul>

<p>The spec calls <code>stub_connection(current_player_id: uid)</code> in the before block.
By this, the <code>current_player_id</code> value is available to use in the channel methods.
In each spec, <code>subscribe</code> is called with a parameter. This simulate the the subscription has done.</p>

<p>To test subscription, we can do:</p>
<pre><code class="language-ruby">expect(subscription).to be_confirmed
expect(subscription).to have_stream_from('player_channel')
</code></pre>

<p>To test transmitted payload, <code>expect(transmissions.last).to eq({...})</code> does the job.</p>
<pre><code class="language-ruby">expect(transmissions.last).to eq({key: value})
</code></pre>

<p>As for testing a broadcast, <code>have_broadcasted_to</code> matcher does the job.</p>
<pre><code class="language-ruby">expect {
  perform :heads_up, {key1: value1}
}.to have_broadcasted_to("player_channel").with({key2: value2})
</code></pre>

<h3 id="javascript-side">JavaScript Side</h3>

<p>To connect to Rails’ WebSocket, <a href="https://www.npmjs.com/package/@rails/actioncable">@rails/actioncable</a>
JavaScript package would be the best library.
The package provides seamless interaction with WebSocket by Rails Action Cable.</p>

<p>Of course, @rails/actioncable is not the only one choice.
Since WebSocket is a protocol, it’s possible to write a connection library from scratch.
In the JavaScript world, well-known WebSocket libraries are out there also.
However, an ease of use, examples to learn about, and more reasons say @rails/actioncable is the best.</p>

<h4 id="basics-of-client-side">Basics of Client Side</h4>

<p>With @rails/actioncable library, a basic usage is below:</p>
<pre><code class="language-javascript">const channel = createConsumer()
    .subscriptions
    .create({ channel: 'CHANNEL_CLASS', key: value }, {
        received(data) {
            // do something
        }
    }
</code></pre>

<p>Above establishes WebSocket connection and calls channel’s subscribe method.
The channel to subscribe is a parameter to <code>create</code> method.
The callback function, <code>receieved</code> receives everything the channel sends back
such as the payload from channel’s transmit and broadcast methods.
The client side application should handle all of those.</p>

<p>To call perform action methods, use <code>channel.perform</code> function.</p>
<pre><code class="language-javascript">channel.perform("CHANNEL_METHOD", {key: value})
</code></pre>

<p>This Tic-Tac-Toe application uses Vue.js and Pinia (something like React + Redux).
The client implementation to use <code>PlayerChannel</code> is a Pinia store, <code>player.ts</code>.</p>
<ul>
  <li><a href="https://gitlab.com/yokolet/action-cable-tictactoe/-/blob/main/app/frontend/stores/player.ts?ref_type=heads">app/frontend/stores/player.ts</a></li>
</ul>

<p>In this application, the payload data is a Hash and has an action key always.
The action is a key to handle received data through WebSocket.
Depending on the action type, received data is processed and set to reactive variables.
The changes of reactive variables are taken care of by a JavaScript framework, in this application, Vue.js.</p>

<p>The client side implementation really varies.
Vue.js, React, Stimulus and many other JavaScript frameworks handles reactive data in their ways.
The basics here is to reflect the updated data to UI by own way.</p>

<h3 id="live-application">Live Application</h3>

<p>The multi-player, multi-board Tic-Tac-Toe application is live at:</p>
<ul>
  <li><a href="https://action-cable-tictactoe-2fbbd874419e.herokuapp.com/">https://action-cable-tictactoe-2fbbd874419e.herokuapp.com/</a></li>
</ul>

<h3 id="consideration">Consideration</h3>

<p>Creating a real-time application by Rails Action Cable is relatively easy.
The framework provides an easy to use API for both back-end and front-end.
The downside would be lack of up-to-date rich information.
Rails Guide gives enough info and examples, but those are fragments.
Google search often hit old Rails 6 examples and blog posts. 
It took a while to figure out how to code and test on Rails 7.
However, once those became clear, the development accelerated.</p>

<p>Try and have fun by creating a real-time application.</p>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[The previous two blog posts introduced WebSocket and how to implement a WebSocket application on Ruby on Rails. This blog post digs deeper. It is a memo on creating a more realistic application by Action Cable.]]></summary></entry><entry><title type="html">Real-time App on Rails by Action Cable</title><link href="http://localhost:4000/2024/08/08/real-time-app-on-rails-by-action-cable.html" rel="alternate" type="text/html" title="Real-time App on Rails by Action Cable" /><published>2024-08-08T23:27:00+09:00</published><updated>2024-08-08T23:27:00+09:00</updated><id>http://localhost:4000/2024/08/08/real-time-app-on-rails-by-action-cable</id><content type="html" xml:base="http://localhost:4000/2024/08/08/real-time-app-on-rails-by-action-cable.html"><![CDATA[<p>The previous blog post, <a href="/2024/08/02/websocket-on-rails-by-action-cable.html">WebSocket on Rails by Action Cable</a>,
focused on WebSocket as a protocol. As in the previous post, by default, Rails app responds to WebSocket connection
requests without any hassle. However, other than connecting and sending ping frames, it doesn’t do anything.
This blog post focuses on an application side and explains how we can create a full-duplex, bidirectional app.</p>

<h3 id="publishsubscribe-pubsub-architecture">Publish/Subscribe (Pub/Sub) architecture</h3>

<p>WebSocket itself is the protocol, so it is independent from an application architecture or framework.
In Rails, ActionCable::Connection::Base is an abstraction of WebSocket connection.</p>

<p>As an application framework on the full-duplex, bidirectional connection, Rails adapts Pub/Sub
(Publish/Subscribe) architecture. The Pub/Sub architecture is a general event-driven, asynchronous model for a
distributed system. The Pub/Sub architecture is independent from protocols, so it is not only for WebSocket.
If we name the Pub/Sub frameworks, <a href="https://kafka.apache.org/">Apache Kafka</a>, <a href="https://akka.io/">Akka</a>,
<a href="https://www.rabbitmq.com/">RabbitMQ</a>, and many more are out there.</p>

<p>In general, the Pub/Sub framework consists of publishers, a broker with topics (or channels), and subscribers.
The subscriber subscribes to a topic or topics to get updates.
When the publisher send a message to a broker, the broker sends the message to the related topic.
Then, the message will be distributed to subscribers who subscribed to the topic previously.</p>

<p><img width="1200px" src="/assets/img/GeneralPubSub.jpg" alt="img: Pub/Sub architecture in general" /></p>

<p>Rails provides a bit simplified version of Pub/Sub architecture.
For Rails, both publishers and subscribers are a web application client.
The idea of consumer is introduced as an abstraction of publishers and subscribers.
Using JavaScript library, a consumer is created tied to the specific channel.
The publisher sends a message through the consumer.
When the publisher wants to send the message to a specific method, it performs the corresponding action with the message.
Once the message arrives to the channel, the message will be broadcast to subscribers.
In the end, the broadcast message is received by the subscriber through the consumer.</p>

<p><img width="1200px" src="/assets/img/RailsPubSub.jpg" alt="img: Rails Pub/Sub architecture" /></p>

<h3 id="chat-simple-real-time-application">Chat: Simple Real-time Application</h3>

<p>It’s time to create a Rails app. The application here is a very simple chat app.
The application needs a JavaScript library which has an ability to behave reactively when the broadcast message comes in.
Here, the app uses Vue.js version 3 with composition API.</p>

<h4 id="create-rails-app">Create Rails app</h4>

<p>As always, the first step is to create a Rails app. The application doesn’t need some libraries, so it uses the rc file
below to skip those.</p>

<pre><code class="language-bash">--skip-action-mailer
--skip-action-mailbox
--skip-action-text
--skip-active-job
--skip-active-storage
-J
-T
</code></pre>

<p>Save above to <code>.railsrc</code> file, or whatever the file name you like.</p>

<pre><code class="language-bash">$ rails new action-cable-chat --rc=./.railsrc
</code></pre>

<h4 id="create-a-vue-app-mount-point">Create a Vue app mount point</h4>

<p>So that the root path shows Vue.js page, create a mount point.</p>

<pre><code class="language-bash">$ cd action-cable-chat
$ bin/rails g controller home index
</code></pre>

<p>Edit <code>app/views/home/index.html.erb</code> to create a mount point, <code>#app</code>.</p>

<pre><code class="language-erbruby">&lt;%= content_tag(:div, "", id:"app") %&gt;
</code></pre>

<p>Additionally, update <code>config/routes.rb</code>.</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root 'home#index'
  # ...
  # ...
end
</code></pre>

<h4 id="install-and-setup-vite_rails">Install and setup vite_rails</h4>

<p>Since the app uses Vue.js on the frontend side, <code>vite_rails</code> gem should be installed and setup.
Try below:</p>

<pre><code class="language-bash">$ bundle add vite_rails
$ bundle exec vite install
</code></pre>

<h4 id="install-vuejs">Install Vue.js</h4>

<p>At this point, <code>package.json</code> and <code>package-lock.json</code> are created.
Since we use <code>yarn</code> instead of <code>npm</code>, remove <code>package-lock.json</code> and run <code>yarn install</code>.</p>

<pre><code class="language-bash">$ rm package-lock.json
$ yarn install
</code></pre>

<p>For now, we are ready to install Vue.js. Run blow to add two packages:</p>

<pre><code class="language-bash">$ yarn add vue @vitejs/plugin-vue
</code></pre>

<p>Then, edit <code>vite.config.ts</code> to add Vue plugin.</p>

<pre><code class="language-javascript">// vite.config.ts
import { defineConfig } from 'vite'
import RubyPlugin from 'vite-plugin-ruby'
import vue from '@vitejs/plugin-vue' // added

export default defineConfig({
    plugins: [
        RubyPlugin(),
        vue(),  // added
    ],
})
</code></pre>

<h4 id="create-a-starter-script">Create a starter script</h4>

<p>When vite was installed, Profile.dev was updated as well to start two servers: one for backend, another for frontend.
To avoid typing <code>foreman start -f Procfile.dev</code> everytime, create a <code>bin/dev</code> file with the content below:</p>

<pre><code class="language-bash">#!/usr/bin/env sh

if gem list --no-installed --exact --silent foreman; then
  echo "Installing foreman..."
  gem install foreman
fi

# Default to port 3000 if not specified
export PORT="${PORT:-3000}"

exec foreman start -f Procfile.dev "$@"
</code></pre>

<p>Change the file permission to executable by <code>chmod 755 bin/dev</code>.</p>

<h4 id="create-a-pubsub-channel">Create a Pub/Sub channel</h4>

<p>So far, all settings were completed.
Now, it’s time to write code for a chat app.</p>

<p>We start from creating a channel for Pub/Sub.
Rails provides a generator to create a channel, so type below:</p>

<pre><code class="language-bash">$ bin/rails g channel chat speak
</code></pre>

<p>Above command creates <code>app/channels/chat_channel.rb</code> file with a minimal implementation.
Update <code>subscribe</code> and <code>speak</code> method as in below:</p>

<pre><code class="language-ruby"># app/channels/chat_channel.rb
class ChatChannel &lt; ApplicationCable::Channel
  def subscribed
    stream_from "chat_channel"
  end

  def unsubscribed
    # Any cleanup needed when channel is unsubscribed
  end

  def speak(data)
    ActionCable.server.broadcast("chat_channel", data)
  end
end
</code></pre>

<p>The method, <code>subscribed</code>, defines the channel whose name is chat_channel.
The method, <code>speak</code>, broadcast message to clients who subscribed to the chat_channel.
That’s all for the server side.</p>

<h4 id="install-railsactioncable-package">Install @rails/actioncable package</h4>

<p>Since WebSocket is a protocol, we may use any libraries for WebSocket, for example, <a href="https://socket.io/">Socket.IO</a>.
However, it’s much better to use Rails provided package to connect to the backend seamlessly.
Run below to install <code>@rails/actioncable</code> package.</p>

<pre><code class="language-bash">$ yarn add @rails/actioncable 
</code></pre>

<h4 id="write-frontend-code">Write frontend code</h4>

<p>The last piece is a Vue.js app.
Create a Vue component, <code>app/frontend/App.vue</code>, with the content below:</p>

<pre><code class="language-javascript">&lt;script setup&gt;
import { ref } from 'vue';
const message = ref("");
const messages = ref([]);
import { createConsumer } from '@rails/actioncable';

const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
const consumer = createConsumer(`${protocol}://${window.location.host}/cable`);
const channel = consumer.subscriptions.create({ channel: 'ChatChannel' }, {
  received(data) {
    messages.value.push(data['message']);
  }
});

const addNewMessage = () =&gt; {
  channel.perform('speak', { message: message.value });
}
&lt;/script&gt;

&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;h2&gt;Action Cable Example&lt;/h2&gt;
    &lt;div class="info"&gt;Type something in the box below and hit enter&lt;/div&gt;
    &lt;form @submit.prevent="addNewMessage"&gt;
      &lt;input
          type="text"
          placeholder="say something"
          minlength="1"
          maxlength="50"
          v-model.trim="message" /&gt;
    &lt;/form&gt;
    &lt;div class="messages"&gt;
      &lt;ul class="message"&gt;
        &lt;li v-for="message in messages"&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>

<p>Everything of frontend is here. The above Vue component does:</p>
<ul>
  <li>Creates a consumer using <code>createConsumer</code> function provided by Rails’ actioncable package. <br />
By default, WebSocket is mounted on <code>/cable</code>, so the URL to WebSocket is used to an argument of <code>createConsumer</code>.</li>
  <li>Creates a channel by subscribing to the channel, <code>ChatChannel</code>. <br />
The channel name is a channel class name on Rails side, so it is a camel case of ChatChannel.</li>
  <li>At the same time, implements <code>received</code> function to update the <code>messages</code> value when a new message comes in.</li>
  <li>Calls <code>addNewMessage</code> function when something is typed in the input box and hit enter. <br />
The function hits channel’s perform function to send the message to <code>speak</code> method defined in ChatChannel class on the server side.</li>
</ul>

<p>To make the Vue component work, we need a small additional work.
Edit <code>app/frontend/entrypoints/application.js</code> to add below:</p>

<pre><code class="language-javascript">import { createApp } from 'vue';
import App from '~/App.vue';
import '~/styles.css'

createApp(App).mount('#app');
</code></pre>

<p>The mount point <code>#app</code> was already created on the backend side.
To look better, the Vue component uses the <code>style.css</code> below.</p>

<pre><code class="language-css">* {
  box-sizing: border-box;
}

html {
  font-family: sans-serif;
}

body {
  margin: 0;
}

#app {
  margin: 3rem auto;
  border-radius: 10px;
  padding: 1rem;
  width: 90%;
  max-width: 40rem;
}

#app h2 {
  font-size: 1.5rem;
  border-bottom: 2px solid #ccc;
  color: #af463d;
  margin: 0 0 1rem 0;
}

#app .info {
  font-size: 1rem;
  color: #544f4f;
  margin: 0 0 1rem 0;
}

#app .messages {
  font-size: 1rem;
  color: #544f4f;
  margin: 1rem 0 1rem 0;
}

#app .message {
  font-size: 1rem;
  color: #4d4848;
  margin: 0 0 1rem 0;
}

#app input {
  font: inherit;
  border: 1px solid #aaa;
  background-color: #eee;
}

#app input:focus {
  outline: none;
  border-color: #754340;
  background-color: #fff;
}
</code></pre>

<h4 id="run-the-app-and-try-real-time-chat">Run the app and try real-time chat</h4>

<p>We have already created <code>bin/dev</code> starter command. Type it and start servers.</p>

<pre><code class="language-bash">$ bin/dev
</code></pre>

<p>Open <code>http://localhost:3000</code> on multiple different browsers or private windows.
Type something in the input box and hit enter.
The message appears on all browsers immediately.
Below are the result on Safari, FireFox and Chrome.</p>

<p><img width="600px" src="/assets/img/action-cable-chat-safari.jpeg" alt="img: Chat on Safari" /> <br />
<img width="600px" src="/assets/img/action-cable-chat-firefox.jpeg" alt="img: Chat on FireFox" /> <br />
<img width="600px" src="/assets/img/action-cable-chat-chrome.jpeg" alt="img: Chat on Chrome" /></p>

<h3 id="conclusion">Conclusion</h3>

<p>WebSocket and Action Cable are not easy ideas to understand.
However, once we do, an implementation using Rails Action Cable is not difficult.
We can create more interesting real-time applications by Action Cable.</p>

<h3 id="comments-and-discussions">Comments and Discussions</h3>

<p>GitHub Discussions: <a href="https://github.com/yokolet/new-note/discussions/9">Real-time App on Rails by Action Cable #9</a></p>

<h3 id="references">References</h3>
<ul>
  <li>GitHub Repo: <a href="https://github.com/yokolet/action-cable-chat">https://github.com/yokolet/action-cable-chat</a></li>
  <li>Publisher-Subscriber Model: <a href="https://www.baeldung.com/cs/publisher-subscriber-model">https://www.baeldung.com/cs/publisher-subscriber-model</a></li>
  <li>Akka: <a href="https://akka.io/">https://akka.io/</a></li>
  <li>Apache Kafka: <a href="https://kafka.apache.org/">https://kafka.apache.org/</a></li>
  <li>Redis Pub/Sub: <a href="https://redis.io/docs/latest/develop/interact/pubsub/">https://redis.io/docs/latest/develop/interact/pubsub/</a></li>
  <li>Rails Guides, Action Cable Overview: <a href="https://guides.rubyonrails.org/action_cable_overview.html">https://guides.rubyonrails.org/action_cable_overview.html</a></li>
  <li>Action Cable Hello World With Rails 7: <a href="https://blog.dennisokeeffe.com/blog/2022-02-28-action-cable-hello-world-with-rails-7">https://blog.dennisokeeffe.com/blog/2022-02-28-action-cable-hello-world-with-rails-7</a></li>
  <li>Creating a Chat Using Rails’ Action Cable: <a href="https://www.pluralsight.com/resources/blog/guides/creating-a-chat-using-rails-action-cable">https://www.pluralsight.com/resources/blog/guides/creating-a-chat-using-rails-action-cable</a></li>
  <li>Getting more comfortable with Action Cable: <a href="https://medium.com/craft-academy/getting-more-comfortable-with-action-cable-2b4bc758c57f">https://medium.com/craft-academy/getting-more-comfortable-with-action-cable-2b4bc758c57f</a></li>
  <li>Deconstructing Action Cable: <a href="https://stanko.io/deconstructing-action-cable-DC7F33OsjGmK">https://stanko.io/deconstructing-action-cable-DC7F33OsjGmK</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[The previous blog post, WebSocket on Rails by Action Cable, focused on WebSocket as a protocol. As in the previous post, by default, Rails app responds to WebSocket connection requests without any hassle. However, other than connecting and sending ping frames, it doesn’t do anything. This blog post focuses on an application side and explains how we can create a full-duplex, bidirectional app.]]></summary></entry><entry><title type="html">WebSocket on Rails by Action Cable</title><link href="http://localhost:4000/2024/08/03/websocket-on-rails-by-action-cable.html" rel="alternate" type="text/html" title="WebSocket on Rails by Action Cable" /><published>2024-08-03T00:10:00+09:00</published><updated>2024-08-03T00:10:00+09:00</updated><id>http://localhost:4000/2024/08/03/websocket-on-rails-by-action-cable</id><content type="html" xml:base="http://localhost:4000/2024/08/03/websocket-on-rails-by-action-cable.html"><![CDATA[<p>In the web application domain, we hear some protocol names.
Absolutely, HTTP or HTTPS is the most famous protocol that all web developers know.
Although there’s a mechanism of <a href="/2024/07/17/conserving-network-resources-keep-alive.html">Keep-Alive</a>,
a single request/response sequence with a single client/server is all done by HTTP.
The client initiates the HTTP request to the server. Once the client receives the HTTP response from the server,
communication finishes. As far as HTTP is used, the server just waits and waits. Only when the request comes in, the
server can send back some data to the client. This communication style is surprisingly capable of doing many things,
so most web applications are satisfied with HTTP.</p>

<p>But! Let’s think of a chat application. Two or more people write messages to each other.
How do we see newer messages from other folks? Reload every time?
Definitely, no. We don’t want to click a reload button every time to see newer ones.
For this type of communication, a protocol called WebSocket has been created.
Since then, WebSocket is used for a chat, multi-player game, online presence status, and more.
This blog post is about WebSocket protocol and how Ruby on Rails handles it.</p>

<h3 id="what-is-websocket-protocol">What is WebSocket protocol</h3>

<p>WebSocket is a protocol defined by <a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC6455</a>.
As many documents or blog posts explain, WebSocket provides a two-way interactive communication session
over a single TCP connection. The two-way interactive communication is often called a full-duplex bidirectional
communication. Not like HTTP, both client and server can send data each other.</p>

<h4 id="websocket-handshake">WebSocket Handshake</h4>

<p>The communication by WebSocket initially starts from normal HTTP request/response. Then the communication is upgraded to
WebSocket. Once the bidirectional communication establishes, a single TCP connection is used to send/receive data
until a client or server closes the connection.</p>

<p>The initial HTTP request/response sequence is called a WebSocket handshake.
<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">MDN (Mozilla Developer Network) document</a>
explains how the handshake goes.
Suppose the server listens to the WebSocket request at http://example.com/chat, the client sends the HTTP request
something like below:</p>

<pre><code>GET /chat HTTP/1.1
Host: example.com:8000
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
</code></pre>

<p>The HTTP request header above has Connection: Upgrade and Upgrade: websocket. These are keys to get started.
Also, Sec-WebSocket-Key header field is there. The value is basically 16 bytes base 64 encoded string.
Precisely, the forgiving-base64-encoded or isomorphic encoded is used to create a string.
The key is used to avoid <a href="https://portswigger.net/web-security/websockets/cross-site-websocket-hijacking">Cross-site WebSocket hijacking</a>.</p>

<p>When the server receives the upgrade request, it returns something like below as a response.</p>

<pre><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
</code></pre>

<p>The status code is 101.
Upon receiving the response above, the protocol is upgraded to WebSocket.
Among the response header field, we see a Sec-WebSocket-Accept field.
It is the answer to Sec-WebSocket-Key from the client.
The client can verify the server when it receives the Sec-WebSocket-Accept.</p>

<p>The Sec-WebSocket-Accept value is created by the steps below:</p>
<ol>
  <li>Concatenate Sec-WebSocket-Key field value in the request and GUID value, <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>.<br />
 The GUID value is always the same, a magic number.</li>
  <li>Take SHA1 hash and base64 encode.</li>
</ol>

<p>In Ruby, the encoding can be done by Digest::SHA1.base64digest.
Let’s try above Sec-WebSocket-Key and see if the same value of Sec-WebSocket-Accept will be created.</p>

<pre><code class="language-bash">$ irb
irb(main):001&gt; require 'digest'
=&gt; false
irb(main):002&gt; key = 'dGhlIHNhbXBsZSBub25jZQ=='
=&gt; "dGhlIHNhbXBsZSBub25jZQ=="
irb(main):003&gt; magic = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
=&gt; "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
irb(main):004&gt; accpt = Digest::SHA1.base64digest(key + magic)
=&gt; "s3pPLMBiTxaQ9kYGzzhZRbK+xOo="
</code></pre>

<p><img width="1000px" src="/assets/img/WebSocket.jpg" alt="img: WebSocket" /></p>

<h4 id="websocket-heartbeat">WebSocket Heartbeat</h4>

<p>After the WebSocket connection is established, a client or server can send a ping to a counterpart.
The client or server who receives the ping must return a pong to the other side immediately or within a certain time frame.
This is the heartbeat of the WebSocket.</p>

<p>The heartbeat by pinging is useful for handling the connection for the reasons below:</p>
<ul>
  <li>verify the client and server are connected</li>
  <li>prevent firewalls and proxies from terminating inactive connections</li>
</ul>

<p>That is all about WebSocket as a protocol.</p>

<h3 id="action-cable">Action Cable</h3>

<p>Ruby on Rails supports WebSocket by Action Cable. The Action Cable was introduced on Rails 5.
Just including (or not skipping) Action Cable makes WebSocket available to use.
Let’s try Action Cable.</p>

<h4 id="create-a-rails-app">Create a Rails app</h4>

<p>Rails is an all-inclusive type web framework. All features are supported by default.
We don’t need to do anything special to enable Action Cable while creating a Rails app.
Only when <code>--minimal</code> or <code>--skip-action-cable</code> option is specified, Action Cable is not included.
Even when <code>--api</code> option is specified, Action Cable a.k.a WebSocket is supported.</p>

<p>For a simplicity, create a Rails app with default options.</p>

<pre><code class="language-bash">$ rails new just-a-sample
</code></pre>

<h4 id="test-websocket">Test WebSocket</h4>

<p>Nothing special. Go to just-a-sample directory and start the Rails server.</p>

<pre><code class="language-bash">$ cd just-a-sample
$ bin/rails s
</code></pre>

<p>That’s it. WebSocket is ready to accept the request.
ActionCable.server is mounted on /cable by default, so using a curl command, try below HTTP request.</p>

<pre><code class="language-bash">$ curl --http1.1 -i -N \
&gt; -H 'Sec-Websocket-Version: 13' \
&gt; -H 'Sec-Websocket-Key: QUo86XL2bHszCCpigvKqHg==' \
&gt; -H "Connection: Upgrade" \
&gt; -H "Upgrade: websocket" \
&gt; -H "Origin: http://localhost:3000/cable" \
&gt; http://localhost:3000/cable
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: 8dlVwoWynsF/RauFo6HjkWl7dLk=

�{"type":"welcome"}�${"type":"ping","message":1722608438}�${"type":"ping","message":1722608441}�${"type":"ping",
"message":1722608444}�${"type":"ping","message":1722608447}
</code></pre>

<p>As we see, the status code 101 is returned. The connection is upgraded to WebSocket, and Sec-WebSocket-Accept is returned.
Right after the connection is established, a welcome message is sent back. Then, ping messages come in a fixed interval.</p>

<p>On the console that the Rails server is running, we see the message below:</p>

<pre><code class="language-bash">Started GET "/cable" for ::1 at 2024-08-02 23:20:35 +0900
Started GET "/cable" [WebSocket] for ::1 at 2024-08-02 23:20:35 +0900
Successfully upgraded to WebSocket (REQUEST_METHOD: GET, HTTP_CONNECTION: Upgrade, HTTP_UPGRADE: websocket)
</code></pre>

<p>When, the curl command quits by hitting control-c, the message below shows up:</p>
<pre><code class="language-bash">Finished "/cable" [WebSocket] for ::1 at 2024-08-02 23:20:48 +0900
</code></pre>

<h3 id="note">Note</h3>

<p>As we see, starting WebSocket on Rails is very easy, zero configuration.
That’s a good news, but also a bad news.
If the Rails app is created without –skip-action-cable option, the app accepts WebSocket requests.
The app keeps sending ping frames to the clients who requested a WebSocket connection.
What if many curl requests try to establish WebSocket connections?
The ping frame is light weight, and the WebSocket connection can’t do anything except sending pings.
The risk of data breach or session hijacking would be almost zero, however, DoS (DDoS) type attack might be possible.</p>

<p>It’s a good practice to specify –skip-action-cable option if the app doesn’t need WebSocket.</p>

<h3 id="comments-and-discussions">Comments and Discussions</h3>

<p>GitHub Discussions: <a href="https://github.com/yokolet/new-note/discussions/10">WebSocket on Rails by Action Cable #10</a></p>

<h3 id="references">References</h3>

<ul>
  <li>RFC6455 The Websocket Protocol: <a href="https://datatracker.ietf.org/doc/html/rfc6455">https://datatracker.ietf.org/doc/html/rfc6455</a></li>
  <li>Rails Guides: Action Cable Overview: <a href="https://guides.rubyonrails.org/action_cable_overview.html">https://guides.rubyonrails.org/action_cable_overview.html</a></li>
  <li>MDN: Writing WebSocket servers: <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers</a></li>
  <li>A simple guide to Action Cable: <a href="https://dev.to/lucaskuhn/a-simple-guide-to-action-cable-2dk2">https://dev.to/lucaskuhn/a-simple-guide-to-action-cable-2dk2</a></li>
  <li>Understanding Action Cable in Rails 7: <a href="https://patrickkarsh.medium.com/understanding-action-cable-in-rails-7-24e942f6a8d7">https://patrickkarsh.medium.com/understanding-action-cable-in-rails-7-24e942f6a8d7</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[In the web application domain, we hear some protocol names. Absolutely, HTTP or HTTPS is the most famous protocol that all web developers know. Although there’s a mechanism of Keep-Alive, a single request/response sequence with a single client/server is all done by HTTP. The client initiates the HTTP request to the server. Once the client receives the HTTP response from the server, communication finishes. As far as HTTP is used, the server just waits and waits. Only when the request comes in, the server can send back some data to the client. This communication style is surprisingly capable of doing many things, so most web applications are satisfied with HTTP.]]></summary></entry><entry><title type="html">Conserving Network Resources – Keep-Alive</title><link href="http://localhost:4000/2024/07/17/conserving-network-resources-keep-alive.html" rel="alternate" type="text/html" title="Conserving Network Resources – Keep-Alive" /><published>2024-07-17T21:05:00+09:00</published><updated>2024-07-17T21:05:00+09:00</updated><id>http://localhost:4000/2024/07/17/conserving-network-resources-keep-alive</id><content type="html" xml:base="http://localhost:4000/2024/07/17/conserving-network-resources-keep-alive.html"><![CDATA[<p>“When you type a URL in your browser, what will happen?”
If you are a web developer, you might have answered this sort of interview question once or twice.
It would be a popular question to test the knowledge how the Internet works.
As it is famous, you will find many answers here and there online.</p>

<p>A common answer includes steps below:</p>
<ol>
  <li>DNS Resolution</li>
  <li>TCP Three-Way Handshake</li>
  <li>HTTPS Upgrade (SSL/TLS Handshake)</li>
  <li>HTTP Request/Response</li>
  <li>Browser Rendering</li>
</ol>

<p>This blog post focuses on the first three steps: DNS, TCP, and TLS, to think how the technology conserves the network
resources.</p>

<h3 id="dns-resolution">DNS Resolution</h3>

<p>To get website contents, devices send a TCP packet. The essential components of TCP packet are a
destination IP address and destination port. However it is not convenient to type 142.250.207.14, 17.253.144.10, or
54.239.28.85 in the URL box to go to Google, Apple or Amazon websites.
Sure, people type google.com, apple.com or amazon.com instead of IP addresses.</p>

<p>The first step is to find an IP address based on a given URL string. This is done by Domain Name Service (or DNS).
DNS provides a domain name to IP address mapping service and is basically a huge distributed database.
As you may know, DNS servers form a hierarchical structure.
On the top layer, 13 root servers are there:</p>
<ul>
  <li>a: Verisign, Los Angels CA</li>
  <li>b: USC-ISI, Marina del Rey, CA</li>
  <li>c: Cogent, Herndon, VA</li>
  <li>d: U Maryland, College Park, MD</li>
  <li>e: NASA, Mt. View, CA</li>
  <li>f: Internet Software C., Palo Alto, CA</li>
  <li>g: US DoD, Columbus, OH</li>
  <li>h: ARL, Aberdeen, MD</li>
  <li>i: Netnod, Stockholm</li>
  <li>j: Verisign, Dulles, VA</li>
  <li>k: RIPE, London</li>
  <li>l: ICANN, Los Angels, CA</li>
  <li>m: WIDE, Tokyo</li>
</ul>

<p>The next is a layer of Top-level domain (TLD) servers. These servers handle top-level domains such as .com, .org, .net, .edu
and .gov and all of the country top-level domains such as .uk, .fr, .ca, and .jp. The third layer is Authoritative DNS
servers. Many organizations run authoritative DNS servers. Among them, Cloudflare, Google and some more
provides publicly accessible DNS servers.</p>

<p>To get the IP address from URL string, browsers/devices make queries to a local DNS server.
It might be an Internet Service Provider (or ISP) DNS server and often called DNS resolver.
The local DNS server asks to the root DNS server and get a referral – what TLD DNS server likely knows the domain.
Then, the local DNS server asks to the specified TLD DNS server.
Again, the local DNS server get the referral from the TLD DNS server.
Lastly, the local DNS server goes to the specified authoritative DNS server to get the IP address.</p>

<p>It is a long way to finally get the IP address, however, domain name and IP address mappings are cached in certain points.
A browser and OS have a cache. The local DNS server has a cache as well.
If the mapping is in the cache, it is a much shorter way.</p>

<p><img width="1000px" src="/assets/img/DNS_query.jpg" alt="img: DNS query" /></p>

<h3 id="tcp-three-way-handshake">TCP Three-Way Handshake</h3>

<p>The second step is the TCP three-way handshake.
TCP (Transmission Control Protocol) is frequently compared to UDP (User Datagram Protocol).
While TCP is described as connection-oriented, UDP is connectionless.
TCP establishes the connection before data transfer begins. This phase is called the three-way handshake.</p>

<p>As the name expresses, the three-way handshake consists of 3 phases.</p>
<ul>
  <li>Phase 1: A client sends a SYN segment, which contains SYN bit 1 and randomly chosen client initial sequence number.</li>
  <li>Phase 2: A server receives the SYN segment and grants it. The server sends back a SYNACK segment, which contains
  SYN bit 1, client initial sequence number + 1, and randomly chosen server initial sequence number.</li>
  <li>Phase 3: The client receives SYNACK segment and acknowledges it. The client sends back the acknowledgement, which
  contains SYN bit 0, client initial sequence number + 1 and server initial sequence number + 1.</li>
</ul>

<p>After above three phases are completed, data can be sent over TCP.</p>

<p><img width="1000px" src="/assets/img/TCP-3Way-Handshake.jpg" alt="img: TCP 3 Way Handshake" /></p>

<h3 id="https-upgrade-ssltls-handshake">HTTPS Upgrade (SSL/TLS Handshake)</h3>

<p>The third step is TLS handshake. This handshake is much more complicated compared to TCP handshake.
TLS handshake goes like this:</p>

<ol>
  <li>ClientHello: The client initiates the handshake by sending a message containing its supported protocols,
 cipher suites, and random session ID.</li>
  <li>ServerHello: The server responds with its chosen protocol, cipher suite, and session ID.</li>
  <li>Certificate: The server sends its digital certificate, which contains its public key and identity information.</li>
  <li>Key Exchange: The client and server use asymmetric encryption to exchange cryptographic keys,
 ensuring secure communication.</li>
  <li>Change Cipher Spec: Both parties send a “change cipher spec” message to indicate they are switching to
 the new symmetric encryption key.</li>
  <li>Finished: The client and server exchange “finished” messages to verify the integrity of the handshake and ensure
 both parties agree on the session parameters.</li>
</ol>

<p>Finally, web contents are ready to be downloaded to the browsers or devices.</p>

<h3 id="numbers-of-three-steps">Numbers of three steps</h3>

<p>At this point, we learn gory details of DNS lookup, TCP and TLS handshakes.
Well, let’s look at numbers related to the 3 steps above.</p>

<h4 id="number-of-dns-lookups">Number of DNS lookups</h4>

<p>It is said that DNS traffic is extremely busy.
<a href="https://news.ycombinator.com/item?id=36984419">This Hacker News post</a> says
“1.1.1.1 is now handling more than 1.3T requests per day.”
The 1.1.1.1 is a Cloudflare DNS server. Only one authoritative DNS server has to deal with 1.3T requests per day!
The post is 11 months ago from middle of July 2024, so data was taken around June 2023.
Here is another a bit old data.
A Reddit post from 2018 says, only one Pi-Hole DNS server processed around 18,000 DNS queries per day.
If we think of the number of public authoritative DNS servers, global DNS lookups may go up to 10 trillion
or more per day these days.</p>

<p>To conclude, DNS traffic is really extremely busy.</p>

<h4 id="time-needed-for-dns-lookup-tcptls-handshakes">Time needed for DNS lookup, TCP/TLS handshakes</h4>

<p>The number is from an AI assisted answer popped up by online search. So, the numbers are just an estimation.</p>

<ul>
  <li>DNS lookup: 10-100 milliseconds <br />
  varies depending on the complexity of the domain name, DNS server performance, and network latency.</li>
  <li>TCP handshake: 10-30 milliseconds</li>
  <li>TLS handshake: 200-1000 milliseconds <br />
  varies depending on the TLS version, the complexity of the certificate, and network latency.</li>
</ul>

<p>As the unit is milliseconds, overall performance looks not so bad. However, when the sequence repeats many times,
combined performance might not be negligible.</p>

<h3 id="here-comes-the-keep-alive">Here Comes the Keep-Alive</h3>

<p>If you are a web developer, you are sure to know that HTTP protocol is stateless.
The connection is closed once a request/response sequence is completed.
When someone type the URL on the browser, a DNS look up runs followed by a TCP handshake and TLS handshake.
Finally, web contents are shown up on the browser. At this point, the connection is closed.
When the same person clicks a button in the web page just shown up, again gory stuff explained above repeats.
The DNS lookup runs followed by the TCP handshake and TLS handshake.
The same person might click another button in the same web page. The previous connection is already closed.
So, DNS lookup, TCP handshake, and TLS handshake are performed, then finally, the web contents show up.</p>

<p>We are like: Oh, it’s a prime day. Let’s go to Amazon and click, click, click …….
Wow, what if every click triggers DNS lookup, TCP handshake, and TLS handshake?
How many people on earth do click, click, click ……?
The Internet world must be really extremely busy.</p>

<p>But, smart people are out there. They have invented a way to avoid repeating three steps.
Yes, it is the keep-alive.
The keep-alive is a mechanism to let the connection open. The consecutive HTTP request/response sequences can
skip DNS lookup, TCP handshake and TLS handshake. Using the keep-alive improves overall web performance
as well as conserves network resources.
Apparently, the number of DNS look ups is cut down.</p>

<p>During the era of HTTP/1.0, a client or server should explicitly specify the keep-alive in the HTTP header
like below:</p>

<pre><code>Connection: Keep-Alive
Keep-Alive: timeout=5, max=1000
</code></pre>

<p>The timeout is the time in seconds that the host will allow an idle connection to remain open.
The max is the maximum number of requests that can be sent on this connection.</p>

<p>Now, HTTP/1.1 is out. The keep-alive becomes a default behavior. Below is an excerpt from RFC2616 section 8.1.2</p>
<blockquote>
  <p>A significant difference between HTTP/1.1 and earlier versions of
HTTP is that persistent connections are the default behavior of any
HTTP connection. That is, unless otherwise indicated, the client
SHOULD assume that the server will maintain a persistent connection,
even after error responses from the server.</p>
</blockquote>

<h3 id="test-keep-alive">Test Keep-Alive</h3>

<p>Well, we know Rails 7 supports HTTP/1.1, so does the keep-alive.
The keep-alive should be available and working.
But, is there any way to test the keep-alive is working?
It is very simple. Use curl command and request twice.</p>

<p>Let’s try some. The first test is to make sure the keep-alive is working.</p>
<pre><code class="language-bash">$ curl -Iv http://localhost:3000  -o /dev/null http://localhost:3000
* Host localhost:3000 was resolved.
* IPv6: ::1
* IPv4: 127.0.0.1
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying [::1]:3000...
* Connected to localhost (::1) port 3000
&gt; HEAD / HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/8.6.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; x-frame-options: SAMEORIGIN
&lt; x-xss-protection: 0
&lt; x-content-type-options: nosniff
#...(snip snip snip)...
&lt; Content-Length: 0
&lt;
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
* Connection #0 to host localhost left intact
* Found bundle for host: 0x600002e64480 [serially]
* Can not multiplex, even if we wanted to
* Re-using existing connection with host localhost
&gt; HEAD / HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/8.6.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
HTTP/1.1 200 OK
&lt; x-frame-options: SAMEORIGIN
x-frame-options: SAMEORIGIN
&lt; x-xss-protection: 0
x-xss-protection: 0
&lt; x-content-type-options: nosniff
x-content-type-options: nosniff
#...(snip snip snip)...
&lt; Content-Length: 0
Content-Length: 0

&lt;
* Connection #0 to host localhost left intact
</code></pre>

<p>Focus on the lines <code>* Connection #0 to host localhost left intact</code> and
<code>* Re-using existing connection with host localhost</code>.  Those are the evidence that the keep-alive is working.</p>

<p>For a comparison, let’s add <code>Connection: close</code> to the request header to test the keep-alive disabled.</p>

<pre><code class="language-bash">$ curl -Iv http://localhost:3000  -o /dev/null http://localhost:3000  -H "Connection: close"
* Host localhost:3000 was resolved.
* IPv6: ::1
* IPv4: 127.0.0.1
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying [::1]:3000...
* Connected to localhost (::1) port 3000
&gt; HEAD / HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/8.6.0
&gt; Accept: */*
&gt; Connection: close
&gt;
&lt; HTTP/1.1 200 OK
&lt; x-frame-options: SAMEORIGIN
&lt; x-xss-protection: 0
&lt; x-content-type-options: nosniff
#...(snip snip snip)...
&lt; Connection: close
&lt; Content-Length: 0
&lt;
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0
* Closing connection
* Hostname localhost was found in DNS cache
*   Trying [::1]:3000...
* Connected to localhost (::1) port 3000
&gt; HEAD / HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/8.6.0
&gt; Accept: */*
&gt; Connection: close
&gt;
&lt; HTTP/1.1 200 OK
HTTP/1.1 200 OK
&lt; x-frame-options: SAMEORIGIN
x-frame-options: SAMEORIGIN
&lt; x-xss-protection: 0
x-xss-protection: 0
&lt; x-content-type-options: nosniff
x-content-type-options: nosniff
#...(snip snip snip)...
&lt; Connection: close
Connection: close
&lt; Content-Length: 0
Content-Length: 0

&lt;
* Closing connection
</code></pre>

<p>We see the line <code>* Closing connection</code>, so we know the keep-alive becomes off.</p>

<p>Additionally, the second connection says <code>* Hostname localhost was found in DNS cache</code>, which means
the second DNS look up hits the cache.</p>

<p>“When you type a URL in your browser, what will happen?” is the interesting question.
We can learn how the Internet works as well as the network resource conservation and web performance.</p>

<h3 id="references">References</h3>
<ul>
  <li>Optimizing HTTP: Keep-alive and Pipelining: <a href="https://www.igvita.com/2011/10/04/optimizing-http-keep-alive-and-pipelining/">https://www.igvita.com/2011/10/04/optimizing-http-keep-alive-and-pipelining/</a></li>
  <li><a href="https://medium.com/@roopa.kushtagi/mastering-dns-a-comprehensive-overview-of-internet-address-translation-73793d0598ba">Mastering DNS: A Comprehensive Overview of Internet Address Translation</a></li>
  <li><a href="https://circleid.com/posts/20230316-analysis-of-7.5-trillion-dns-queries-reveals-public-resolvers-dominate-the-internet">Analysis of 7.5 Trillion DNS Queries Reveals Public Resolvers Dominate the Internet</a></li>
  <li>“1.1.1.1 is now handling more than 1.3T requests per day”: <a href="https://news.ycombinator.com/item?id=36984419">https://news.ycombinator.com/item?id=36984419</a></li>
  <li>Hypertext Transfer Protocol – HTTP/1.1: <a href="https://www.rfc-editor.org/rfc/rfc2616">https://www.rfc-editor.org/rfc/rfc2616</a></li>
  <li>The Transport Layer Security (TLS) Protocol Version 1.2 <a href="https://www.ietf.org/rfc/rfc5246.txt">https://www.ietf.org/rfc/rfc5246.txt</a></li>
  <li>Keep Alive: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[“When you type a URL in your browser, what will happen?” If you are a web developer, you might have answered this sort of interview question once or twice. It would be a popular question to test the knowledge how the Internet works. As it is famous, you will find many answers here and there online.]]></summary></entry><entry><title type="html">What is bcrypt gem?</title><link href="http://localhost:4000/2024/07/05/what-is-bcrypt-gem.html" rel="alternate" type="text/html" title="What is bcrypt gem?" /><published>2024-07-05T23:33:00+09:00</published><updated>2024-07-05T23:33:00+09:00</updated><id>http://localhost:4000/2024/07/05/what-is-bcrypt-gem</id><content type="html" xml:base="http://localhost:4000/2024/07/05/what-is-bcrypt-gem.html"><![CDATA[<p>When a Ruby on Rails application is created by <code>rails new</code> command, we typically see bcrypt gem in <code>Gemfile</code>.</p>

<pre><code class="language-ruby"># Use Active Model has_secure_password [https://guides.rubyonrails.org/active_model_basics.html#securepassword]
# gem "bcrypt", "~&gt; [VERSION]"
</code></pre>

<p>The Rails generator adds commonly used gems to Gemfile so that developers can add those by just removing <code>#</code>
at the beginning of a line. That’s pretty handy.</p>

<p>Okay, then, what is bcrypt gem actually doing?
The instruction at <a href="https://guides.rubyonrails.org/active_model_basics.html#securepassword">https://guides.rubyonrails.org/active_model_basics.html#securepassword</a>
says:</p>

<blockquote>
  <p>ActiveModel::SecurePassword depends on bcrypt, so include this gem in your Gemfile….”</p>
</blockquote>

<p>We can understand how to setup and use the gem to make passwords secure,
but still it’s not clear why the passwords become secure by bcrypt gem.</p>

<p>It’s time google it!</p>

<h3 id="hashing-not-encryption">Hashing, not Encryption</h3>

<p>If we see google search results about bcrypt, we notice many websites mention about hashing vs encryption.
The difference is a one-way or two-way algorithm or function.
The one-way function is able to generate a string of random characters based on the given string, but there’s no way to
make the original string back. In another words, it is impossible to decrypt.
The generated string is called a hash or digital fingerprint.</p>

<p>On the other hand, the two-way algorithm or function can do both: encrypt and decrypt.
If the two-way function is used to generate a string of random characters based on the the given string,
the given string can be recovered from the generated string. This process is called an encryption and decryption.</p>

<p>Bcrypt is the one-way function, so we will never ever know what is the password actually.
The question now would be how to test a given password from a user A is correct.
To test the password, exactly the same hashing process runs to generate a hashed string,
then, compare the saved and generated hashed strings. If those matches, the given password is correct.</p>

<p>Since nobody can recover passwords from hashed string, the one-way function is commonly used to secure password storage.</p>

<p>What about the two-way function? The two-way function or encryption/decryption is used to secure communication
including emails, store sensitive data such as PII (personal identifiable information), and etc.</p>

<p>In the area of two-way function, many online articles mention symmetric and asymmetric key encryption.
The symmetric encryption uses the same key to both encryption and decryption.
While asymmetric encryption uses a key pair, which is known as a public/private key pair.
The private key is used to encrypt. The public key is used to decrypt.
Well-known algorithms are:</p>
<ul>
  <li>Symmetric: Advanced Encryption Standard (AES), Data Encryption Standard (DES)</li>
  <li>Asymmetric: Rivest-Shamir-Adleman (RSA), Digital Signature Algorithm (DSA)</li>
</ul>

<p>If you are a software developer, you should have used one when you generated a ssh key pair.
Then, you should have pasted a public key to the source code repository such as GitHub or GitLab.</p>

<h3 id="bcrypt-algorithm--slow-is-good">Bcrypt algorithm – slow is good</h3>

<p>Of course, bcrypt is not the only widely used hashing algorithm. 
Famous algorithms are <a href="https://en.wikipedia.org/wiki/Argon2">Argon2id</a>,
<a href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a>, and
<a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>.</p>

<p>Among those, bcrypt is said to be good since its computation is slow.
SLOW?? WHAT?
Yes, in the computing world, the faster, the better. To make it run faster, people use their brains and pay a lot of efforts.
Even though, bcrypt is good because it runs slow.</p>

<p>One of the purposes of the slow computation is to stop attackers in an early stage.
When a monitoring is in place, an administrator can spot a suspicious activity.
Thanks for the slow bcrypt, the attackers’ progresses slow down, which effectively prevents further data breach.</p>

<p>Bcrypt has a cost parameter to control its slowness.
The Ruby world has another gem called <a href="https://github.com/binarylogic/authlogic">authlogic</a>, which covers bcrypt,
scrypt and a couple more hashing algorithm. Authlogic’s API document has interesting benchmarks at:
<a href="https://www.rubydoc.info/github/binarylogic/authlogic/Authlogic/CryptoProviders/BCrypt">https://www.rubydoc.info/github/binarylogic/authlogic/Authlogic/CryptoProviders/BCrypt</a></p>
<pre><code class="language-ruby">require "bcrypt"
require "digest"
require "benchmark"

Benchmark.bm(18) do |x|
  x.report("BCrypt (cost = 10:") {
    100.times { BCrypt::Password.create("mypass", :cost =&gt; 10) }
  }
  x.report("BCrypt (cost = 4:") {
    100.times { BCrypt::Password.create("mypass", :cost =&gt; 4) }
  }
  x.report("Sha512:") {
    100.times { Digest::SHA512.hexdigest("mypass") }
  }
  x.report("Sha1:") {
    100.times { Digest::SHA1.hexdigest("mypass") }
  }
end

#                          user     system      total        real
# BCrypt (cost = 10):  37.360000   0.020000  37.380000 ( 37.558943)
# BCrypt (cost = 4):    0.680000   0.000000   0.680000 (  0.677460)
# Sha512:               0.000000   0.000000   0.000000 (  0.000672)
# Sha1:                 0.000000   0.000000   0.000000 (  0.000454)
</code></pre>

<p>As the result shows, the cost 10 bcrypt runs very slow.</p>

<p>Bcrypt gem’s default cost is 12 as explained at
<a href="https://github.com/bcrypt-ruby/bcrypt-ruby">https://github.com/bcrypt-ruby/bcrypt-ruby</a>.
So, by default, bcrypt-ruby runs much slower.</p>

<h3 id="its-salted">It’s salted</h3>

<p>Another goodness of bcrypt is, it is salted.
The salt is a some length of random characters used by hashing functions.
As for bcrypt, the salt is randomly generated 16 byte value, which will be 22 characters after base 64 encoded.
Using salt, bcrypt generate a hash (or checksum) from <code>salt + password</code>.
This makes hashed strings really unique and almost impossible to find passwords.</p>

<p>When the hashing is done, the generated string will have a format blow:</p>

<pre><code>$2&lt;a/b/x/y&gt;$[cost]$[22 character salt][31 character hash]

$2a$12$K0ByB.6YI2/OYrB4fQOYLe6Tv0datUVf6VZ/2Jzwm879BW5K1cHey
\__/\/ \____________________/\_____________________________/
Alg Cost      Salt                  Hash (Checksum)
</code></pre>

<p>Since every password has a different salt, bcrypt makes guessing the passwords really hard.</p>

<h3 id="devise-and-bcrypt-gem">Devise and bcrypt gem</h3>

<p>Bcrypt-ruby gem or simply bcrypt gem is a widely used hashing function in the Rails ecosystem.
For example, famous devise gem uses bcrypt as a default hashing algorithm.</p>

<p>Let’s try what are going on by getting hands dirty.</p>

<h4 id="create-a-sample-rails-app">Create a sample Rails app</h4>

<p>As always, the first command is <code>rails new</code>. This can be very simple app, so –minimal option is added.
Also, <code>-d postgresql</code> option is added to see what are actually in the database.
Once the app is created, setup the database, install devise gem, and finally create a devise User model.</p>

<pre><code class="language-bash">$ bundle exec rails new devise-sample --minimal -d postgresql
$ rake db:setup
$ bundle add devise
$ bundle exec rails g devise:install
$ bundle exec rails g devise User
$ bundle exec rails db:migrate
</code></pre>

<p>At this point, sign up, sign in, sign out and some more password related paths are already created.</p>

<pre><code class="language-bash">$ bundle exec rails routes
                  Prefix Verb   URI Pattern                    Controller#Action
        new_user_session GET    /users/sign_in(.:format)       devise/sessions#new
            user_session POST   /users/sign_in(.:format)       devise/sessions#create
    destroy_user_session DELETE /users/sign_out(.:format)      devise/sessions#destroy
       new_user_password GET    /users/password/new(.:format)  devise/passwords#new
      edit_user_password GET    /users/password/edit(.:format) devise/passwords#edit
           user_password PATCH  /users/password(.:format)      devise/passwords#update
                         PUT    /users/password(.:format)      devise/passwords#update
                         POST   /users/password(.:format)      devise/passwords#create
cancel_user_registration GET    /users/cancel(.:format)        devise/registrations#cancel
   new_user_registration GET    /users/sign_up(.:format)       devise/registrations#new
  edit_user_registration GET    /users/edit(.:format)          devise/registrations#edit
       user_registration PATCH  /users(.:format)               devise/registrations#update
                         PUT    /users(.:format)               devise/registrations#update
                         DELETE /users(.:format)               devise/registrations#destroy
                         POST   /users(.:format)               devise/registrations#create
      rails_health_check GET    /up(.:format)                  rails/health#show
</code></pre>

<p>For a convenience, let’s create a simple page which has buttons of sign up/in/out.</p>

<pre><code class="language-bash">$ bundle exec rails g controller home index
</code></pre>

<p>Add below to <code>app/views/home/index.html.erb</code>.</p>

<pre><code class="language-ruby">&lt;% if notice %&gt;
  &lt;p class="alert alert-success"&gt;&lt;%= notice %&gt;&lt;/p&gt;
&lt;% end %&gt;
&lt;% if alert %&gt;
  &lt;p class="alert alert-danger"&gt;&lt;%= alert %&gt;&lt;/p&gt;
&lt;% end %&gt;

&lt;%= button_to(
        "Sign Up",
        new_user_registration_path,
        method: :get
      ) %&gt;
&lt;br/&gt;
&lt;%= button_to(
        "Sign In",
        new_user_session_path,
        method: :get
      ) %&gt;
&lt;br/&gt;
&lt;%= button_to(
        "Log Out",
        destroy_user_session_path,
        method: :delete
      ) %&gt;
</code></pre>

<p>Update <code>config/routes.rb</code> as in blow:</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root 'home#index'
  #...
  # ...
end
</code></pre>

<p>All are ready. It’s time to start a Rails server and create users.</p>

<pre><code class="language-bash">$ bundle exec rails s
</code></pre>

<p>If the server starts, go to http://localhost:3000 on a browser.</p>

<p><img width="500px" src="/assets/img/devise-sample-buttons.jpeg" alt="img: devise sample buttons" /></p>

<p>Sign up the first user with:</p>
<ul>
  <li>email: foo@example.com</li>
  <li>password: Foo’sPassw0rd!</li>
</ul>

<p><img width="500px" src="/assets/img/devise-sample-foo-signup.jpeg" alt="img: devise sample sign up foo" /></p>

<p>Click the “Log Out” button and sign up the second user with exactly the same password as the first user:</p>

<ul>
  <li>email: bar@example.com</li>
  <li>password: Foo’sPassw0rd!</li>
</ul>

<p><img width="500px" src="/assets/img/devise-sample-bar-signup.jpeg" alt="img: devise sample sign up bar" /></p>

<h4 id="what-have-been-created">What have been created</h4>

<p>Now we had two devise users successfully signed up. Two users can be verified on a Rails console, but let’s see
what are in PostgreSQL first.</p>

<pre><code class="language-bash"># In this case, PostgreSQL was installed by brew on MacOS.
# On other OS, installation, or setup, psql command may start with different arguments. 
$ psql postgres
postgres=# \c devise_sample_development
devise_sample_development=# select * from users;

 id |      email      |                      encrypted_password                      | reset_password_token |...
----+-----------------+--------------------------------------------------------------+----------------------+...
  2 | foo@example.com | $2a$12$biaK7edYPkOMEKUFjt9rCucUrine6wP.La20blTv7.bvpxtPv/dYi |                      |...
  3 | bar@example.com | $2a$12$.e3uUveScoJJmjBg9FNozeU9G.knZVODPmmk6xCVU0Amwmk4Pg316 |                      |...
(2 rows)
</code></pre>

<p>The encrypted_password column has hashed values generated by bcrypt.
Although two users used the exactly the same password, salt strings (22 characters after “12$”) are different.
As a result, hash values (last 31 characters) are different.</p>

<p>Open up the Rails console and test some bcrypt APIs.</p>

<pre><code class="language-bash">$ bundle exec rails c
</code></pre>

<pre><code class="language-ruby"># get bcrypt generated hash values
irb(main):001&gt; hashes = User.all.map {|u| u.encrypted_password }
  User Load (0.9ms)  SELECT "users".* FROM "users"
=&gt;
["$2a$12$biaK7edYPkOMEKUFjt9rCucUrine6wP.La20blTv7.bvpxtPv/dYi",
...
irb(main):002&gt; hashes
=&gt;
["$2a$12$biaK7edYPkOMEKUFjt9rCucUrine6wP.La20blTv7.bvpxtPv/dYi",
 "$2a$12$.e3uUveScoJJmjBg9FNozeU9G.knZVODPmmk6xCVU0Amwmk4Pg316"]

# try some bcrypt APIs
irb(main):004&gt; require 'bcrypt'
=&gt; true
irb(main):005&gt; foo = BCrypt::Password.new(hashes[0])
=&gt; "$2a$12$biaK7edYPkOMEKUFjt9rCucUrine6wP.La20blTv7.bvpxtPv/dYi"

# yes! the password test passes 
irb(main):006&gt; foo == "Foo'sPassw0rd!"
=&gt; true

# the second user's password test passes as well
irb(main):010&gt; BCrypt::Password.new(hashes[1]) == "Foo'sPassw0rd!"
=&gt; true

# get parameters from a generated hash value
# bcrypt version
irb(main):011&gt; foo.version
=&gt; "2a"
# cost 
irb(main):012&gt; foo.cost
=&gt; 12
# salt -- bcrypt gem's salt method returns "version + cost + salt"
irb(main):013&gt; foo.salt
=&gt; "$2a$12$biaK7edYPkOMEKUFjt9rCu"
# checksum or hash of 31 characters
irb(main):014&gt; foo.checksum
=&gt; "cUrine6wP.La20blTv7.bvpxtPv/dYi"
irb(main):015&gt; foo.checksum.length
=&gt; 31
</code></pre>

<p>As in above, we can manually test the password’s validity.</p>

<h3 id="what-can-be-prevented-by-password-hashing">What can be prevented by password hashing?</h3>

<p>At this point, we know what is bcrypt (bcrypt gem) and how to use it.
Bcrypt is there to secure a password storage.
The question is from what the password storage will be secured.</p>

<p>In this world, two major password storage attacks are there: brute force and rainbow table attack.
The brute force attack takes trial and error approach guessing every possible password string.
Nothing can prevent the brute force attack 100%.
However, because of the bcrypt’s slow computing process, the attack can be detected in the early stage.
That way, a damage can be possibly minimized.</p>

<p>Considering the slow computing process, evil hackers invented rainbow table attack.
The table has already generated hashing values using really many combinations of salt and possible password string.
The rainbow attack can bypass the slow bcrypt computation time.
Bcrypt is strong enough to be cracked, but there’s no guarantee to make it 100% secure.
A good news is, the rainbow table attack happens when the password storage is compromised.</p>

<p>As a Rails developer, what we can do would be to put an additional layer of password security.
Two factor authentication or CAPTCHA might be good options.</p>

<p>Other than that, Rails devs might just pray for administrators or DevOps people’s relentless work
to save the password storage.</p>

<h3 id="references">References</h3>

<ul>
  <li>Argon2: <a href="https://en.wikipedia.org/wiki/Argon2">https://en.wikipedia.org/wiki/Argon2</a></li>
  <li>scrypt: <a href="https://en.wikipedia.org/wiki/Scrypt">https://en.wikipedia.org/wiki/Scrypt</a></li>
  <li>bcrypt: <a href="https://en.wikipedia.org/wiki/Bcrypt">https://en.wikipedia.org/wiki/Bcrypt</a></li>
  <li>PBKDF2: <a href="https://en.wikipedia.org/wiki/PBKDF2">https://en.wikipedia.org/wiki/PBKDF2</a></li>
  <li>authlogic: <a href="https://github.com/binarylogic/authlogic">https://github.com/binarylogic/authlogic</a></li>
  <li>bcrypt-ruby: <a href="https://github.com/bcrypt-ruby/bcrypt-ruby">https://github.com/bcrypt-ruby/bcrypt-ruby</a></li>
  <li>OWASP Password Storage Cheat Sheet: <a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html</a></li>
  <li>What is bcrypt and how does it work?: <a href="https://nordvpn.com/blog/what-is-bcrypt/">https://nordvpn.com/blog/what-is-bcrypt/</a></li>
  <li>What is brute force attack?: <a href="https://nordvpn.com/blog/brute-force-attack/">https://nordvpn.com/blog/brute-force-attack/</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[When a Ruby on Rails application is created by rails new command, we typically see bcrypt gem in Gemfile.]]></summary></entry><entry><title type="html">Vite + Vue + Bun on Rails</title><link href="http://localhost:4000/2024/03/05/vite-vue-bun-on-rails.html" rel="alternate" type="text/html" title="Vite + Vue + Bun on Rails" /><published>2024-03-05T21:18:00+09:00</published><updated>2024-03-05T21:18:00+09:00</updated><id>http://localhost:4000/2024/03/05/vite-vue-bun-on-rails</id><content type="html" xml:base="http://localhost:4000/2024/03/05/vite-vue-bun-on-rails.html"><![CDATA[<p><a href="https://vuejs.org/">Vue.js</a> is one of frontend frameworks gaining popularity among rapidly emerging JavaScript technologies.
The combination of Vue.js and Rails is becoming more popular as well,
however, Vue.js development on Rails is not so straightforward.
The reason would be that Vue.js relies on <a href="https://vitejs.dev/">Vite</a> for a development environment
such as HMR (Hot Module Replacement) and bundling.</p>

<p>Since Rails 7, some JavaScript approaches have been supported.
As of version 7.1.3.2, importmap (default), bun, webpack, esbuild and rollup are the choices.
Vite is a replacement of such JavaScript approaches, but is not listed yet.</p>

<p>Here comes the <a href="https://rubygems.org/gems/vite_rails">vite_rails gem</a>.
The gem sets up the environment for Vite on Rails.
Vite itself is independent from frontend frameworks.
By adding a plugin, Vite + Vue development environment will be created.</p>

<p>One more addition in this blog post is <a href="https://bun.sh/">Bun</a>.
Bun runs really fast.
Here, Bun is used just a replacement of npm or yarn.
However, Bun is a all-in-one toolkit and covers some features of Vite such as bundling.
For the topic of Bun vs. Vite, the blog post,
<a href="https://dev.to/this-is-learning/why-use-vite-when-bun-is-also-a-bundler-vite-vs-bun-2723">Why use Vite when Bun is also a bundler? - Vite vs. Bun</a>,
explains well.
At this moment, Vite on Bun is an effective combination.</p>

<p>This blog post explains how Vue, Vite and Bun on Rails can be created.
The source code is on the GitHub, <a href="https://github.com/yokolet/rails-vite-vue">rails-vite-vue</a>.</p>

<h3 id="prerequisite">Prerequisite</h3>

<p>This blog is not about a big application,
even though we need tools to be installed before getting started.
Below is a list of what should be installed.</p>

<ol>
  <li>Ruby: <a href="https://www.ruby-lang.org/en/documentation/installation/">Installing Ruby</a></li>
  <li>Rails: <a href="https://guides.rubyonrails.org/v5.0/getting_started.html#installing-rails">Installing Rails</a></li>
  <li>Node.js: <a href="https://nodejs.org/en/download/package-manager/">Installing Node.js via package manager</a><br />
or Download from <a href="https://nodejs.org/en">https://nodejs.org/en</a></li>
  <li>Bun: <a href="https://bun.sh/docs/installation">https://bun.sh/docs/installation</a></li>
</ol>

<h3 id="versions">Versions</h3>

<ul>
  <li>Ruby 3.2.3</li>
  <li>Rails 7.1.3.2</li>
  <li>Node.js v21.5.0</li>
  <li>Bun 1.0.29</li>
</ul>

<h3 id="create-a-rails-app-skipping-javascript">Create a Rails App Skipping JavaScript</h3>

<p>Rails supports importmap (default), bun, webpack, esbuild and rollup as JavaScript approaches.
None of those will be used to transpile, bundle, or etc. to create a frontend by Vue.
Bun will be used, but its role is a replacement of npm or yarn here.
The best option is <code>--skip-javascript</code>.
Also, <code>--minimal</code> option works if the app can be a simple one.</p>

<p>The command blow creates a Rails app without a JavaScript support.</p>

<pre><code class="language-bash">$ rails new [APP NAME] --skip-javascript -T
</code></pre>

<h3 id="install-vite">Install Vite</h3>

<p>The next step is to install Vite.
Change a directory to the application, then type the command below.</p>

<pre><code class="language-bash">$ bundle add vite_rails
</code></pre>

<p>The command above installs vite_rails gem along with a Ruby version of vite command.
The Ruby version of vite command is used to install Vite and JavaScript version of vite command.</p>

<p>Now, it’s time to use the Ruby version of vite command. Type below.</p>

<pre><code class="language-bash">$ bundle exec vite install
</code></pre>

<p>Above command does a lot.
It installs the vite JavaScript package which includes JavaScript version of vite command.
Also, it installs the vite-plugin-ruby JavaScript package.
During the package installation, npm runs. It looks no option to switch to yarn or bun.</p>

<p>Additionally, it creates files listed below.</p>

<ul>
  <li>Procfile.dev</li>
  <li>app/frontend/entrypoints/application.js</li>
  <li>bin/vite</li>
  <li>config/initializers/content_security_policy.rb</li>
  <li>config/vite.json</li>
  <li>vite.config.ts</li>
</ul>

<h3 id="switching-from-npm-to-bun">Switching from npm to bun</h3>

<p>Bun runs really fast, so this blog uses bun instead of npm.
Since package-lock.json is no longer needed, delete the npm lock file.</p>

<pre><code class="language-bash">$ rm package-lock.json
$ bun install
</code></pre>

<p>Once bun install is completed,  Bun’s lock file, <code>bun.lockb</code>, will be created.
After this, use bun command to install JavaScript packages.</p>

<h3 id="install-vue-and-vue-plugin">Install Vue and Vue Plugin</h3>

<p>We need Vue JavaScript package to develop Vue app.
We also need the Vue plugin for Vite.
Vite is a framework independent development tool.
To use Vite for Vue development, Vue plugin should be installed and set up.</p>

<pre><code class="language-bash">$ bun add vue @vitejs/plugin-vue
</code></pre>

<p>After the vue and plugin installation, edit <code>vite.config.ts</code> to set up Vue plugin.</p>

<pre><code class="language-typescript">import { defineConfig } from 'vite'
import RubyPlugin from 'vite-plugin-ruby'
import vue from '@vitejs/plugin-vue' // added

export default defineConfig({
  plugins: [
    RubyPlugin(),
    vue(),  // added
  ],
})
</code></pre>

<h3 id="set-up-starter-command">Set up Starter Command</h3>

<p>When the app was created, we skipped the JavaScript approaches.
Because of that, the app doesn’t have a handy command such as <code>bin/dev</code>.
The vite_rails gem created <code>Profile,dev</code> configuration for a foreman.
This works, but, still, we need to type <code>foreman start -f Procfile.dev</code> to start the development server.
It’s better to have the command, <code>bin/dev</code>.</p>

<h5 id="packagejson">package.json</h5>

<p>Add the scripts section in package.json.</p>

<pre><code class="language-json">{
  "scripts": {
    "dev": "bunx --bun vite",
    "build": "bunx --bun vite build"
  },
  "devDependencies": {
    "vite": "^5.1.4",
    "vite-plugin-ruby": "^5.0.0"
  },
  "dependencies": {
    "@vitejs/plugin-vue": "^5.0.4",
    "vue": "^3.4.21"
  }
}
</code></pre>

<p>The <a href="https://bun.sh/docs/cli/bunx">bunx command</a> should be installed when Bun was installed.
The bunx is a counterpart of npx.</p>

<h5 id="procfiledev">Procfile.dev</h5>

<p>Update the file as in below.</p>

<pre><code class="language-bash">web: env RUBY_DEBUG_OPEN=true bin/rails server
js: bun run dev
</code></pre>

<p>This setting is to start two servers – one for Rails and another for a frontend.</p>

<h5 id="bindev">bin/dev</h5>

<p>Create a new file <code>bin/dev</code> with the contents below.</p>

<pre><code class="language-bash">#!/usr/bin/env sh

if gem list --no-installed --exact --silent foreman; then
  echo "Installing foreman..."
  gem install foreman
fi

# Default to port 3000 if not specified
export PORT="${PORT:-3000}"

exec foreman start -f Procfile.dev "$@"
</code></pre>

<p>Then, change the file permission to executable.
For example, <code>chmod 755 bin/dev</code>.</p>

<p>For now, we can start the two development servers by just typing <code>bin/dev</code>.</p>

<h3 id="create-a-vue-app-mount-point">Create a Vue App Mount Point</h3>

<p>Since it is a Rails app, a controller is responsible to receive HTTP requests.</p>

<pre><code class="language-bash">$ rails g controller pages index
</code></pre>

<p>Edit <code>app/views/pages/index.html.erb</code> to add the mount point.</p>

<pre><code class="language-erbruby">&lt;%= content_tag(:div, "", id:"app") %&gt;
</code></pre>

<p>Edit <code>config/routes.rb</code> so that the Vue app can be seen at a root path.</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root 'pages#index'  # updated for a Vue app
  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html

  # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.
  # Can be used by load balancers and uptime monitors to verify that the app is live.
  get "up" =&gt; "rails/health#show", as: :rails_health_check

  # Defines the root path route ("/")
  # root "posts#index"
end
</code></pre>

<h3 id="create-a-vue-app">Create a Vue App</h3>

<p>To make an app creation simple, the Vue app used here is the one create by <code>bun create vite</code> command.
During the app creation, Vue and JavaScript was selected as a framework and language.</p>

<p>When vite_rails gem is used, an entrypoint file is <code>app/frontend/entrypoints/application.js</code>.
The file is equivalent to <code>main.js</code> of the Vue sample app.
Replace whole content of application.js (Rails) by main.js (Vite + Vue)
or add entire main.js (Vite + Vue) to application.js (Rails).</p>

<p>Six files of Vite + Vue app below:</p>

<pre><code class="language-bash">$ tree src public
src
├── App.vue
├── assets
│   └── vue.svg
├── components
│   └── HelloWorld.vue
├── main.js
└── style.css
public
└── vite.svg

4 directories, 6 files
</code></pre>

<p>should be mapped to below on Rails:</p>

<pre><code class="language-bash">$ tree app/frontend
app/frontend
├── App.vue
├── assets
│   └── vue.svg
├── components
│   └── HelloWorld.vue
├── entrypoints
│   ├── application.js
│   └── style.css
└── vite.svg

4 directories, 6 files
</code></pre>

<p>How to organize directories/files under app/frontend looks not standardized yet.
The vite_rails gem watches all files under app/frontend and reload if necessary.
Above directory structure is just an example.</p>

<h3 id="start-the-app-and-verify-hmr">Start the App and Verify HMR</h3>

<p>Start the servers by:</p>

<pre><code class="language-bash">$ bin/dev
</code></pre>

<p>Open http://localhost:3000/ on a browser.
The webpage below should show up.</p>

<p><img width="500px" src="/assets/img/vite_vue_rails.jpeg" alt="img: vite + vue on rails" /></p>

<p>Try editing <code>app/frontend/App.vue</code> and <code>app/frontend/components/HelloWorld.vue</code> and
verify HMR (Hot Module Replacement) is working.</p>

<h3 id="references">References</h3>
<ul>
  <li>Vite Ruby: <a href="https://vite-ruby.netlify.app/">https://vite-ruby.netlify.app/</a></li>
  <li>Vue.js Guide: <a href="https://vuejs.org/guide/introduction.html">https://vuejs.org/guide/introduction.html</a></li>
  <li>Build a frontend using Vite and Bun: <a href="https://bun.sh/guides/ecosystem/vite">https://bun.sh/guides/ecosystem/vite</a></li>
  <li><a href="https://dev.to/this-is-learning/why-use-vite-when-bun-is-also-a-bundler-vite-vs-bun-2723">Why use Vite when Bun is also a bundler? - Vite vs. Bun</a></li>
  <li><a href="https://bootrails.com/blog/ruby-on-rails-and-vuejs-tutorial/">Ruby-on-Rails and VueJS tutorial</a></li>
  <li><a href="https://dev.to/chmich/setup-vite-on-rails-7-f1i">Create Rails-7 app with Vite</a></li>
  <li><a href="https://dev.to/jetthoughts/integrating-bun-with-vite-ruby-for-lightning-fast-frontend-builds-1fh2">Integrating Bun with Vite Ruby for Lightning-Fast Frontend Builds</a></li>
  <li><a href="https://clouddevs.com/ruby-on-rails/building-app-with-vuejs-frontend/">Building a Rails App with a Vue.js Frontend</a></li>
  <li><a href="https://medium.com/@oscarreciogonzalez/vue-on-rails-15686b85b1d3">Vue on Rails</a></li>
  <li><a href="https://guillaume.barillot.me/2022/05/05/rails-vite-vue-3-pina-starter-pack/">Rails 7 + Vite + Vue 3 + Pinia starter pack</a></li>
  <li>Source code: <a href="https://github.com/yokolet/rails-vite-vue">https://github.com/yokolet/rails-vite-vue</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[Vue.js is one of frontend frameworks gaining popularity among rapidly emerging JavaScript technologies. The combination of Vue.js and Rails is becoming more popular as well, however, Vue.js development on Rails is not so straightforward. The reason would be that Vue.js relies on Vite for a development environment such as HMR (Hot Module Replacement) and bundling.]]></summary></entry><entry><title type="html">Bun + React on Rails</title><link href="http://localhost:4000/2024/03/01/bun-react-on-rails.html" rel="alternate" type="text/html" title="Bun + React on Rails" /><published>2024-03-01T15:31:00+09:00</published><updated>2024-03-01T15:31:00+09:00</updated><id>http://localhost:4000/2024/03/01/bun-react-on-rails</id><content type="html" xml:base="http://localhost:4000/2024/03/01/bun-react-on-rails.html"><![CDATA[<p>In the frontend world, new technologies keep emerging rapidly these years.
Still, React is a well-established and very popular frontend framework,
Vue.js, Svelte, Astro and more frameworks are gaining popularity.
Not just the frameworks, tools for a transpiler/bundler or sort are also under a rapid development.
In JavaScript domain, esbuild, rollup, vite and some more are out.</p>

<p>Relatively new addition is Bun (<a href="https://bun.sh/">https://bun.sh/</a>).</p>

<p>Bun has multiple features.
It can be used as a package manager, development server, bundler and test runner.
On the website, it says an all-in-one toolkit for JavaScript.
The best advantage of using Bun would be its speed.
Indeed, Bun runs very fast.</p>

<p>Rails supports Bun since version 7.1 as one of JavaScript approaches.
This blog post is about the attempt to create a React app using Bun.</p>

<h4 id="prerequisite">Prerequisite</h4>

<p>Prior to the Rails application creation, <code>bun</code> command should be installed.
The installation instruction is on the Bun website, <a href="https://bun.sh/docs/installation">https://bun.sh/docs/installation</a>.
The website shows 5 ways to install bun if you have macOS and Linux.
Among those, by curl command, Homebrew and npm would be popular.
Choose whatever you like.</p>

<ul>
  <li>curl
    <pre><code class="language-bash">$ curl -fsSL https://bun.sh/install | bash # for macOS, Linux, and WSL
</code></pre>
  </li>
  <li>Homebrew
    <pre><code class="language-bash">$ brew install oven-sh/bun/bun # for macOS and Linux
</code></pre>
  </li>
  <li>npm
    <pre><code class="language-bash">$ npm install -g bun # the last `npm` command you'll ever need
</code></pre>
  </li>
</ul>

<p>The Bun website also has an instruction for Windows.</p>

<h4 id="versions">Versions</h4>
<ul>
  <li>Ruby 3.2.3</li>
  <li>Rails 7.1.3.2</li>
</ul>

<h3 id="create-a-rails-app-with-bun-option">Create a Rails App with bun Option</h3>

<p>The command to create an app which uses bun is something like this:</p>

<pre><code class="language-bash">% rails new [APP NAME] -j bun -T
</code></pre>

<p>Above command installs all including <code>bun install</code>.
After the installation finishes, change the directory to application and just type <code>bin/dev</code>.
The Rails should start up.
Verify that by visiting http://localhost:3000/ on a browser.</p>

<p>In early releases of Rail 7.1, some odds were reported to start the Rails.
However, on version 7.1.3.2, all those issues look fixed.
None of extra steps are required to start Rails now.</p>

<h3 id="files-related-to-bun">Files Related to Bun</h3>

<p>Let’s look at files in the Rails application top directory.</p>
<h4 id="bunlockb">bun.lockb</h4>
<p>This file is a lock file equivalent to package-lock.json or yarn.lock.
Unlike a legacy lock file, bun.lockb is a binary file.</p>

<h4 id="bunconfigjs">bun.config.js</h4>
<p>This is a Bun configuration file which defines how Bun builds the application.
When the Rails generator created the file, a build configuration is defined like this:</p>
<pre><code class="language-javascript">const config = {
  sourcemap: "external",
  entrypoints: ["app/javascript/application.js"],
  outdir: path.join(process.cwd(), "app/assets/builds"),
};
</code></pre>

<p>The details of the configuration parameters are explained at <a href="https://bun.sh/docs/bundler#api">https://bun.sh/docs/bundler#api</a>.</p>

<p>For example, to minify output JavaScript files, the configuration will be:</p>
<pre><code class="language-javascript">const config = {
  sourcemap: "external",
  entrypoints: ["app/javascript/application.js"],
  outdir: path.join(process.cwd(), "app/assets/builds"),
  minify: true,
};
</code></pre>
<p>We see more than ten configuration APIs on the web page.
However, not many options work seamlessly with Rails.
Suppose the naming setting is changed to <code>naming: '[dir]/[name]-[hash].[ext]'</code>
(default for the entry is ‘[dir]/[name].[ext]’),
the generated JavaScript file will be something like <code>application-6da4a92fc66938e4.js</code>.
It looks good at a glance.
However, javascript_include_tag in app/views/layouts/application.html.erb should be changed like
<code>&lt;%= javascript_include_tag "application-6da4a92fc66938e4", "data-turbo-track": "reload", type: "module" %&gt;</code>.
When the JavaScript file is updated, the hash value will be updated as well.
As a result, the outdir will have multiple <code>application-[hash].js</code> files.
Also, javascript_include_tag’s filename should be updated accordingly.
Moreover, Rails adds a hash value when the JavaScript file is provided.
It is something like, <code>application-921e7020b343a6ac4bfb2c1d2302254e1f5ea0fda39e8ee8c38aa17e00d8e0e2.js</code>.</p>

<p>Although Bun configuration API has many options, only few are useful on Rails.</p>

<h4 id="procfiledev">Procfile.dev</h4>

<p>The file is a server setting passed to Foreman.
When the Rails application is created with <code>-j bun</code> option, the file looks like below:</p>
<pre><code class="language-bash">web: env RUBY_DEBUG_OPEN=true bin/rails server
js: bun run build --watch
</code></pre>

<p>Bun’s <code>--watch</code> options is explained at Watch mode (<a href="https://bun.sh/docs/runtime/hot">https://bun.sh/docs/runtime/hot</a>).
When the option is specified, Bun watches changes in JavaScript files listed in the entrypoints configuration.
If Bun detects a change, Bun restarts the process.</p>

<p>Another option is <code>--hot</code>. However, <code>--hot</code> option works when Bun is used on the server side.
Besides, as above web page explains, the option is not for a hot loading to the browser.
When the JavaScript code is updated, still we need to click browser’s reload button.
The hot loading to the browser will be a job by <a href="https://vitejs.dev/">Vite</a>.</p>

<h3 id="create-a-react-app">Create a React App</h3>

<p>The first step is to install packages.</p>

<pre><code class="language-bash">$ bun add react react-dom
</code></pre>

<p>You might be surprised. Bun runs really fast.</p>

<p>Next step is to write React code.
For a simplicity, the React app used here is the one create-react-app package creates.
The app shows a rotating React logo and a couple other messages.
JavaScript code can be used as those are except image and stylesheet imports.
Since the server side is Rails, it’s good and easy to put images and stylesheets in the directories meant to be.
For that reason, the sample app takes idiomatic Rails rather than idiomatic React.</p>

<ul>
  <li>app/javascript/application.js</li>
</ul>

<p>The entrypoint file is index.js on a generated React app, while it is application.js on Rails.
Replace the contents of <code>app/javascript/application.js</code> by index.js.</p>

<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;
);
</code></pre>

<ul>
  <li>app/javascript/App.js</li>
</ul>

<p>This is an App component. Other than stylesheet and image imports, the code stays the same as React app.</p>

<pre><code class="language-javascript">function App() {
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;img src="/assets/logo.svg" className="App-logo" alt="logo" /&gt;
        &lt;p&gt;
          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.
        &lt;/p&gt;
        &lt;a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        &gt;
          Learn React
        &lt;/a&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>

<ul>
  <li>index.css, App.css and logo.svg</li>
</ul>

<p>Copy two css files under app/assets/stylesheets. No need to edit those.
Also, copy logo.svg under app/assets/images.</p>

<p>The directory structures become look like below.</p>

<pre><code>app/javascript
├── App.js
├── application.js
└── controllers
    ├── application.js
    ├── hello_controller.js
    └── index.js

2 directories, 5 files
</code></pre>

<pre><code>app/assets
├── builds
│   ├── application.js
│   └── application.js.map
├── config
│   └── manifest.js
├── images
│   └── logo.svg
└── stylesheets
    ├── App.css
    ├── application.css
    └── index.css

5 directories, 7 files
</code></pre>

<h3 id="create-a-mount-point">Create a Mount Point</h3>

<p>Since this is a Rails app, a controller is responsible to receive HTTP requests.
To show the React app on a browser, the controller for that should be created along with a view.</p>

<pre><code class="language-bash">$ rails g controller pages index
</code></pre>

<p>Above command creates a controller and view, also adds a new route in config/routes.rb</p>

<ul>
  <li>app/view/pages/index.html.erb</li>
</ul>

<p>In the app/javascript/application.js, “root” is specified as a mount point.
Add a div tag in the index.html.erb file.</p>

<pre><code class="language-html">&lt;h1&gt;Pages#index&lt;/h1&gt;
&lt;p&gt;Find me in app/views/pages/index.html.erb&lt;/p&gt;
&lt;%= content_tag(:div, "", id:"root") %&gt;
</code></pre>

<h3 id="run-the-app">Run the app</h3>

<p>All are ready. Let’s run the app.</p>

<pre><code class="language-bash">$ bin/dev
</code></pre>

<p>Then go to http://localhost:3000/pages/index on the browser.
The React app shows up.</p>

<p><img width="300px" src="/assets/img/rails-bun-react.jpeg" alt="img: bun + react on rails" /></p>

<h3 id="references">References</h3>
<ul>
  <li><a href="https://bun.sh/docs">https://bun.sh/docs</a></li>
  <li><a href="https://webcrunch.com/posts/bun-with-ruby-on-rails">How to use Bun with Ruby on Rails</a></li>
  <li>Sample code: <a href="https://github.com/yokolet/rails-bun-react">https://github.com/yokolet/rails-bun-react</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[In the frontend world, new technologies keep emerging rapidly these years. Still, React is a well-established and very popular frontend framework, Vue.js, Svelte, Astro and more frameworks are gaining popularity. Not just the frameworks, tools for a transpiler/bundler or sort are also under a rapid development. In JavaScript domain, esbuild, rollup, vite and some more are out.]]></summary></entry><entry><title type="html">Ruby on Rails Secrets Management</title><link href="http://localhost:4000/2023/09/04/ruby-on-rails-secrets-management.html" rel="alternate" type="text/html" title="Ruby on Rails Secrets Management" /><published>2023-09-04T15:13:00+09:00</published><updated>2023-09-04T15:13:00+09:00</updated><id>http://localhost:4000/2023/09/04/ruby-on-rails-secrets-management</id><content type="html" xml:base="http://localhost:4000/2023/09/04/ruby-on-rails-secrets-management.html"><![CDATA[<p>A web application needs various kinds of values, params and etc which should not be revealed to the public, say GitHub repo.
For example, API keys, tokens, passwords, and endpoints, all those should be kept secret.
Another important factor is that such secrets should be shared among the team members.
Additionally, all those secrets should come along with the deployment.</p>

<p>Previously, the dotenv file (.env) is commonly used for this purpose.
When the web application is deployed, the secrets are set up as environment variables.</p>

<h3 id="rails-way-of-secrets-management">Rails Way of Secrets Management</h3>

<p>Since version 5.2, Rails provides a new way of secret management
(<a href="https://rubyonrails.org/2018/4/9/Rails-5-2-0-final">Rails 5.2.0 FINAL: Active Storage, Redis Cache Store, HTTP/2 Early Hints, CSP, Credentials</a>).
It consists of an encrypted credentials file and a key to encrypt/decrypt it.
By default, those are config/credentials.yml.enc and config/master.key,
which are generated by a rails new command.
The credentials.yml.enc is encrypted, so it can be safely pushed to the GitHub repo.
While the master.key should kept secret and never be pushed to the GitHub repo.
The master.key is often shared among team members by a secure measure.</p>

<p>To edit the credentials file, use the <code>rails credentials:edit</code> command with the EDITOR environment variable.
For example:</p>
<pre><code class="language-bash">$ EDITOR=vim rails credentials:edit
$ EDITOR="code --wait" rails credentials:edit
</code></pre>

<p>If the master.key doesn’t exist, Rails shows the message below.</p>
<blockquote>
  <p>When the config/master.key is missing, the command shows the suggestion.</p>

  <p>$ EDITOR=vim rails credentials:edit
Adding config/master.key to store the encryption key: ed36bdc2…….</p>

  <p>Save this in a password manager your team can access.</p>

  <p>If you lose the key, no one, including you, can access anything encrypted with it.</p>

  <pre><code> create  config/master.key
</code></pre>

  <p>Couldn’t decrypt config/credentials.yml.enc. Perhaps you passed the wrong key?</p>
</blockquote>

<p>Even though the new master.key is created following the message,
the existing credentials.yml.enc won’t be decrypted.
It needs the exact key the file is encrypted.
This way, we can safely push the credentials.yml.enc file to the GitHub repo.</p>

<h3 id="how-to-use-credentials">How to Use Credentials</h3>

<p>As the file extension expresses, the credentials file takes YAML format.
It is structured, not like a dotenv file.</p>

<p>When the rails new command creates the credentials file, it looks like this.</p>

<pre><code class="language-yaml"># aws:
#   access_key_id: 123
#   secret_access_key: 345

# Used as the base secret for all MessageVerifiers in Rails, including the one protecting cookies.
secret_key_base: 3cfc7cf4......
</code></pre>

<p>We can add various secrets in YAML format.
For example, some_api_key, client_id and client_secret pairs for OAuth authentication can be
written here.</p>

<pre><code class="language-yaml">secret_key_base: 3cfc7cf4......
some_api_key: HERE_IS_MY_API_KEY
oauth:
  twitter:
    client_id: MY_TWITTER_CLIENT_ID
    client_secret: MY_TWITTER_CLIENT_SECRET
  facebook:
    client_id: MY_FACEBOOK_CLIENT_ID
    client_secret: MY_FACEBOOK_CLIENT_SECRET
</code></pre>

<p>To use above secrets in Rails app,
Rails.application.credentials.[key1].[key2]… is the way to access those.
We can confirm that on the Rails console.</p>

<pre><code class="language-bash">$ rails c
Loading development environment (Rails 7.0.4.2)
irb(main):001:0&gt; Rails.application.credentials.some_api_key
=&gt; "HERE_IS_MY_API_KEY"
irb(main):002:0&gt; Rails.application.credentials.oauth.twitter.client_id
=&gt; "MY_TWITTER_CLIENT_ID"
irb(main):003:0&gt; Rails.application.credentials.oauth.twitter.client_secret
=&gt; "MY_TWITTER_CLIENT_SECRET"
</code></pre>

<h3 id="multi-environment-credentials">Multi-environment credentials</h3>

<p>Since Rails 6, the multi-environment credentials are supported.
When secrets are not the same between development and production environment,
those could’ve been differentiated by a nested YAML notation. For example,</p>

<pre><code class="language-yaml"># before Rails 6
development:
  some_api_key: API_KEY_FOR_DEV
production:
  some_api_key: API_KEY_FOR_PROD
</code></pre>

<p>However, in the Rails app, we should’ve written something like:</p>

<pre><code class="language-ruby"># before Rails 6
if Rails.env == "development"
  api_key = Rails.application.credentials.development.some_api_key
elsif Rails.env == "production"
  api_key = Rails.application.credentials.production.some_api_key
end
</code></pre>

<p>In contract, with the multi-environment credentials,
the credentials file is chosen based on the Rails environment.
If the Rails environment is a production, config/credentials/production.yml.enc is used.
The key to encrypt/decrypt is just for the production env, config/credentials/production.key.
This way, we can eliminate the environment check in our code.</p>

<h4 id="create-the-environment-specific-credentials">Create the environment specific credentials</h4>

<p>To create the Rails environment based credentials, use –environment option.</p>

<pre><code class="language-bash">$ EDITOR=vim rails credentials:edit --environment development
$ EDITOR=vim rails credentials:edit --environment production
</code></pre>

<p>Above commands creates credential and key files under config/credentials directory.</p>

<pre><code class="language-bash">$ tree config/credentials
config/credentials
├── development.key
├── development.yml.enc
├── production.key
└── production.yml.enc

1 directory, 4 files
</code></pre>

<p>The newly generated development/production credential files don’t have a secret_key_base entry.
Under the development environment, missing secret_key_base looks not an immediate problem.
However, under the production environment, it raises an exception.</p>

<pre><code class="language-bash">$ RAILS_ENV=production rails c
/Users/yoko/.gem/ruby/3.2.1/gems/railties-7.0.4.2/lib/rails/application.rb:581:in `validate_secret_key_base': Missing `secret_key_base` for 'production' environment, set this string with `bin/rails credentials:edit` (ArgumentError)
...
...
</code></pre>

<p>We should add secret_key_base in the credentials file.
To generate the value, Rails provides the command:</p>

<pre><code class="language-bash">$ rake secret
a2b30cf4d702a........
</code></pre>

<blockquote>
  <p><strong>Update</strong>:<br />
Rails version 7.0 had the command <code>rake secret</code>. However, since Rails version 7.1,
the command has been changed to:<br />
<code>$ rails secret</code></p>
</blockquote>

<p>Open the production.yml.enc file and copy/paste the generated secret as the value of secret_key_base.</p>

<pre><code class="language-yaml">secret_key_base: a2b30cf4d702a........
some_api_key: API_KEY_FOR_PROD
</code></pre>

<p>Now, we can check the production secrets.</p>

<pre><code class="language-bash">$ RAILS_ENV=production rails c
Loading production environment (Rails 7.0.4.2)
irb(main):001:0&gt; Rails.application.credentials.some_api_key
=&gt; "API_KEY_FOR_PROD"
</code></pre>

<h3 id="deploy-to-heroku">Deploy to Heroku</h3>

<p>Heroku is a popular hosting service for a Rails app.
However, not like AWS EC2 instance, people don’t have a direct access to the instance.
The encrypt/decrypt key should be installed by a heroku command.</p>

<p>One thing we should know is,
Rails “looks for the environment variable ENV[“RAILS_MASTER_KEY”] to encrypt the credentials file”
(<a href="https://edgeguides.rubyonrails.org/security.html#custom-credentials">Securing Rails Applications</a>).
Whether the environment is development or production, Rails sees ENV[“RAILS_MASTER_KEY”].</p>

<p>Heroku’s staging server runs under the production environment.
To deploy the config/production.key, use the Heorku CLI command below:</p>

<pre><code class="language-bash">heroku config:set RAILS_MASTER_KEY=`cat config/credentials/production.key`
</code></pre>

<h3 id="references">References</h3>
<ul>
  <li><a href="https://edgeguides.rubyonrails.org/security.html#custom-credentials">Securing Rails Applications</a></li>
  <li><a href="https://dev.to/raaynaldo/the-power-of-rails-master-key-36fh">The power of Rails master.key</a></li>
  <li><a href="https://blog.kiprosh.com/rails-encrypted-credentials/">Manage Rails app secrets with Rails Encrypted Credentials</a></li>
  <li><a href="https://blog.saeloun.com/2019/10/10/rails-6-adds-support-for-multi-environment-credentials/">Rails 6 adds support for multi environment credentials</a></li>
  <li><a href="https://discuss.rubyonrails.org/t/rails-master-key-and-per-environment-init/82615">RAILS_MASTER_KEY and per-environment init</a></li>
  <li><a href="https://stackoverflow.com/questions/63642303/how-to-set-rails-production-key-config-var-on-a-rails-6-app-on-heroku">How to set RAILS_PRODUCTION_KEY config var on a Rails 6 app on Heroku</a></li>
  <li><a href="https://stackoverflow.com/questions/61279454/rails-6-heroku-devise-error-activesupportmessageencryptorinvalidmessage/66092950#66092950">Rails 6 Heroku Devise error ActiveSupport::MessageEncryptor::InvalidMessage</a></li>
  <li><a href="https://til.hashrocket.com/posts/8b8b4d00a3-generate-a-rails-secret-key">Generate a Rails Secret Key</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[A web application needs various kinds of values, params and etc which should not be revealed to the public, say GitHub repo. For example, API keys, tokens, passwords, and endpoints, all those should be kept secret. Another important factor is that such secrets should be shared among the team members. Additionally, all those secrets should come along with the deployment.]]></summary></entry><entry><title type="html">OAuth2 PKCE With Rails 7, React/Redux and esbuild</title><link href="http://localhost:4000/2023/06/05/oauth2-pkce-with-rails-7-react-redux-and-esbuild.html" rel="alternate" type="text/html" title="OAuth2 PKCE With Rails 7, React/Redux and esbuild" /><published>2023-06-05T22:47:00+09:00</published><updated>2023-06-05T22:47:00+09:00</updated><id>http://localhost:4000/2023/06/05/oauth2-pkce-with-rails-7-react-redux-and-esbuild</id><content type="html" xml:base="http://localhost:4000/2023/06/05/oauth2-pkce-with-rails-7-react-redux-and-esbuild.html"><![CDATA[<p>Logging in to a web site is what users do quite a lot.
Suppose it is a blog site.
Once a user completes a log-in process, the user is allowed to create a new post, update contents and delete a post.
The blog site might have a feature to leave comments by logged in users.</p>

<p>The login process is categorized roughly two types: use the login feature implemented in the web site or
the social login such as Twitter, GitHub, Google, etc.
For a Rails app, implementing a local login feature is not difficult since it can use an established gem called devise.
The Rails app has a choice to use a gem called OmniAuth for the social login
if the front-end is a legacy, server rendered app.</p>

<p>However, we see a lot of rich clients built by ReactJS, Angular, Vue.js or such.
The client app is, sometime, called SPA (Single-Page Application).
Such sort of client app initiates the login process itself.
The social login becomes complicated.
The problem of the social login by SPA is that the app ends up revealing a social login secret parameter.</p>

<p>The Authorization Code Flow, which is a commonly used grant type defined in OAuth2, uses the client id and client secret
provided by the authorization endpoint (Twitter, GitHub, Google, etc).
From a nature of JavaScript code, the client secret is mixed in to a bundled JavaScript code as is.
It might be minified, so very hard to find.
Even though, a reverse engineering would identify the client secret.</p>

<p>To solve such potentially risky issue, the Authorization Code Flow had an extension called Proof Key for Code Exchange.
In short, it is referred as PKCE (pronounced “pixy”).
The PKCE uses a code verifier and code challenge instead of the client secret on the client app side.
The code verifier is a randomly generated string,
while the code challenge is generated by a specified algorithm using the code verifier as a seed.
During multiple interactions with the authorization endpoint,
one of code challenge or code verifier is used in a single interaction.
The client secret is still used on the server app side.
However, the server app can easily protect such secret parameters.</p>

<p>This way, SPA can perform a secure social login.</p>

<h3 id="how-authorization-code-flow-with-proof-key-for-code-exchange-pkce-works">How Authorization Code Flow with Proof Key for Code Exchange (PKCE) Works</h3>

<p>The flow is complicated.
Multiple actors are involved in.
To make it clear, let’s start off from who are those actors.</p>

<h4 id="actors">Actors</h4>

<p>The actors involved in the PKCE are below:</p>

<ul>
  <li>User: human, who wants to be authenticated by a social login.</li>
  <li>SPA: client side app.</li>
  <li>Rails: server side app.</li>
  <li>Auth Endpoint: social login such as Twitter, GitHub, Google, etc.</li>
</ul>

<h4 id="pkce-flow">PKCE Flow</h4>

<p>With above actors, the PKCE flow in this example works like below:</p>

<ol>
  <li>SPA to User: show Login Button which is a link to social login with code challenge and client id</li>
  <li>User to Auth Endpoint: click the button</li>
  <li>Auth Endpoint to User: show the login page if the user is not logged in</li>
  <li>User to Auth Endpoint: input username (or email, phone number, etc) and password, then click a login button</li>
  <li>Auth Endpoint to User: show the Authorize app button with the information about Rails app</li>
  <li>User to Auth Endpoint: click the Authorize app button</li>
  <li>Auth Endpoint to Rails: redirect to Rails app with a code parameter</li>
  <li>Rails to Auth Endpoint: make a request to get an access token with the code parameter, code verifier, client id/secret</li>
  <li>Auth Endpoint to Rails: return the access token</li>
  <li>Rails to Auth Endpoint: make a request to get a user profile with the access token</li>
  <li>Rails to SPA: redirect to SPA’s page with the access token</li>
  <li>SPA to Rails: make a request to know who is the user with the access token</li>
  <li>Rails to SPA: return the user profile</li>
  <li>SPA to User: show the user profile</li>
</ol>

<h3 id="example-application">Example Application</h3>

<p>Versions:</p>
<ul>
  <li>Ruby: 3.2.2</li>
  <li>Rails: 7.0.5</li>
</ul>

<p>Source Code:</p>
<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild">https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild</a></li>
</ul>

<p>Since we learned the basic idea about PKCE, it’s time to implement.
For an example application, the client app is created by ReactJS (TypeScript), Redux Toolkit and Chakra UI.
The server side is created by Ruby on Rails with esbuild setup.</p>

<p>Although ReactJS and Rails have libraries for PKCE, the example app implements the flow from scratch.
It is a good way to understand how PKCE works.</p>

<blockquote>
  <p>For details about creating Rails and ReactJS apps with esbuild setting, please see the previous post:
<a href="/2023/05/23/rails-7-react-redux-development-with-esbuild.html">Rails 7 React/Redux Development with esbuild</a>.</p>
</blockquote>

<h4 id="setup-twitter-social-login">Setup Twitter Social Login</h4>

<p>The example app uses Twitter OAuth2 login.
Go to Twitter’s <a href="https://developer.twitter.com/en/portal/dashboard">Developer Portal</a> and create an app.
The Callback URI / Redirect URL should have “www” in the URL.
This example sets “http://www.localhost:3000/oauth/twitter” for the redirect URL.</p>

<h4 id="server-app">Server App</h4>

<p>The first step is to create Rails app.
Then, add the faraday gem to make HTTP request to the authorization endpoint.
Also, add the jwt gem to sign the access token with some more additional info.</p>

<pre><code class="language-bash">% rails new [APP NAME] -j esbuild -T
% cd [APP NAME]
% bundle add faraday
% bundle add jwt
</code></pre>

<p>Create a user model.</p>

<pre><code class="language-bash">% rails g model User username:string name:string provider:integer pid:string
% rails db:migrate
</code></pre>

<p>The provider here means how the user is authenticated.
It is an enum field, so the data type is integer.
The pid is an id returned from the authorization endpoint.
This example app treats username as a unique field, so it needs additional migration.</p>

<pre><code class="language-bash">% rails g migration add_index_to_users_username
</code></pre>

<p>Edit, db/migrate/[DATE TIME]_add_index_to_users_username.rb</p>
<pre><code class="language-ruby"># db/migrate/[DATE TIME]_add_index_to_users_username.rb

class AddIndexToUsersUsername &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :users, :username, unique: true
  end
end
</code></pre>
<p>Then, run</p>
<pre><code class="language-bash">% rails db:migrate
</code></pre>

<p>Edit, app/models/user.rb to define the provider enum type and add the username constraint of uniqueness.</p>
<pre><code class="language-ruby"># app/models/user.rb

class User &lt; ApplicationRecord
  enum provider: [:local, :twitter]

  validates :username, uniqueness: true
end
</code></pre>

<p>Coming to a controller part, the first one is to create an entry point for the client app.</p>

<pre><code class="language-bash">% rails g stimulus client
</code></pre>

<p>Create another controller to mount the client app.</p>

<pre><code class="language-bash">% rails g controller pages home
</code></pre>

<p>Edit app/views/pages/home.html.erb to add the div tag with id=root as the mount point.</p>
<pre><code class="language-erb">&lt;%# app/views/pages/home.html.erb %&gt;

&lt;h1&gt;Pages#home&lt;/h1&gt;
&lt;p&gt;Find me in app/views/pages/home.html.erb&lt;/p&gt;
&lt;%= content_tag(:div, "", id:"root", data:{ controller: "client" }) %&gt;
</code></pre>

<p>Edit config/routes.rb to make the pages#home to the root route.</p>
<pre><code class="language-ruby"># config/routes.rb

Rails.application.routes.draw do
  root 'pages#home'
end
</code></pre>

<p>Create a controller for the redirect URL.
The URL should be “http://www.localhost:3000/oauth/twitter” as it is set at Twitter Developer Portal.</p>
<pre><code class="language-bash">% rails g controller oauth twitter --skip-template-engine
</code></pre>

<p>The oauth controller will have a core logic explained in the PKCE Flow section.
Among the steps, the oauth controller does step from 7 to 11.
Let’s get back for the PKCE implementation later.</p>

<p>Lastly, create a controller for the me query.
The me query is used to fetch the profile of the currently authenticated user.</p>

<pre><code class="language-bash">% rails g controller me --skip-template-engine
</code></pre>

<p>The controller implementation will be discussed later, so for now, add profile method to create a route.</p>
<pre><code class="language-ruby"># app/controllers/me_controller.rb

class MeController &lt; ApplicationController
  def profile
  end
end
</code></pre>

<p>Edit config/routes.rb to create a path to the me query.</p>
<pre><code class="language-ruby"># config/routes.rb

Rails.application.routes.draw do
  get 'oauth/twitter'
  root 'pages#home'
  get 'me', action: :profile, controller: 'me'
end
</code></pre>

<h4 id="client-app">Client App</h4>

<p>The client app takes a typical Redux Toolkit directory structure described below:</p>

<pre><code class="language-bash">app/javascript
├── App.tsx
├── app
│   ├── hooks.ts
│   └── store.ts
├── application.js
├── controllers
│   ├── application.js
│   ├── client_controller.js
│   └── index.js
├── features
│   ├── auth
│   │   └── authSlice.ts
│   └── twitter
│       ├── TwitterLogin.tsx
│       ├── TwitterProfile.tsx
│       └── twitterSlice.ts
└── utils
    ├── hashUtils.ts
    └── twitterOauthConfig.ts

7 directories, 13 files
</code></pre>

<h5 id="environment-variable-setup">Environment Variable Setup</h5>

<p>This is a setup for environment variables for SPA.
In general, the dotenv is used for such purpose.
However, for SPA, the dotenv is quite hard stuff to setup also not meaningful.
Since the files for the app are bundled in a single JavaScript (and stylesheets),
it depends on the build tool how the dotenv is looked up.
Additionally, the content in dotenv will be hardcoded in the built JavaScript file.</p>

<p>For an alternative way, this example app uses settings.js file which is put in the directory where the Rails asset
pipeline sees.</p>

<p>Create app/assets/javascripts/settings.js and write your twitter app’s client id:</p>

<pre><code class="language-javascript">// app/assets/javascripts/settings.js

var environment = {
  "REACT_APP_TWITTER_CLIENT_ID": "YOUR-CLIENT-ID-HERE",
}
</code></pre>

<p>Add javascripts directory in app/assets/config/manifest.js as in the last line below:</p>
<pre><code class="language-javascript">//= link_tree ../images
//= link_directory ../stylesheets .css
//= link_tree ../builds
//= link_directory ../javascripts .js
</code></pre>

<p>Lastly, add javascript tag in app/views/layouts/application.html.erb.
The tag should come before application.js since the variables defined in settings.js will be referenced in application.js.</p>
<pre><code class="language-erb">&lt;%# app/views/layouts/application.html.erb %&gt;

...
&lt;head&gt;
    &lt;title&gt;TwitterOauthPkceExample&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt;
    &lt;%= csrf_meta_tags %&gt;
    &lt;%= csp_meta_tag %&gt;

    &lt;%= stylesheet_link_tag "application", "data-turbo-track": "reload" %&gt;
    &lt;%= javascript_include_tag "settings", "data-turbo-track": "reload", defer: true %&gt;
    &lt;%= javascript_include_tag "application", "data-turbo-track": "reload", defer: true %&gt;
  &lt;/head&gt;
...
</code></pre>

<h5 id="install-packages">Install Packages</h5>

<p>At Rails app’s root directory, run yarn add command to install packages.</p>

<pre><code class="language-bash">% yarn add react react-dom
% yarn add typescript @types/node @types/react @types/react-dom
% yarn add react-redux @reduxjs/toolkit
% yarn add @chakra-ui/react @emotion/react @emotion/styled framer-motion
</code></pre>

<h5 id="login-button">Login Button</h5>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/TwitterLogin.tsx">TwitterLogin.tsx</a></li>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/utils/twitterOauthConfig.ts">twitterOauthConfig.ts</a></li>
</ul>

<p>The first step of the PKCE is to show the login button which has a link to the authorization endpoint with necessary info.</p>
<pre><code class="language-typescript">// app/javascript/features/twitter/TwitterLogin.tsx

...
return (
  &lt;VStack spacing="4"&gt;
    {!isLoggedIn &amp;&amp;
      &lt;Button
        colorScheme='blue'
        aria-label="Log in using OAuth 2.0"
        onClick={() =&gt; window.open(getTwitterOauthUrl(), '_self')}
      &gt;
        Log in with Twitter
      &lt;/Button&gt;
    }
    {isLoggedIn &amp;&amp;
      &lt;Text&gt;
        Token expiry date: {tokenExpiryDate}
      &lt;/Text&gt;
    }
  &lt;/VStack&gt;
);
...
</code></pre>

<p>The link url is created in the function defined in twitterOauthConfig.ts.
The code challenge is hardcoded in this example app.
In the real world, it should be generated by a specified algorithm.</p>
<pre><code class="language-typescript">// app/javascript/utils/twitterOauthConfig.ts

const authEndpoint = 'https://twitter.com/i/oauth2/authorize';

const client_id = environment.REACT_APP_TWITTER_CLIENT_ID;
const redirect_uri = "http://www.localhost:3000/oauth/twitter";

export const getTwitterOauthUrl = (): string =&gt; {
  // temporarily uses static code verifier and challenge
  let code_challenge = "WeI7ul0uzUr0Zv89EPknzv4iNqmQuEysEtkWan7P3FA";
  let state = "state";
  let scope = ["users.read", "tweet.read", "follows.read", "follows.write"].join(" ");
  // @ts-ignore
  let args = new URLSearchParams({
    redirect_uri,
    client_id,
    state,
    response_type: 'code',
    code_challenge,
    code_challenge_method: "S256",
    scope,
  }).toString();
  return `${authEndpoint}?${args}`;
}
</code></pre>

<p>The button looks like below:</p>

<p><img src="/assets/img/oauth-pkce-login-button.jpeg" alt="img: oauth pkce login button" /></p>

<p>When a user (human) clicks the button, Twitter navigates to the login page if the user has not yet logged in.
If the user is already logged in, this step is skipped.</p>

<p><img src="/assets/img/oauth-pkce-twitter-login-page.jpeg" alt="img: oauth pkce twitter login page" /></p>

<p>After the successful login, Twitter shows the authorize app page.</p>

<p><img src="/assets/img/oauth-pkce-twitter-authorize-app-page.jpeg" alt="img: oauth pkce twitter authorize app page" /></p>

<p>When the user clicks the Authorize app button, Twitter redirects to the given redirect URI with the code as the URL parameter.</p>

<p>Up here, PKCE flow’s 1 to 6 steps are completed.</p>

<h5 id="user-profile">User Profile</h5>

<p>Let’s assume the server side app successfully gets the access token and the user profile from Twitter.
What the server app does at this point is to redirect back to the client app.
The example here sends back access_token and token expiry as URL parameters.
Those parameters are handled by TwitterLogin.tsx and hashUtils.ts.</p>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/TwitterLogin.tsx">TwitterLogin.tsx</a></li>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/utils/hashUtils.ts">hashUtils.ts</a></li>
</ul>

<pre><code class="language-typescript">// app/javascript/features/twitter/TwitterLogin.tsx
...
const { access_token, expires_in } = getOAuthParams();
removeHashParamsFromUrl();
...
useEffect(() =&gt; {
  if (access_token) {
    dispatch(setLoggedIn(true));
    dispatch(setAccessToken(access_token));
    dispatch(setTokenExpiryDate(Number(expires_in)));
    dispatch(setUserProfileAsync(access_token));
  }
}, [])
...
</code></pre>
<pre><code class="language-typescript">// app/javascript/utils/hashUtils.ts
export const getOAuthParams = () =&gt; {
  const urlParams = new URLSearchParams(window.location.search);
  return {
    access_token: urlParams.get('access_token'),
    expires_in: urlParams.get('expires_in'),
  };
}

export const removeHashParamsFromUrl = () =&gt; {
  window.history.pushState("", document.title, window.location.pathname);
}
</code></pre>

<p>The last line in useEffect function, <code>dispatch(setUserProfileAsync(access_token));</code>, triggers the me query.
The function is defined in twitterSlice.ts.</p>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/twitterSlice.ts">twitterSlice.ts</a></li>
</ul>

<pre><code class="language-typescript">// app/javascript/features/twitter/twitterSlice.ts
...
export const setUserProfileAsync = (accessToken: string): AppThunk =&gt; dispatch =&gt; {
  fetch('http://www.localhost:3000/me', {
    method: 'GET',
    headers: {
      Authorization: 'Bearer ' + accessToken,
    },
  }).then(response =&gt; response.json())
    .then((data) =&gt; {
      dispatch(setLoggedIn(true));
      dispatch(setName(data.name ? data.name : data.id));
      dispatch(setUsername(data.username));
    }).catch((error) =&gt; {
    console.log(error);
    if (error instanceof XMLHttpRequest) {
      if (error.status === 401) {
        dispatch(setLoggedIn(false));
      }
    }
  });
};
...
</code></pre>

<p>The client app returns the access token as is in the Authorization header.
This is the step 12 of the PKCE flow.
When the server app returns the user profile, that will be rendered in TwitterProfile.tsx.
By that, the last step, 14, of the PKCE flow completes.</p>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/TwitterProfile.tsx">TwitterProfile.tsx</a></li>
</ul>

<pre><code class="language-typescript">// app/javascript/features/twitter/TwitterProfile.tsx

...
export function TwitterProfile() {
  const name = useSelector(selectName);
  const username = useSelector(selectUsername);

  return (
    &lt;VStack&gt;
      {name &amp;&amp;
        &lt;Box&gt;
          &lt;Text&gt;Logged in as: {name}&lt;/Text&gt;
        &lt;/Box&gt;}
      {username &amp;&amp;
        &lt;Box&gt;
          &lt;Text&gt;Username: {username}&lt;/Text&gt;
        &lt;/Box&gt;
      }
      &lt;/VStack&gt;
  );
}
...
</code></pre>

<p><img src="/assets/img/oauth-pkce-user-profile.jpeg" alt="img: oauth pkce user profile" /></p>

<h4 id="core-logic-on-the-server-side-app">Core Logic on the Server Side App</h4>

<h5 id="setup-secrets">Setup Secrets</h5>

<p>The controllers needs some secret parameters.
Before going to the controller details, setup those parameters.
Choose your favorite editor, for example, EDITOR=”code –wait”.
The vim is the choice here.</p>

<pre><code class="language-bash">% EDITOR=vim rails credentials:edit
</code></pre>

<p>Write your JWT secret, Twitter app’s client id and client secret in the format below:</p>

<pre><code class="language-yml">jwt_secret: YOUR-JWT-SECRET-HERE
twitter:
  client_id: YOUR-TWITTER-APP-CLIENT-ID-HERE
  client_secret: YOUR-TWITTER-APP-CLIENT-SECRET-HERE
</code></pre>

<h5 id="oauthcontroller-details">OauthController Details</h5>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/controllers/oauth_controller.rb">oauth_controller.rb</a></li>
</ul>

<p>The OauthController performs the PKCE flow’s step from 7 to 11.
The authentication request made by the client app ends up coming to the redirect uri,
http://www.localhost:3000/oauth/twitter with the code as a URL parameter.
The controller gets the code, then makes a request to the Twitter access token endpoint with the code and other parameters.</p>

<pre><code class="language-ruby">// app/controllers/oauth_controller.rb

...
    def twitter
        client_id = Rails.application.credentials.twitter.client_id.strip
        client_secret = Rails.application.credentials.twitter.client_secret.strip
        oauthTokenParams = {
          redirect_uri: 'http://www.localhost:3000/oauth/twitter',
          code: params[:code]
        }
        access_token, expires_in = getOAuthToken("https://api.twitter.com", "/2/oauth2/token",
                                                 client_id, client_secret,
                                                 oauthTokenParams) 
        ...
    end
...
    def getBasicAuthToken(client_id, client_secret)
      Base64.strict_encode64("#{client_id}:#{client_secret}")
    end

    def getOAuthToken(url, path, client_id, client_secret, oauth_token_params)
      oauth_token_params = oauth_token_params.merge({
                                                      grant_type: 'authorization_code',
                                                      client_id: client_id,
                                                      code_verifier: CODE_VERIFIER
                                                    }))
      conn = Faraday.new(
        url: url,
        headers: {
          'Content-Type' =&gt; 'application/x-www-form-urlencoded',
          'Authorization' =&gt; "Basic #{getBasicAuthToken(client_id, client_secret)}"
        }
      )
      response = conn.post(path, URI.encode_www_form(oauth_token_params))
      body_obj = JSON.parse(response.body)
      [body_obj['access_token'], body_obj['expires_in']]
    end
...
</code></pre>

<p>Once the access token is successfully returned from Twitter, the next step is to get a user profile.
The me query to Twitter does the job.
The access token is set in the Authorization header to make the me query.</p>

<pre><code class="language-ruby">// app/controllers/oauth_controller.rb

def twitter
    ...
    data = getUser("https://api.twitter.com", "/2/users/me", access_token)
    ...
end
...
def getUser(url, path, access_token)
    conn = Faraday.new(
      url: url,
      headers: {
        'Content-Type' =&gt; 'application/x-www-form-urlencoded',
        'Authorization' =&gt; "Bearer #{access_token}"
      }
    )
    response = conn.get(path)
    body_obj = JSON.parse(response.body)
    body_obj['data']
end
...
</code></pre>

<p>After the server side app gets the user profile, the user is either created on or retrieved from a local database.</p>

<pre><code class="language-ruby">// app/controllers/oauth_controller.rb

def twitter
  ...
  user = getUserFromDb(
    {
      username: data['username'],
      name: data['name'],
      provider: User.providers[:twitter],
      pid: data['id']
    }
  )
  ...
end
</code></pre>

<p>Almost there.
The following step is to sign access token and user info.
This example app uses user’s username and name with the access token.</p>

<pre><code class="language-ruby">// app/controllers/oauth_controller.rb

def twitter
  ...
  signedToken = getSignedToken(access_token, user)
  ...
end
...
def getSignedToken(access_token, user)
  JWT.encode(
    {
      username: user.username,
      provider: user.provider,
      accessToken: access_token
    },
    Rails.application.credentials.jwt_secret,
    'HS256'
  )
end
</code></pre>

<p>Finally, the controller redirects back to the client app with the signed access token and token’s expiry.</p>

<pre><code class="language-ruby">// app/controllers/oauth_controller.rb

def twitter
  ...
  redirect_to(root_path(access_token: signedToken, expires_in: expires_in))
end
</code></pre>

<h5 id="mecontroller-details">MeController Details</h5>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/controllers/me_controller.rb">me_controller.rb</a></li>
</ul>

<p>The MeController gets signed access token from the Authorization header which is sent back by the client app.
Then, the token is decoded using the same JWT secret.
The decoded token has the user info which can be verified to make a query to the local database.
The result of the database query is returned to the client app.</p>

<p>The example app skips the access token validity check since it focuses on the PKCE flow only.
However, in a real situation, the access token should be checked.</p>

<pre><code class="language-ruby">// app/controllers/me_controller.rb

...
class MeController &lt; ApplicationController
  def profile
    payload = decodeSignedJwtToken(getBearerToken()).first
    user = User.where(provider: payload["provider"], username: payload["username"]).first
    render json: user
  end

  def getBearerToken
    pattern = /^Bearer /
    request.authorization.gsub(pattern, '') if request.authorization
  end

  def decodeSignedJwtToken(token)
    JWT.decode(
      token,
      Rails.application.credentials.jwt_secret,
      true,
      { algorithm: 'HS256' }
    )
  end
end
</code></pre>

<h3 id="conclusion">Conclusion</h3>

<p>The example app’s purpose is to show how PKCE flow works.
So, some parts are missing.
For example, the code verifier and code challenge should be generated in each authentication process, but not.
The access token should be saved in both client and server apps and re-requested when the token is expired.
The example app skips that as well.</p>

<p>Even though, the example app would help to understand how the PKCE flow works between React app, Rails app and
Authorization endpoint.</p>

<h3 id="references">References</h3>
<h4 id="proof-key-for-code-exchange">Proof Key for Code Exchange</h4>
<ul>
  <li><a href="https://oauth.net/2/pkce/">RFC 7636: Proof Key for Code Exchange</a></li>
  <li><a href="https://blog.miniorange.com/auth-flow-with-pkce/">Authorization Code Flow with Proof Key for Code Exchange (PKCE)</a></li>
  <li><a href="https://hceris.com/oauth-authorization-code-flow-pkce-for-react/">Authorization Code Flow with PKCE (OAuth) in a React application</a></li>
  <li><a href="https://developer.twitter.com/en/docs/authentication/oauth-2-0/authorization-code">Twitter Documentation: Authentication</a></li>
  <li><a href="https://developer.spotify.com/documentation/web-api/tutorials/code-pkce-flow">Spotify for Developers: Authorization Code with PKCE Flow</a></li>
</ul>

<h4 id="implementation">Implementation</h4>
<ul>
  <li><a href="https://dev.to/reinforz/implementing-authentication-with-twitter-oauth-20-using-typescript-node-js-express-js-and-next-js-in-a-full-stack-application-353d">Implementing Authentication with Twitter OAuth 2.0 using Typescript, Express.js and Next.js</a></li>
  <li><a href="https://medium.com/swlh/create-a-react-app-with-typescript-redux-and-oauth-2-0-7f62d57890df">Create a React App with TS, Redux and OAuth 2.0 - Spotify login example</a></li>
  <li><a href="https://dev.to/sbelzile/stop-using-dotenv-in-your-front-end-427p">Stop using Dotenv in your front-end</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[Logging in to a web site is what users do quite a lot. Suppose it is a blog site. Once a user completes a log-in process, the user is allowed to create a new post, update contents and delete a post. The blog site might have a feature to leave comments by logged in users.]]></summary></entry></feed>