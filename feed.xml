<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-28T16:42:02+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">yokolet’s notelets</title><subtitle>Blog site mostly for programming topics.</subtitle><entry><title type="html">Vite + Vue + Bun on Rails</title><link href="http://localhost:4000/2024/03/05/vite-vue-bun-on-rails.html" rel="alternate" type="text/html" title="Vite + Vue + Bun on Rails" /><published>2024-03-05T21:18:00+09:00</published><updated>2024-03-05T21:18:00+09:00</updated><id>http://localhost:4000/2024/03/05/vite-vue-bun-on-rails</id><content type="html" xml:base="http://localhost:4000/2024/03/05/vite-vue-bun-on-rails.html"><![CDATA[<p><a href="https://vuejs.org/">Vue.js</a> is one of frontend frameworks gaining popularity among rapidly emerging JavaScript technologies.
The combination of Vue.js and Rails is becoming more popular as well,
however, Vue.js development on Rails is not so straightforward.
The reason would be that Vue.js relies on <a href="https://vitejs.dev/">Vite</a> for a development environment
such as HMR (Hot Module Replacement) and bundling.</p>

<p>Since Rails 7, some JavaScript approaches have been supported.
As of version 7.1.3.2, importmap (default), bun, webpack, esbuild and rollup are the choices.
Vite is a replacement of such JavaScript approaches, but is not listed yet.</p>

<p>Here comes the <a href="https://rubygems.org/gems/vite_rails">vite_rails gem</a>.
The gem sets up the environment for Vite on Rails.
Vite itself is independent from frontend frameworks.
By adding a plugin, Vite + Vue development environment will be created.</p>

<p>One more addition in this blog post is <a href="https://bun.sh/">Bun</a>.
Bun runs really fast.
Here, Bun is used just a replacement of npm or yarn.
However, Bun is a all-in-one toolkit and covers some features of Vite such as bundling.
For the topic of Bun vs. Vite, the blog post,
<a href="https://dev.to/this-is-learning/why-use-vite-when-bun-is-also-a-bundler-vite-vs-bun-2723">Why use Vite when Bun is also a bundler? - Vite vs. Bun</a>,
explains well.
At this moment, Vite on Bun is an effective combination.</p>

<p>This blog post explains how Vue, Vite and Bun on Rails can be created.
The source code is on the GitHub, <a href="https://github.com/yokolet/rails-vite-vue">rails-vite-vue</a>.</p>

<h3 id="prerequisite">Prerequisite</h3>

<p>This blog is not about a big application,
even though we need tools to be installed before getting started.
Below is a list of what should be installed.</p>

<ol>
  <li>Ruby: <a href="https://www.ruby-lang.org/en/documentation/installation/">Installing Ruby</a></li>
  <li>Rails: <a href="https://guides.rubyonrails.org/v5.0/getting_started.html#installing-rails">Installing Rails</a></li>
  <li>Node.js: <a href="https://nodejs.org/en/download/package-manager/">Installing Node.js via package manager</a><br />
or Download from <a href="https://nodejs.org/en">https://nodejs.org/en</a></li>
  <li>Bun: <a href="https://bun.sh/docs/installation">https://bun.sh/docs/installation</a></li>
</ol>

<h3 id="versions">Versions</h3>

<ul>
  <li>Ruby 3.2.3</li>
  <li>Rails 7.1.3.2</li>
  <li>Node.js v21.5.0</li>
  <li>Bun 1.0.29</li>
</ul>

<h3 id="create-a-rails-app-skipping-javascript">Create a Rails App Skipping JavaScript</h3>

<p>Rails supports importmap (default), bun, webpack, esbuild and rollup as JavaScript approaches.
None of those will be used to transpile, bundle, or etc. to create a frontend by Vue.
Bun will be used, but its role is a replacement of npm or yarn here.
The best option is <code>--skip-javascript</code>.
Also, <code>--minimal</code> option works if the app can be a simple one.</p>

<p>The command blow creates a Rails app without a JavaScript support.</p>

<pre><code class="language-bash">$ rails new [APP NAME] --skip-javascript -T
</code></pre>

<h3 id="install-vite">Install Vite</h3>

<p>The next step is to install Vite.
Change a directory to the application, then type the command below.</p>

<pre><code class="language-bash">$ bundle add vite_rails
</code></pre>

<p>The command above installs vite_rails gem along with a Ruby version of vite command.
The Ruby version of vite command is used to install Vite and JavaScript version of vite command.</p>

<p>Now, it’s time to use the Ruby version of vite command. Type below.</p>

<pre><code class="language-bash">$ bundle exec vite install
</code></pre>

<p>Above command does a lot.
It installs the vite JavaScript package which includes JavaScript version of vite command.
Also, it installs the vite-plugin-ruby JavaScript package.
During the package installation, npm runs. It looks no option to switch to yarn or bun.</p>

<p>Additionally, it creates files listed below.</p>

<ul>
  <li>Procfile.dev</li>
  <li>app/frontend/entrypoints/application.js</li>
  <li>bin/vite</li>
  <li>config/initializers/content_security_policy.rb</li>
  <li>config/vite.json</li>
  <li>vite.config.ts</li>
</ul>

<h3 id="switching-from-npm-to-bun">Switching from npm to bun</h3>

<p>Bun runs really fast, so this blog uses bun instead of npm.
Since package-lock.json is no longer needed, delete the npm lock file.</p>

<pre><code class="language-bash">$ rm package-lock.json
$ bun install
</code></pre>

<p>Once bun install is completed,  Bun’s lock file, <code>bun.lockb</code>, will be created.
After this, use bun command to install JavaScript packages.</p>

<h3 id="install-vue-and-vue-plugin">Install Vue and Vue Plugin</h3>

<p>We need Vue JavaScript package to develop Vue app.
We also need the Vue plugin for Vite.
Vite is a framework independent development tool.
To use Vite for Vue development, Vue plugin should be installed and set up.</p>

<pre><code class="language-bash">$ bun add vue @vitejs/plugin-vue
</code></pre>

<p>After the vue and plugin installation, edit <code>vite.config.ts</code> to set up Vue plugin.</p>

<pre><code class="language-typescript">import { defineConfig } from 'vite'
import RubyPlugin from 'vite-plugin-ruby'
import vue from '@vitejs/plugin-vue' // added

export default defineConfig({
  plugins: [
    RubyPlugin(),
    vue(),  // added
  ],
})
</code></pre>

<h3 id="set-up-starter-command">Set up Starter Command</h3>

<p>When the app was created, we skipped the JavaScript approaches.
Because of that, the app doesn’t have a handy command such as <code>bin/dev</code>.
The vite_rails gem created <code>Profile,dev</code> configuration for a foreman.
This works, but, still, we need to type <code>foreman start -f Procfile.dev</code> to start the development server.
It’s better to have the command, <code>bin/dev</code>.</p>

<h5 id="packagejson">package.json</h5>

<p>Add the scripts section in package.json.</p>

<pre><code class="language-json">{
  "scripts": {
    "dev": "bunx --bun vite",
    "build": "bunx --bun vite build"
  },
  "devDependencies": {
    "vite": "^5.1.4",
    "vite-plugin-ruby": "^5.0.0"
  },
  "dependencies": {
    "@vitejs/plugin-vue": "^5.0.4",
    "vue": "^3.4.21"
  }
}
</code></pre>

<p>The <a href="https://bun.sh/docs/cli/bunx">bunx command</a> should be installed when Bun was installed.
The bunx is a counterpart of npx.</p>

<h5 id="procfiledev">Procfile.dev</h5>

<p>Update the file as in below.</p>

<pre><code class="language-bash">web: env RUBY_DEBUG_OPEN=true bin/rails server
js: bun run dev
</code></pre>

<p>This setting is to start two servers – one for Rails and another for a frontend.</p>

<h5 id="bindev">bin/dev</h5>

<p>Create a new file <code>bin/dev</code> with the contents below.</p>

<pre><code class="language-bash">#!/usr/bin/env sh

if gem list --no-installed --exact --silent foreman; then
  echo "Installing foreman..."
  gem install foreman
fi

# Default to port 3000 if not specified
export PORT="${PORT:-3000}"

exec foreman start -f Procfile.dev "$@"
</code></pre>

<p>Then, change the file permission to executable.
For example, <code>chmod 755 bin/dev</code>.</p>

<p>For now, we can start the two development servers by just typing <code>bin/dev</code>.</p>

<h3 id="create-a-vue-app-mount-point">Create a Vue App Mount Point</h3>

<p>Since it is a Rails app, a controller is responsible to receive HTTP requests.</p>

<pre><code class="language-bash">$ rails g controller pages index
</code></pre>

<p>Edit <code>app/views/pages/index.html.erb</code> to add the mount point.</p>

<pre><code class="language-erbruby">&lt;%= content_tag(:div, "", id:"app") %&gt;
</code></pre>

<p>Edit <code>config/routes.rb</code> so that the Vue app can be seen at a root path.</p>

<pre><code class="language-ruby">Rails.application.routes.draw do
  root 'pages#index'  # updated for a Vue app
  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html

  # Reveal health status on /up that returns 200 if the app boots with no exceptions, otherwise 500.
  # Can be used by load balancers and uptime monitors to verify that the app is live.
  get "up" =&gt; "rails/health#show", as: :rails_health_check

  # Defines the root path route ("/")
  # root "posts#index"
end
</code></pre>

<h3 id="create-a-vue-app">Create a Vue App</h3>

<p>To make an app creation simple, the Vue app used here is the one create by <code>bun create vite</code> command.
During the app creation, Vue and JavaScript was selected as a framework and language.</p>

<p>When vite_rails gem is used, an entrypoint file is <code>app/frontend/entrypoints/application.js</code>.
The file is equivalent to <code>main.js</code> of the Vue sample app.
Replace whole content of application.js (Rails) by main.js (Vite + Vue)
or add entire main.js (Vite + Vue) to application.js (Rails).</p>

<p>Six files of Vite + Vue app below:</p>

<pre><code class="language-bash">$ tree src public
src
├── App.vue
├── assets
│   └── vue.svg
├── components
│   └── HelloWorld.vue
├── main.js
└── style.css
public
└── vite.svg

4 directories, 6 files
</code></pre>

<p>should be mapped to below on Rails:</p>

<pre><code class="language-bash">$ tree app/frontend
app/frontend
├── App.vue
├── assets
│   └── vue.svg
├── components
│   └── HelloWorld.vue
├── entrypoints
│   ├── application.js
│   └── style.css
└── vite.svg

4 directories, 6 files
</code></pre>

<p>How to organize directories/files under app/frontend looks not standardized yet.
The vite_rails gem watches all files under app/frontend and reload if necessary.
Above directory structure is just an example.</p>

<h3 id="start-the-app-and-verify-hmr">Start the App and Verify HMR</h3>

<p>Start the servers by:</p>

<pre><code class="language-bash">$ bin/dev
</code></pre>

<p>Open http://localhost:3000/ on a browser.
The webpage below should show up.</p>

<p><img width="500px" src="http://localhost:4000/assets/img/vite_vue_rails.jpeg" alt="img: vite + vue on rails" /></p>

<p>Try editing <code>app/frontend/App.vue</code> and <code>app/frontend/components/HelloWorld.vue</code> and
verify HMR (Hot Module Replacement) is working.</p>

<h3 id="references">References</h3>
<ul>
  <li>Vite Ruby: <a href="https://vite-ruby.netlify.app/">https://vite-ruby.netlify.app/</a></li>
  <li>Vue.js Guide: <a href="https://vuejs.org/guide/introduction.html">https://vuejs.org/guide/introduction.html</a></li>
  <li>Build a frontend using Vite and Bun: <a href="https://bun.sh/guides/ecosystem/vite">https://bun.sh/guides/ecosystem/vite</a></li>
  <li><a href="https://dev.to/this-is-learning/why-use-vite-when-bun-is-also-a-bundler-vite-vs-bun-2723">Why use Vite when Bun is also a bundler? - Vite vs. Bun</a></li>
  <li><a href="https://bootrails.com/blog/ruby-on-rails-and-vuejs-tutorial/">Ruby-on-Rails and VueJS tutorial</a></li>
  <li><a href="https://dev.to/chmich/setup-vite-on-rails-7-f1i">Create Rails-7 app with Vite</a></li>
  <li><a href="https://dev.to/jetthoughts/integrating-bun-with-vite-ruby-for-lightning-fast-frontend-builds-1fh2">Integrating Bun with Vite Ruby for Lightning-Fast Frontend Builds</a></li>
  <li><a href="https://clouddevs.com/ruby-on-rails/building-app-with-vuejs-frontend/">Building a Rails App with a Vue.js Frontend</a></li>
  <li><a href="https://medium.com/@oscarreciogonzalez/vue-on-rails-15686b85b1d3">Vue on Rails</a></li>
  <li><a href="https://guillaume.barillot.me/2022/05/05/rails-vite-vue-3-pina-starter-pack/">Rails 7 + Vite + Vue 3 + Pinia starter pack</a></li>
  <li>Source code: <a href="https://github.com/yokolet/rails-vite-vue">https://github.com/yokolet/rails-vite-vue</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[Vue.js is one of frontend frameworks gaining popularity among rapidly emerging JavaScript technologies. The combination of Vue.js and Rails is becoming more popular as well, however, Vue.js development on Rails is not so straightforward. The reason would be that Vue.js relies on Vite for a development environment such as HMR (Hot Module Replacement) and bundling.]]></summary></entry><entry><title type="html">Bun + React on Rails</title><link href="http://localhost:4000/2024/03/01/bun-react-on-rails.html" rel="alternate" type="text/html" title="Bun + React on Rails" /><published>2024-03-01T15:31:00+09:00</published><updated>2024-03-01T15:31:00+09:00</updated><id>http://localhost:4000/2024/03/01/bun-react-on-rails</id><content type="html" xml:base="http://localhost:4000/2024/03/01/bun-react-on-rails.html"><![CDATA[<p>In the frontend world, new technologies keep emerging rapidly these years.
Still, React is a well-established and very popular frontend framework,
Vue.js, Svelte, Astro and more frameworks are gaining popularity.
Not just the frameworks, tools for a transpiler/bundler or sort are also under a rapid development.
In JavaScript domain, esbuild, rollup, vite and some more are out.</p>

<p>Relatively new addition is Bun (<a href="https://bun.sh/">https://bun.sh/</a>).</p>

<p>Bun has multiple features.
It can be used as a package manager, development server, bundler and test runner.
On the website, it says an all-in-one toolkit for JavaScript.
The best advantage of using Bun would be its speed.
Indeed, Bun runs very fast.</p>

<p>Rails supports Bun since version 7.1 as one of JavaScript approaches.
This blog post is about the attempt to create a React app using Bun.</p>

<h4 id="prerequisite">Prerequisite</h4>

<p>Prior to the Rails application creation, <code>bun</code> command should be installed.
The installation instruction is on the Bun website, <a href="https://bun.sh/docs/installation">https://bun.sh/docs/installation</a>.
The website shows 5 ways to install bun if you have macOS and Linux.
Among those, by curl command, Homebrew and npm would be popular.
Choose whatever you like.</p>

<ul>
  <li>curl
    <pre><code class="language-bash">$ curl -fsSL https://bun.sh/install | bash # for macOS, Linux, and WSL
</code></pre>
  </li>
  <li>Homebrew
    <pre><code class="language-bash">$ brew install oven-sh/bun/bun # for macOS and Linux
</code></pre>
  </li>
  <li>npm
    <pre><code class="language-bash">$ npm install -g bun # the last `npm` command you'll ever need
</code></pre>
  </li>
</ul>

<p>The Bun website also has an instruction for Windows.</p>

<h4 id="versions">Versions</h4>
<ul>
  <li>Ruby 3.2.3</li>
  <li>Rails 7.1.3.2</li>
</ul>

<h3 id="create-a-rails-app-with-bun-option">Create a Rails App with bun Option</h3>

<p>The command to create an app which uses bun is something like this:</p>

<pre><code class="language-bash">% rails new [APP NAME] -j bun -T
</code></pre>

<p>Above command installs all including <code>bun install</code>.
After the installation finishes, change the directory to application and just type <code>bin/dev</code>.
The Rails should start up.
Verify that by visiting http://localhost:3000/ on a browser.</p>

<p>In early releases of Rail 7.1, some odds were reported to start the Rails.
However, on version 7.1.3.2, all those issues look fixed.
None of extra steps are required to start Rails now.</p>

<h3 id="files-related-to-bun">Files Related to Bun</h3>

<p>Let’s look at files in the Rails application top directory.</p>
<h4 id="bunlockb">bun.lockb</h4>
<p>This file is a lock file equivalent to package-lock.json or yarn.lock.
Unlike a legacy lock file, bun.lockb is a binary file.</p>

<h4 id="bunconfigjs">bun.config.js</h4>
<p>This is a Bun configuration file which defines how Bun builds the application.
When the Rails generator created the file, a build configuration is defined like this:</p>
<pre><code class="language-javascript">const config = {
  sourcemap: "external",
  entrypoints: ["app/javascript/application.js"],
  outdir: path.join(process.cwd(), "app/assets/builds"),
};
</code></pre>

<p>The details of the configuration parameters are explained at <a href="https://bun.sh/docs/bundler#api">https://bun.sh/docs/bundler#api</a>.</p>

<p>For example, to minify output JavaScript files, the configuration will be:</p>
<pre><code class="language-javascript">const config = {
  sourcemap: "external",
  entrypoints: ["app/javascript/application.js"],
  outdir: path.join(process.cwd(), "app/assets/builds"),
  minify: true,
};
</code></pre>
<p>We see more than ten configuration APIs on the web page.
However, not many options work seamlessly with Rails.
Suppose the naming setting is changed to <code>naming: '[dir]/[name]-[hash].[ext]'</code>
(default for the entry is ‘[dir]/[name].[ext]’),
the generated JavaScript file will be something like <code>application-6da4a92fc66938e4.js</code>.
It looks good at a glance.
However, javascript_include_tag in app/views/layouts/application.html.erb should be changed like
<code>&lt;%= javascript_include_tag "application-6da4a92fc66938e4", "data-turbo-track": "reload", type: "module" %&gt;</code>.
When the JavaScript file is updated, the hash value will be updated as well.
As a result, the outdir will have multiple <code>application-[hash].js</code> files.
Also, javascript_include_tag’s filename should be updated accordingly.
Moreover, Rails adds a hash value when the JavaScript file is provided.
It is something like, <code>application-921e7020b343a6ac4bfb2c1d2302254e1f5ea0fda39e8ee8c38aa17e00d8e0e2.js</code>.</p>

<p>Although Bun configuration API has many options, only few are useful on Rails.</p>

<h4 id="procfiledev">Procfile.dev</h4>

<p>The file is a server setting passed to Foreman.
When the Rails application is created with <code>-j bun</code> option, the file looks like below:</p>
<pre><code class="language-bash">web: env RUBY_DEBUG_OPEN=true bin/rails server
js: bun run build --watch
</code></pre>

<p>Bun’s <code>--watch</code> options is explained at Watch mode (<a href="https://bun.sh/docs/runtime/hot">https://bun.sh/docs/runtime/hot</a>).
When the option is specified, Bun watches changes in JavaScript files listed in the entrypoints configuration.
If Bun detects a change, Bun restarts the process.</p>

<p>Another option is <code>--hot</code>. However, <code>--hot</code> option works when Bun is used on the server side.
Besides, as above web page explains, the option is not for a hot loading to the browser.
When the JavaScript code is updated, still we need to click browser’s reload button.
The hot loading to the browser will be a job by <a href="https://vitejs.dev/">Vite</a>.</p>

<h3 id="create-a-react-app">Create a React App</h3>

<p>The first step is to install packages.</p>

<pre><code class="language-bash">$ bun add react react-dom
</code></pre>

<p>You might be surprised. Bun runs really fast.</p>

<p>Next step is to write React code.
For a simplicity, the React app used here is the one create-react-app package creates.
The app shows a rotating React logo and a couple other messages.
JavaScript code can be used as those are except image and stylesheet imports.
Since the server side is Rails, it’s good and easy to put images and stylesheets in the directories meant to be.
For that reason, the sample app takes idiomatic Rails rather than idiomatic React.</p>

<ul>
  <li>app/javascript/application.js</li>
</ul>

<p>The entrypoint file is index.js on a generated React app, while it is application.js on Rails.
Replace the contents of <code>app/javascript/application.js</code> by index.js.</p>

<pre><code class="language-javascript">import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;
);
</code></pre>

<ul>
  <li>app/javascript/App.js</li>
</ul>

<p>This is an App component. Other than stylesheet and image imports, the code stays the same as React app.</p>

<pre><code class="language-javascript">function App() {
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;img src="/assets/logo.svg" className="App-logo" alt="logo" /&gt;
        &lt;p&gt;
          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.
        &lt;/p&gt;
        &lt;a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        &gt;
          Learn React
        &lt;/a&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>

<ul>
  <li>index.css, App.css and logo.svg</li>
</ul>

<p>Copy two css files under app/assets/stylesheets. No need to edit those.
Also, copy logo.svg under app/assets/images.</p>

<p>The directory structures become look like below.</p>

<pre><code>app/javascript
├── App.js
├── application.js
└── controllers
    ├── application.js
    ├── hello_controller.js
    └── index.js

2 directories, 5 files
</code></pre>

<pre><code>app/assets
├── builds
│   ├── application.js
│   └── application.js.map
├── config
│   └── manifest.js
├── images
│   └── logo.svg
└── stylesheets
    ├── App.css
    ├── application.css
    └── index.css

5 directories, 7 files
</code></pre>

<h3 id="create-a-mount-point">Create a Mount Point</h3>

<p>Since this is a Rails app, a controller is responsible to receive HTTP requests.
To show the React app on a browser, the controller for that should be created along with a view.</p>

<pre><code class="language-bash">$ rails g controller pages index
</code></pre>

<p>Above command creates a controller and view, also adds a new route in config/routes.rb</p>

<ul>
  <li>app/view/pages/index.html.erb</li>
</ul>

<p>In the app/javascript/application.js, “root” is specified as a mount point.
Add a div tag in the index.html.erb file.</p>

<pre><code class="language-html">&lt;h1&gt;Pages#index&lt;/h1&gt;
&lt;p&gt;Find me in app/views/pages/index.html.erb&lt;/p&gt;
&lt;%= content_tag(:div, "", id:"root") %&gt;
</code></pre>

<h3 id="run-the-app">Run the app</h3>

<p>All are ready. Let’s run the app.</p>

<pre><code class="language-bash">$ bin/dev
</code></pre>

<p>Then go to http://localhost:3000/pages/index on the browser.
The React app shows up.</p>

<p><img width="300px" src="http://localhost:4000/assets/img/rails-bun-react.jpeg" alt="img: bun + react on rails" /></p>

<h3 id="references">References</h3>
<ul>
  <li><a href="https://bun.sh/docs">https://bun.sh/docs</a></li>
  <li><a href="https://webcrunch.com/posts/bun-with-ruby-on-rails">How to use Bun with Ruby on Rails</a></li>
  <li>Sample code: <a href="https://github.com/yokolet/rails-bun-react">https://github.com/yokolet/rails-bun-react</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[In the frontend world, new technologies keep emerging rapidly these years. Still, React is a well-established and very popular frontend framework, Vue.js, Svelte, Astro and more frameworks are gaining popularity. Not just the frameworks, tools for a transpiler/bundler or sort are also under a rapid development. In JavaScript domain, esbuild, rollup, vite and some more are out.]]></summary></entry><entry><title type="html">Ruby on Rails Secrets Management</title><link href="http://localhost:4000/2023/09/04/ruby-on-rails-secrets-management.html" rel="alternate" type="text/html" title="Ruby on Rails Secrets Management" /><published>2023-09-04T15:13:00+09:00</published><updated>2023-09-04T15:13:00+09:00</updated><id>http://localhost:4000/2023/09/04/ruby-on-rails-secrets-management</id><content type="html" xml:base="http://localhost:4000/2023/09/04/ruby-on-rails-secrets-management.html"><![CDATA[<p>A web application needs various kinds of values, params and etc which should not be revealed to the public, say GitHub repo.
For example, API keys, tokens, passwords, and endpoints, all those should be kept secret.
Another important factor is that such secrets should be shared among the team members.
Additionally, all those secrets should come along with the deployment.</p>

<p>Previously, the dotenv file (.env) is commonly used for this purpose.
When the web application is deployed, the secrets are set up as environment variables.</p>

<h3 id="rails-way-of-secrets-management">Rails Way of Secrets Management</h3>

<p>Since version 5.2, Rails provides a new way of secret management
(<a href="https://rubyonrails.org/2018/4/9/Rails-5-2-0-final">Rails 5.2.0 FINAL: Active Storage, Redis Cache Store, HTTP/2 Early Hints, CSP, Credentials</a>).
It consists of an encrypted credentials file and a key to encrypt/decrypt it.
By default, those are config/credentials.yml.enc and config/master.key,
which are generated by a rails new command.
The credentials.yml.enc is encrypted, so it can be safely pushed to the GitHub repo.
While the master.key should kept secret and never be pushed to the GitHub repo.
The master.key is often shared among team members by a secure measure.</p>

<p>To edit the credentials file, use the <code>rails credentials:edit</code> command with the EDITOR environment variable.
For example:</p>
<pre><code class="language-bash">$ EDITOR=vim rails credentials:edit
$ EDITOR="code --wait" rails credentials:edit
</code></pre>

<p>If the master.key doesn’t exist, Rails shows the message below.</p>
<blockquote>
  <p>When the config/master.key is missing, the command shows the suggestion.</p>

  <p>$ EDITOR=vim rails credentials:edit
Adding config/master.key to store the encryption key: ed36bdc2…….</p>

  <p>Save this in a password manager your team can access.</p>

  <p>If you lose the key, no one, including you, can access anything encrypted with it.</p>

  <pre><code> create  config/master.key
</code></pre>

  <p>Couldn’t decrypt config/credentials.yml.enc. Perhaps you passed the wrong key?</p>
</blockquote>

<p>Even though the new master.key is created following the message,
the existing credentials.yml.enc won’t be decrypted.
It needs the exact key the file is encrypted.
This way, we can safely push the credentials.yml.enc file to the GitHub repo.</p>

<h3 id="how-to-use-credentials">How to Use Credentials</h3>

<p>As the file extension expresses, the credentials file takes YAML format.
It is structured, not like a dotenv file.</p>

<p>When the rails new command creates the credentials file, it looks like this.</p>

<pre><code class="language-yaml"># aws:
#   access_key_id: 123
#   secret_access_key: 345

# Used as the base secret for all MessageVerifiers in Rails, including the one protecting cookies.
secret_key_base: 3cfc7cf4......
</code></pre>

<p>We can add various secrets in YAML format.
For example, some_api_key, client_id and client_secret pairs for OAuth authentication can be
written here.</p>

<pre><code class="language-yaml">secret_key_base: 3cfc7cf4......
some_api_key: HERE_IS_MY_API_KEY
oauth:
  twitter:
    client_id: MY_TWITTER_CLIENT_ID
    client_secret: MY_TWITTER_CLIENT_SECRET
  facebook:
    client_id: MY_FACEBOOK_CLIENT_ID
    client_secret: MY_FACEBOOK_CLIENT_SECRET
</code></pre>

<p>To use above secrets in Rails app,
Rails.application.credentials.[key1].[key2]… is the way to access those.
We can confirm that on the Rails console.</p>

<pre><code class="language-bash">$ rails c
Loading development environment (Rails 7.0.4.2)
irb(main):001:0&gt; Rails.application.credentials.some_api_key
=&gt; "HERE_IS_MY_API_KEY"
irb(main):002:0&gt; Rails.application.credentials.oauth.twitter.client_id
=&gt; "MY_TWITTER_CLIENT_ID"
irb(main):003:0&gt; Rails.application.credentials.oauth.twitter.client_secret
=&gt; "MY_TWITTER_CLIENT_SECRET"
</code></pre>

<h3 id="multi-environment-credentials">Multi-environment credentials</h3>

<p>Since Rails 6, the multi-environment credentials are supported.
When secrets are not the same between development and production environment,
those could’ve been differentiated by a nested YAML notation. For example,</p>

<pre><code class="language-yaml"># before Rails 6
development:
  some_api_key: API_KEY_FOR_DEV
production:
  some_api_key: API_KEY_FOR_PROD
</code></pre>

<p>However, in the Rails app, we should’ve written something like:</p>

<pre><code class="language-ruby"># before Rails 6
if Rails.env == "development"
  api_key = Rails.application.credentials.development.some_api_key
elsif Rails.env == "production"
  api_key = Rails.application.credentials.production.some_api_key
end
</code></pre>

<p>In contract, with the multi-environment credentials,
the credentials file is chosen based on the Rails environment.
If the Rails environment is a production, config/credentials/production.yml.enc is used.
The key to encrypt/decrypt is just for the production env, config/credentials/production.key.
This way, we can eliminate the environment check in our code.</p>

<h4 id="create-the-environment-specific-credentials">Create the environment specific credentials</h4>

<p>To create the Rails environment based credentials, use –environment option.</p>

<pre><code class="language-bash">$ EDITOR=vim rails credentials:edit --environment development
$ EDITOR=vim rails credentials:edit --environment production
</code></pre>

<p>Above commands creates credential and key files under config/credentials directory.</p>

<pre><code class="language-bash">$ tree config/credentials
config/credentials
├── development.key
├── development.yml.enc
├── production.key
└── production.yml.enc

1 directory, 4 files
</code></pre>

<p>The newly generated development/production credential files don’t have a secret_key_base entry.
Under the development environment, missing secret_key_base looks not an immediate problem.
However, under the production environment, it raises an exception.</p>

<pre><code class="language-bash">$ RAILS_ENV=production rails c
/Users/yoko/.gem/ruby/3.2.1/gems/railties-7.0.4.2/lib/rails/application.rb:581:in `validate_secret_key_base': Missing `secret_key_base` for 'production' environment, set this string with `bin/rails credentials:edit` (ArgumentError)
...
...
</code></pre>

<p>We should add secret_key_base in the credentials file.
To generate the value, Rails provides the command:</p>

<pre><code class="language-bash">$ rake secret
a2b30cf4d702a........
</code></pre>

<p>Open the production.yml.enc file and copy/paste the generated secret as the value of secret_key_base.</p>

<pre><code class="language-yaml">secret_key_base: a2b30cf4d702a........
some_api_key: API_KEY_FOR_PROD
</code></pre>

<p>Now, we can check the production secrets.</p>

<pre><code class="language-bash">$ RAILS_ENV=production rails c
Loading production environment (Rails 7.0.4.2)
irb(main):001:0&gt; Rails.application.credentials.some_api_key
=&gt; "API_KEY_FOR_PROD"
</code></pre>

<h3 id="deploy-to-heroku">Deploy to Heroku</h3>

<p>Heroku is a popular hosting service for a Rails app.
However, not like AWS EC2 instance, people don’t have a direct access to the instance.
The encrypt/decrypt key should be installed by a heroku command.</p>

<p>One thing we should know is,
Rails “looks for the environment variable ENV[“RAILS_MASTER_KEY”] to encrypt the credentials file”
(<a href="https://edgeguides.rubyonrails.org/security.html#custom-credentials">Securing Rails Applications</a>).
Whether the environment is development or production, Rails sees ENV[“RAILS_MASTER_KEY”].</p>

<p>Heroku’s staging server runs under the production environment.
To deploy the config/production.key, use the Heorku CLI command below:</p>

<pre><code class="language-bash">heroku config:set RAILS_MASTER_KEY=`cat config/credentials/production.key`
</code></pre>

<h3 id="references">References</h3>
<ul>
  <li><a href="https://edgeguides.rubyonrails.org/security.html#custom-credentials">Securing Rails Applications</a></li>
  <li><a href="https://dev.to/raaynaldo/the-power-of-rails-master-key-36fh">The power of Rails master.key</a></li>
  <li><a href="https://blog.kiprosh.com/rails-encrypted-credentials/">Manage Rails app secrets with Rails Encrypted Credentials</a></li>
  <li><a href="https://blog.saeloun.com/2019/10/10/rails-6-adds-support-for-multi-environment-credentials/">Rails 6 adds support for multi environment credentials</a></li>
  <li><a href="https://discuss.rubyonrails.org/t/rails-master-key-and-per-environment-init/82615">RAILS_MASTER_KEY and per-environment init</a></li>
  <li><a href="https://stackoverflow.com/questions/63642303/how-to-set-rails-production-key-config-var-on-a-rails-6-app-on-heroku">How to set RAILS_PRODUCTION_KEY config var on a Rails 6 app on Heroku</a></li>
  <li><a href="https://stackoverflow.com/questions/61279454/rails-6-heroku-devise-error-activesupportmessageencryptorinvalidmessage/66092950#66092950">Rails 6 Heroku Devise error ActiveSupport::MessageEncryptor::InvalidMessage</a></li>
  <li><a href="https://til.hashrocket.com/posts/8b8b4d00a3-generate-a-rails-secret-key">Generate a Rails Secret Key</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[A web application needs various kinds of values, params and etc which should not be revealed to the public, say GitHub repo. For example, API keys, tokens, passwords, and endpoints, all those should be kept secret. Another important factor is that such secrets should be shared among the team members. Additionally, all those secrets should come along with the deployment.]]></summary></entry><entry><title type="html">OAuth2 PKCE With Rails 7, React/Redux and esbuild</title><link href="http://localhost:4000/2023/06/05/oauth2-pkce-with-rails-7-react-redux-and-esbuild.html" rel="alternate" type="text/html" title="OAuth2 PKCE With Rails 7, React/Redux and esbuild" /><published>2023-06-05T22:47:00+09:00</published><updated>2023-06-05T22:47:00+09:00</updated><id>http://localhost:4000/2023/06/05/oauth2-pkce-with-rails-7-react-redux-and-esbuild</id><content type="html" xml:base="http://localhost:4000/2023/06/05/oauth2-pkce-with-rails-7-react-redux-and-esbuild.html"><![CDATA[<p>Logging in to a web site is what users do quite a lot.
Suppose it is a blog site.
Once a user completes a log-in process, the user is allowed to create a new post, update contents and delete a post.
The blog site might have a feature to leave comments by logged in users.</p>

<p>The login process is categorized roughly two types: use the login feature implemented in the web site or
the social login such as Twitter, GitHub, Google, etc.
For a Rails app, implementing a local login feature is not difficult since it can use an established gem called devise.
The Rails app has a choice to use a gem called OmniAuth for the social login
if the front-end is a legacy, server rendered app.</p>

<p>However, we see a lot of rich clients built by ReactJS, Angular, Vue.js or such.
The client app is, sometime, called SPA (Single-Page Application).
Such sort of client app initiates the login process itself.
The social login becomes complicated.
The problem of the social login by SPA is that the app ends up revealing a social login secret parameter.</p>

<p>The Authorization Code Flow, which is a commonly used grant type defined in OAuth2, uses the client id and client secret
provided by the authorization endpoint (Twitter, GitHub, Google, etc).
From a nature of JavaScript code, the client secret is mixed in to a bundled JavaScript code as is.
It might be minified, so very hard to find.
Even though, a reverse engineering would identify the client secret.</p>

<p>To solve such potentially risky issue, the Authorization Code Flow had an extension called Proof Key for Code Exchange.
In short, it is referred as PKCE (pronounced “pixy”).
The PKCE uses a code verifier and code challenge instead of the client secret on the client app side.
The code verifier is a randomly generated string,
while the code challenge is generated by a specified algorithm using the code verifier as a seed.
During multiple interactions with the authorization endpoint,
one of code challenge or code verifier is used in a single interaction.
The client secret is still used on the server app side.
However, the server app can easily protect such secret parameters.</p>

<p>This way, SPA can perform a secure social login.</p>

<h3 id="how-authorization-code-flow-with-proof-key-for-code-exchange-pkce-works">How Authorization Code Flow with Proof Key for Code Exchange (PKCE) Works</h3>

<p>The flow is complicated.
Multiple actors are involved in.
To make it clear, let’s start off from who are those actors.</p>

<h4 id="actors">Actors</h4>

<p>The actors involved in the PKCE are below:</p>

<ul>
  <li>User: human, who wants to be authenticated by a social login.</li>
  <li>SPA: client side app.</li>
  <li>Rails: server side app.</li>
  <li>Auth Endpoint: social login such as Twitter, GitHub, Google, etc.</li>
</ul>

<h4 id="pkce-flow">PKCE Flow</h4>

<p>With above actors, the PKCE flow in this example works like below:</p>

<ol>
  <li>SPA to User: show Login Button which is a link to social login with code challenge and client id</li>
  <li>User to Auth Endpoint: click the button</li>
  <li>Auth Endpoint to User: show the login page if the user is not logged in</li>
  <li>User to Auth Endpoint: input username (or email, phone number, etc) and password, then click a login button</li>
  <li>Auth Endpoint to User: show the Authorize app button with the information about Rails app</li>
  <li>User to Auth Endpoint: click the Authorize app button</li>
  <li>Auth Endpoint to Rails: redirect to Rails app with a code parameter</li>
  <li>Rails to Auth Endpoint: make a request to get an access token with the code parameter, code verifier, client id/secret</li>
  <li>Auth Endpoint to Rails: return the access token</li>
  <li>Rails to Auth Endpoint: make a request to get a user profile with the access token</li>
  <li>Rails to SPA: redirect to SPA’s page with the access token</li>
  <li>SPA to Rails: make a request to know who is the user with the access token</li>
  <li>Rails to SPA: return the user profile</li>
  <li>SPA to User: show the user profile</li>
</ol>

<h3 id="example-application">Example Application</h3>

<p>Versions:</p>
<ul>
  <li>Ruby: 3.2.2</li>
  <li>Rails: 7.0.5</li>
</ul>

<p>Source Code:</p>
<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild">https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild</a></li>
</ul>

<p>Since we learned the basic idea about PKCE, it’s time to implement.
For an example application, the client app is created by ReactJS (TypeScript), Redux Toolkit and Chakra UI.
The server side is created by Ruby on Rails with esbuild setup.</p>

<p>Although ReactJS and Rails have libraries for PKCE, the example app implements the flow from scratch.
It is a good way to understand how PKCE works.</p>

<blockquote>
  <p>For details about creating Rails and ReactJS apps with esbuild setting, please see the previous post:
<a href="/2023/05/23/rails-7-react-redux-development-with-esbuild.html">Rails 7 React/Redux Development with esbuild</a>.</p>
</blockquote>

<h4 id="setup-twitter-social-login">Setup Twitter Social Login</h4>

<p>The example app uses Twitter OAuth2 login.
Go to Twitter’s <a href="https://developer.twitter.com/en/portal/dashboard">Developer Portal</a> and create an app.
The Callback URI / Redirect URL should have “www” in the URL.
This example sets “http://www.localhost:3000/oauth/twitter” for the redirect URL.</p>

<h4 id="server-app">Server App</h4>

<p>The first step is to create Rails app.
Then, add the faraday gem to make HTTP request to the authorization endpoint.
Also, add the jwt gem to sign the access token with some more additional info.</p>

<pre><code class="language-bash">% rails new [APP NAME] -j esbuild -T
% cd [APP NAME]
% bundle add faraday
% bundle add jwt
</code></pre>

<p>Create a user model.</p>

<pre><code class="language-bash">% rails g model User username:string name:string provider:integer pid:string
% rails db:migrate
</code></pre>

<p>The provider here means how the user is authenticated.
It is an enum field, so the data type is integer.
The pid is an id returned from the authorization endpoint.
This example app treats username as a unique field, so it needs additional migration.</p>

<pre><code class="language-bash">% rails g migration add_index_to_users_username
</code></pre>

<p>Edit, db/migrate/[DATE TIME]_add_index_to_users_username.rb</p>
<pre><code class="language-ruby"># db/migrate/[DATE TIME]_add_index_to_users_username.rb

class AddIndexToUsersUsername &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :users, :username, unique: true
  end
end
</code></pre>
<p>Then, run</p>
<pre><code class="language-bash">% rails db:migrate
</code></pre>

<p>Edit, app/models/user.rb to define the provider enum type and add the username constraint of uniqueness.</p>
<pre><code class="language-ruby"># app/models/user.rb

class User &lt; ApplicationRecord
  enum provider: [:local, :twitter]

  validates :username, uniqueness: true
end
</code></pre>

<p>Coming to a controller part, the first one is to create an entry point for the client app.</p>

<pre><code class="language-bash">% rails g stimulus client
</code></pre>

<p>Create another controller to mount the client app.</p>

<pre><code class="language-bash">% rails g controller pages home
</code></pre>

<p>Edit app/views/pages/home.html.erb to add the div tag with id=root as the mount point.</p>
<pre><code class="language-erb">&lt;%# app/views/pages/home.html.erb %&gt;

&lt;h1&gt;Pages#home&lt;/h1&gt;
&lt;p&gt;Find me in app/views/pages/home.html.erb&lt;/p&gt;
&lt;%= content_tag(:div, "", id:"root", data:{ controller: "client" }) %&gt;
</code></pre>

<p>Edit config/routes.rb to make the pages#home to the root route.</p>
<pre><code class="language-ruby"># config/routes.rb

Rails.application.routes.draw do
  root 'pages#home'
end
</code></pre>

<p>Create a controller for the redirect URL.
The URL should be “http://www.localhost:3000/oauth/twitter” as it is set at Twitter Developer Portal.</p>
<pre><code class="language-bash">% rails g controller oauth twitter --skip-template-engine
</code></pre>

<p>The oauth controller will have a core logic explained in the PKCE Flow section.
Among the steps, the oauth controller does step from 7 to 11.
Let’s get back for the PKCE implementation later.</p>

<p>Lastly, create a controller for the me query.
The me query is used to fetch the profile of the currently authenticated user.</p>

<pre><code class="language-bash">% rails g controller me --skip-template-engine
</code></pre>

<p>The controller implementation will be discussed later, so for now, add profile method to create a route.</p>
<pre><code class="language-ruby"># app/controllers/me_controller.rb

class MeController &lt; ApplicationController
  def profile
  end
end
</code></pre>

<p>Edit config/routes.rb to create a path to the me query.</p>
<pre><code class="language-ruby"># config/routes.rb

Rails.application.routes.draw do
  get 'oauth/twitter'
  root 'pages#home'
  get 'me', action: :profile, controller: 'me'
end
</code></pre>

<h4 id="client-app">Client App</h4>

<p>The client app takes a typical Redux Toolkit directory structure described below:</p>

<pre><code class="language-bash">app/javascript
├── App.tsx
├── app
│   ├── hooks.ts
│   └── store.ts
├── application.js
├── controllers
│   ├── application.js
│   ├── client_controller.js
│   └── index.js
├── features
│   ├── auth
│   │   └── authSlice.ts
│   └── twitter
│       ├── TwitterLogin.tsx
│       ├── TwitterProfile.tsx
│       └── twitterSlice.ts
└── utils
    ├── hashUtils.ts
    └── twitterOauthConfig.ts

7 directories, 13 files
</code></pre>

<h5 id="environment-variable-setup">Environment Variable Setup</h5>

<p>This is a setup for environment variables for SPA.
In general, the dotenv is used for such purpose.
However, for SPA, the dotenv is quite hard stuff to setup also not meaningful.
Since the files for the app are bundled in a single JavaScript (and stylesheets),
it depends on the build tool how the dotenv is looked up.
Additionally, the content in dotenv will be hardcoded in the built JavaScript file.</p>

<p>For an alternative way, this example app uses settings.js file which is put in the directory where the Rails asset
pipeline sees.</p>

<p>Create app/assets/javascripts/settings.js and write your twitter app’s client id:</p>

<pre><code class="language-javascript">// app/assets/javascripts/settings.js

var environment = {
  "REACT_APP_TWITTER_CLIENT_ID": "YOUR-CLIENT-ID-HERE",
}
</code></pre>

<p>Add javascripts directory in app/assets/config/manifest.js as in the last line below:</p>
<pre><code class="language-javascript">//= link_tree ../images
//= link_directory ../stylesheets .css
//= link_tree ../builds
//= link_directory ../javascripts .js
</code></pre>

<p>Lastly, add javascript tag in app/views/layouts/application.html.erb.
The tag should come before application.js since the variables defined in settings.js will be referenced in application.js.</p>
<pre><code class="language-erb">&lt;%# app/views/layouts/application.html.erb %&gt;

...
&lt;head&gt;
    &lt;title&gt;TwitterOauthPkceExample&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt;
    &lt;%= csrf_meta_tags %&gt;
    &lt;%= csp_meta_tag %&gt;

    &lt;%= stylesheet_link_tag "application", "data-turbo-track": "reload" %&gt;
    &lt;%= javascript_include_tag "settings", "data-turbo-track": "reload", defer: true %&gt;
    &lt;%= javascript_include_tag "application", "data-turbo-track": "reload", defer: true %&gt;
  &lt;/head&gt;
...
</code></pre>

<h5 id="install-packages">Install Packages</h5>

<p>At Rails app’s root directory, run yarn add command to install packages.</p>

<pre><code class="language-bash">% yarn add react react-dom
% yarn add typescript @types/node @types/react @types/react-dom
% yarn add react-redux @reduxjs/toolkit
% yarn add @chakra-ui/react @emotion/react @emotion/styled framer-motion
</code></pre>

<h5 id="login-button">Login Button</h5>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/TwitterLogin.tsx">TwitterLogin.tsx</a></li>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/utils/twitterOauthConfig.ts">twitterOauthConfig.ts</a></li>
</ul>

<p>The first step of the PKCE is to show the login button which has a link to the authorization endpoint with necessary info.</p>
<pre><code class="language-typescript">// app/javascript/features/twitter/TwitterLogin.tsx

...
return (
  &lt;VStack spacing="4"&gt;
    {!isLoggedIn &amp;&amp;
      &lt;Button
        colorScheme='blue'
        aria-label="Log in using OAuth 2.0"
        onClick={() =&gt; window.open(getTwitterOauthUrl(), '_self')}
      &gt;
        Log in with Twitter
      &lt;/Button&gt;
    }
    {isLoggedIn &amp;&amp;
      &lt;Text&gt;
        Token expiry date: {tokenExpiryDate}
      &lt;/Text&gt;
    }
  &lt;/VStack&gt;
);
...
</code></pre>

<p>The link url is created in the function defined in twitterOauthConfig.ts.
The code challenge is hardcoded in this example app.
In the real world, it should be generated by a specified algorithm.</p>
<pre><code class="language-typescript">// app/javascript/utils/twitterOauthConfig.ts

const authEndpoint = 'https://twitter.com/i/oauth2/authorize';

const client_id = environment.REACT_APP_TWITTER_CLIENT_ID;
const redirect_uri = "http://www.localhost:3000/oauth/twitter";

export const getTwitterOauthUrl = (): string =&gt; {
  // temporarily uses static code verifier and challenge
  let code_challenge = "WeI7ul0uzUr0Zv89EPknzv4iNqmQuEysEtkWan7P3FA";
  let state = "state";
  let scope = ["users.read", "tweet.read", "follows.read", "follows.write"].join(" ");
  // @ts-ignore
  let args = new URLSearchParams({
    redirect_uri,
    client_id,
    state,
    response_type: 'code',
    code_challenge,
    code_challenge_method: "S256",
    scope,
  }).toString();
  return `${authEndpoint}?${args}`;
}
</code></pre>

<p>The button looks like below:</p>

<p><img src="http://localhost:4000/assets/img/oauth-pkce-login-button.jpeg" alt="img: oauth pkce login button" /></p>

<p>When a user (human) clicks the button, Twitter navigates to the login page if the user has not yet logged in.
If the user is already logged in, this step is skipped.</p>

<p><img src="http://localhost:4000/assets/img/oauth-pkce-twitter-login-page.jpeg" alt="img: oauth pkce twitter login page" /></p>

<p>After the successful login, Twitter shows the authorize app page.</p>

<p><img src="http://localhost:4000/assets/img/oauth-pkce-twitter-authorize-app-page.jpeg" alt="img: oauth pkce twitter authorize app page" /></p>

<p>When the user clicks the Authorize app button, Twitter redirects to the given redirect URI with the code as the URL parameter.</p>

<p>Up here, PKCE flow’s 1 to 6 steps are completed.</p>

<h5 id="user-profile">User Profile</h5>

<p>Let’s assume the server side app successfully gets the access token and the user profile from Twitter.
What the server app does at this point is to redirect back to the client app.
The example here sends back access_token and token expiry as URL parameters.
Those parameters are handled by TwitterLogin.tsx and hashUtils.ts.</p>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/TwitterLogin.tsx">TwitterLogin.tsx</a></li>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/utils/hashUtils.ts">hashUtils.ts</a></li>
</ul>

<pre><code class="language-typescript">// app/javascript/features/twitter/TwitterLogin.tsx
...
const { access_token, expires_in } = getOAuthParams();
removeHashParamsFromUrl();
...
useEffect(() =&gt; {
  if (access_token) {
    dispatch(setLoggedIn(true));
    dispatch(setAccessToken(access_token));
    dispatch(setTokenExpiryDate(Number(expires_in)));
    dispatch(setUserProfileAsync(access_token));
  }
}, [])
...
</code></pre>
<pre><code class="language-typescript">// app/javascript/utils/hashUtils.ts
export const getOAuthParams = () =&gt; {
  const urlParams = new URLSearchParams(window.location.search);
  return {
    access_token: urlParams.get('access_token'),
    expires_in: urlParams.get('expires_in'),
  };
}

export const removeHashParamsFromUrl = () =&gt; {
  window.history.pushState("", document.title, window.location.pathname);
}
</code></pre>

<p>The last line in useEffect function, <code>dispatch(setUserProfileAsync(access_token));</code>, triggers the me query.
The function is defined in twitterSlice.ts.</p>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/twitterSlice.ts">twitterSlice.ts</a></li>
</ul>

<pre><code class="language-typescript">// app/javascript/features/twitter/twitterSlice.ts
...
export const setUserProfileAsync = (accessToken: string): AppThunk =&gt; dispatch =&gt; {
  fetch('http://www.localhost:3000/me', {
    method: 'GET',
    headers: {
      Authorization: 'Bearer ' + accessToken,
    },
  }).then(response =&gt; response.json())
    .then((data) =&gt; {
      dispatch(setLoggedIn(true));
      dispatch(setName(data.name ? data.name : data.id));
      dispatch(setUsername(data.username));
    }).catch((error) =&gt; {
    console.log(error);
    if (error instanceof XMLHttpRequest) {
      if (error.status === 401) {
        dispatch(setLoggedIn(false));
      }
    }
  });
};
...
</code></pre>

<p>The client app returns the access token as is in the Authorization header.
This is the step 12 of the PKCE flow.
When the server app returns the user profile, that will be rendered in TwitterProfile.tsx.
By that, the last step, 14, of the PKCE flow completes.</p>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/TwitterProfile.tsx">TwitterProfile.tsx</a></li>
</ul>

<pre><code class="language-typescript">// app/javascript/features/twitter/TwitterProfile.tsx

...
export function TwitterProfile() {
  const name = useSelector(selectName);
  const username = useSelector(selectUsername);

  return (
    &lt;VStack&gt;
      {name &amp;&amp;
        &lt;Box&gt;
          &lt;Text&gt;Logged in as: {name}&lt;/Text&gt;
        &lt;/Box&gt;}
      {username &amp;&amp;
        &lt;Box&gt;
          &lt;Text&gt;Username: {username}&lt;/Text&gt;
        &lt;/Box&gt;
      }
      &lt;/VStack&gt;
  );
}
...
</code></pre>

<p><img src="http://localhost:4000/assets/img/oauth-pkce-user-profile.jpeg" alt="img: oauth pkce user profile" /></p>

<h4 id="core-logic-on-the-server-side-app">Core Logic on the Server Side App</h4>

<h5 id="setup-secrets">Setup Secrets</h5>

<p>The controllers needs some secret parameters.
Before going to the controller details, setup those parameters.
Choose your favorite editor, for example, EDITOR=”code –wait”.
The vim is the choice here.</p>

<pre><code class="language-bash">% EDITOR=vim rails credentials:edit
</code></pre>

<p>Write your JWT secret, Twitter app’s client id and client secret in the format below:</p>

<pre><code class="language-yml">jwt_secret: YOUR-JWT-SECRET-HERE
twitter:
  client_id: YOUR-TWITTER-APP-CLIENT-ID-HERE
  client_secret: YOUR-TWITTER-APP-CLIENT-SECRET-HERE
</code></pre>

<h5 id="oauthcontroller-details">OauthController Details</h5>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/controllers/oauth_controller.rb">oauth_controller.rb</a></li>
</ul>

<p>The OauthController performs the PKCE flow’s step from 7 to 11.
The authentication request made by the client app ends up coming to the redirect uri,
http://www.localhost:3000/oauth/twitter with the code as a URL parameter.
The controller gets the code, then makes a request to the Twitter access token endpoint with the code and other parameters.</p>

<pre><code class="language-ruby">// app/controllers/oauth_controller.rb

...
    def twitter
        client_id = Rails.application.credentials.twitter.client_id.strip
        client_secret = Rails.application.credentials.twitter.client_secret.strip
        oauthTokenParams = {
          redirect_uri: 'http://www.localhost:3000/oauth/twitter',
          code: params[:code]
        }
        access_token, expires_in = getOAuthToken("https://api.twitter.com", "/2/oauth2/token",
                                                 client_id, client_secret,
                                                 oauthTokenParams) 
        ...
    end
...
    def getBasicAuthToken(client_id, client_secret)
      Base64.strict_encode64("#{client_id}:#{client_secret}")
    end

    def getOAuthToken(url, path, client_id, client_secret, oauth_token_params)
      oauth_token_params = oauth_token_params.merge({
                                                      grant_type: 'authorization_code',
                                                      client_id: client_id,
                                                      code_verifier: CODE_VERIFIER
                                                    }))
      conn = Faraday.new(
        url: url,
        headers: {
          'Content-Type' =&gt; 'application/x-www-form-urlencoded',
          'Authorization' =&gt; "Basic #{getBasicAuthToken(client_id, client_secret)}"
        }
      )
      response = conn.post(path, URI.encode_www_form(oauth_token_params))
      body_obj = JSON.parse(response.body)
      [body_obj['access_token'], body_obj['expires_in']]
    end
...
</code></pre>

<p>Once the access token is successfully returned from Twitter, the next step is to get a user profile.
The me query to Twitter does the job.
The access token is set in the Authorization header to make the me query.</p>

<pre><code class="language-ruby">// app/controllers/oauth_controller.rb

def twitter
    ...
    data = getUser("https://api.twitter.com", "/2/users/me", access_token)
    ...
end
...
def getUser(url, path, access_token)
    conn = Faraday.new(
      url: url,
      headers: {
        'Content-Type' =&gt; 'application/x-www-form-urlencoded',
        'Authorization' =&gt; "Bearer #{access_token}"
      }
    )
    response = conn.get(path)
    body_obj = JSON.parse(response.body)
    body_obj['data']
end
...
</code></pre>

<p>After the server side app gets the user profile, the user is either created on or retrieved from a local database.</p>

<pre><code class="language-ruby">// app/controllers/oauth_controller.rb

def twitter
  ...
  user = getUserFromDb(
    {
      username: data['username'],
      name: data['name'],
      provider: User.providers[:twitter],
      pid: data['id']
    }
  )
  ...
end
</code></pre>

<p>Almost there.
The following step is to sign access token and user info.
This example app uses user’s username and name with the access token.</p>

<pre><code class="language-ruby">// app/controllers/oauth_controller.rb

def twitter
  ...
  signedToken = getSignedToken(access_token, user)
  ...
end
...
def getSignedToken(access_token, user)
  JWT.encode(
    {
      username: user.username,
      provider: user.provider,
      accessToken: access_token
    },
    Rails.application.credentials.jwt_secret,
    'HS256'
  )
end
</code></pre>

<p>Finally, the controller redirects back to the client app with the signed access token and token’s expiry.</p>

<pre><code class="language-ruby">// app/controllers/oauth_controller.rb

def twitter
  ...
  redirect_to(root_path(access_token: signedToken, expires_in: expires_in))
end
</code></pre>

<h5 id="mecontroller-details">MeController Details</h5>

<ul>
  <li><a href="https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/controllers/me_controller.rb">me_controller.rb</a></li>
</ul>

<p>The MeController gets signed access token from the Authorization header which is sent back by the client app.
Then, the token is decoded using the same JWT secret.
The decoded token has the user info which can be verified to make a query to the local database.
The result of the database query is returned to the client app.</p>

<p>The example app skips the access token validity check since it focuses on the PKCE flow only.
However, in a real situation, the access token should be checked.</p>

<pre><code class="language-ruby">// app/controllers/me_controller.rb

...
class MeController &lt; ApplicationController
  def profile
    payload = decodeSignedJwtToken(getBearerToken()).first
    user = User.where(provider: payload["provider"], username: payload["username"]).first
    render json: user
  end

  def getBearerToken
    pattern = /^Bearer /
    request.authorization.gsub(pattern, '') if request.authorization
  end

  def decodeSignedJwtToken(token)
    JWT.decode(
      token,
      Rails.application.credentials.jwt_secret,
      true,
      { algorithm: 'HS256' }
    )
  end
end
</code></pre>

<h3 id="conclusion">Conclusion</h3>

<p>The example app’s purpose is to show how PKCE flow works.
So, some parts are missing.
For example, the code verifier and code challenge should be generated in each authentication process, but not.
The access token should be saved in both client and server apps and re-requested when the token is expired.
The example app skips that as well.</p>

<p>Even though, the example app would help to understand how the PKCE flow works between React app, Rails app and
Authorization endpoint.</p>

<h3 id="references">References</h3>
<h4 id="proof-key-for-code-exchange">Proof Key for Code Exchange</h4>
<ul>
  <li><a href="https://oauth.net/2/pkce/">RFC 7636: Proof Key for Code Exchange</a></li>
  <li><a href="https://blog.miniorange.com/auth-flow-with-pkce/">Authorization Code Flow with Proof Key for Code Exchange (PKCE)</a></li>
  <li><a href="https://hceris.com/oauth-authorization-code-flow-pkce-for-react/">Authorization Code Flow with PKCE (OAuth) in a React application</a></li>
  <li><a href="https://developer.twitter.com/en/docs/authentication/oauth-2-0/authorization-code">Twitter Documentation: Authentication</a></li>
  <li><a href="https://developer.spotify.com/documentation/web-api/tutorials/code-pkce-flow">Spotify for Developers: Authorization Code with PKCE Flow</a></li>
</ul>

<h4 id="implementation">Implementation</h4>
<ul>
  <li><a href="https://dev.to/reinforz/implementing-authentication-with-twitter-oauth-20-using-typescript-node-js-express-js-and-next-js-in-a-full-stack-application-353d">Implementing Authentication with Twitter OAuth 2.0 using Typescript, Express.js and Next.js</a></li>
  <li><a href="https://medium.com/swlh/create-a-react-app-with-typescript-redux-and-oauth-2-0-7f62d57890df">Create a React App with TS, Redux and OAuth 2.0 - Spotify login example</a></li>
  <li><a href="https://dev.to/sbelzile/stop-using-dotenv-in-your-front-end-427p">Stop using Dotenv in your front-end</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[Logging in to a web site is what users do quite a lot. Suppose it is a blog site. Once a user completes a log-in process, the user is allowed to create a new post, update contents and delete a post. The blog site might have a feature to leave comments by logged in users.]]></summary></entry><entry><title type="html">Rails 7 React/Redux Development with esbuild</title><link href="http://localhost:4000/2023/05/23/rails-7-react-redux-development-with-esbuild.html" rel="alternate" type="text/html" title="Rails 7 React/Redux Development with esbuild" /><published>2023-05-23T21:47:00+09:00</published><updated>2023-05-23T21:47:00+09:00</updated><id>http://localhost:4000/2023/05/23/rails-7-react-redux-development-with-esbuild</id><content type="html" xml:base="http://localhost:4000/2023/05/23/rails-7-react-redux-development-with-esbuild.html"><![CDATA[<p>Rails 7 provides a couple of approaches to bundle a rich JavaScript application such as SPA.
To create the JavaScript application, we should specify <code>j|--javascript</code> option with
importmap (default), webpack, esbuild or rollup when <code>rails new</code> command gets run.
Although webpack is still among the choices, it has been retired as describe in the
<a href="https://github.com/rails/webpacker/blob/master/README.md">https://github.com/rails/webpacker/blob/master/README.md</a>.
The choice here is <a href="https://esbuild.github.io/">esbuild</a> since it is friendly to JavaScript development,
for example, starting from <code>yarn create react-app ...</code>.
The esbuild is gaining popularity and known to run very fast with its Go-lang implementation.</p>

<p>This blog post creates React/Redux application on top of Rails 7.
The application is a sample counter app which comes from what <code>yarn create react-app [app name] --template redux-typescript</code>
command creates.</p>

<h3 id="create-a-rails-app-with-esbuild-option">Create a Rails App with esbuild Option</h3>

<p>The command to create an app is something like:</p>

<pre><code class="language-bash">% rails new [APP NAME] -j esbuild -T
</code></pre>

<p>The <code>-j esbuild</code> option installs frontend development packages/tools.
Additionally, the command, <code>./bin/rails javascript:install:esbuild</code>, gets run during the app creation.
The package.json, Procfile.dev and couple other files for JavaScript development are also created.</p>

<h3 id="create-an-entry-point-for-reactjs-app">Create an Entry Point for ReactJS App</h3>

<p>The next step is to create and entry point for ReactJS app.
All incoming HTTP requests are received by controllers on Rails.
Following such Rails style, the entry point to ReactJS app is also a controller.
However, instead of <code>rails g controller ...</code>, stimulus generator is used for this.
The generated controller is a JavaScript class, which is a subclass of stimulus Controller.</p>

<pre><code class="language-bash">% rails g stimulus react
</code></pre>

<p>Above generates <code>app/javascript/controllers/react_controller.js</code> and updates <code>app/javascript/controllers/index.js</code>.
The generated controller class is equivalent to ReactJS app’s index.tsx(jsx).
What we write in index.tsx should go to a connect method in the generated controller class.</p>

<h3 id="create-a-view-to-mount-reactjs-app">Create a View to Mount ReactJS App</h3>

<p>If the ReactJS app is created by <code>yarn create react-app ...</code> or npm, npx command,
the app has a mount point in <code>public/index.html</code>, something like: <code>&lt;div id="root"&gt;&lt;/div&gt;</code>.
It is Rails, so we should create a controller.</p>

<pre><code class="language-bash">% rails g controller pages home
</code></pre>

<p>Above creates a couple of files as we know.
Edit <code>app/views/pages/home.html.erb</code> and add the mount point.</p>

<pre><code class="language-erbruby">&lt;%# app/views/pages/home.html.erb %&gt;

&lt;h1&gt;Pages#home&lt;/h1&gt;
&lt;p&gt;Find me in app/views/pages/home.html.erb&lt;/p&gt;
&lt;%= content_tag(:div, "", id:"root", data:{ controller: "react" }) %&gt;
</code></pre>

<p>Also, edit <code>config/routes.rb</code> to add a path to pages#home.</p>

<pre><code class="language-ruby"># config/routes.rb

Rails.application.routes.draw do
  root 'pages#home'
end
</code></pre>

<h3 id="setup-basic-react-typescript-app">Setup Basic React TypeScript App</h3>

<p>At this moment, the Rails side is ready.
However, the JavaScript side has a package.json file only, which is like right after <code>yarn --init</code> ran.
Since it is a React TypeScript app, install basic packages.</p>

<pre><code class="language-bash">% yarn add react react-dom @types/react @types/react-dom typescript
</code></pre>

<p>Also, TypeScript initialization should be done.</p>

<pre><code class="language-bash">% tsc --init --project tsconfig.json --noEmit --jsx react-jsx
</code></pre>

<h3 id="redux-toolkit-counter-example">Redux Toolkit Counter Example</h3>

<p>When the redux-typescript template is used to create a ReactJS App, the counter example comes with it.
For examples, <code>yarn create react-app my-app --template redux-typescript</code> command creates files below
(excludes node_modules directory):</p>
<pre><code>.
├── README.md
├── package.json
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
├── src
│   ├── App.css
│   ├── App.test.tsx
│   ├── App.tsx
│   ├── app
│   │   ├── hooks.ts
│   │   └── store.ts
│   ├── features
│   │   └── counter
│   │       ├── Counter.module.css
│   │       ├── Counter.tsx
│   │       ├── counterAPI.ts
│   │       ├── counterSlice.spec.ts
│   │       └── counterSlice.ts
│   ├── index.css
│   ├── index.tsx
│   ├── logo.svg
│   ├── react-app-env.d.ts
│   ├── reportWebVitals.ts
│   └── setupTests.ts
├── tsconfig.json
└── yarn.lock
</code></pre>

<p>We want files under src directory.
How to map those files under <code>app/javascript</code> might be controversy.
Some might create a components directory.
However, as for Redux Toolkit, features and/or app directories are more common.</p>

<p>The app here is created by copying files under <code>src</code> to <code>app/javascript</code> almost as those are.</p>

<pre><code class="language-bash">app/javascript
├── App.tsx
├── app
│   ├── hooks.ts
│   └── store.ts
├── application.js
├── controllers
│   ├── application.js
│   ├── hello_controller.js
│   ├── index.js
│   └── react_controller.js
├── features
│   └── counter
│       ├── Counter.module.css
│       ├── Counter.tsx
│       ├── counterAPI.ts
│       ├── counterSlice.spec.ts
│       └── counterSlice.ts
└── logo.svg
</code></pre>

<p>Handling of .css files will be mentioned later since that needs a bit of fix.</p>

<p>To run the counter app, Redux Toolkit and react binding packages should be installed.</p>
<pre><code class="language-bash">% yarn add @reduxjs/toolkit react-redux
</code></pre>

<h3 id="update-react_controllerjs">Update react_controller.js</h3>

<p>Previously mentioned, <code>app/javascript/controllers/react_controller.js</code> is equivalent to ReactJS app’s index.tsx.</p>

<p>The file looks like below to run the counter app.</p>

<pre><code class="language-tsx">// app/javascript/controllers/react_controller.js

import { Controller } from "@hotwired/stimulus"
import React from 'react';
import { createRoot } from 'react-dom/client';
import { Provider } from "react-redux";
import App from '../App';
import { store } from '../app/store';

// Connects to data-controller="react"
export default class extends Controller {
  connect() {
    const container = document.getElementById('root');
    const root = createRoot(container);

    root.render(
      &lt;React.StrictMode&gt;
        &lt;Provider store={store}&gt;
          &lt;App /&gt;
        &lt;/Provider&gt;
      &lt;/React.StrictMode&gt;
    );
  }
}
</code></pre>

<h3 id="update-packagejson-scripts-section">Update package.json scripts section</h3>

<p>When the Rails app is created, package.json’s scripts section looks like below.</p>

<pre><code>"scripts": {
  "build": "esbuild app/javascript/*.* --bundle --sourcemap --outdir=app/assets/builds --public-path=assets"
}
</code></pre>

<p>As in the above directory tree, the counter app has .tsx and .svg files under app/javascript.
So that esbuild can load those, two loaders should be added to the esbuild option.</p>

<p>Additionally, the script section should have TypeScript check.</p>

<p>After the update, the script section looks like below:</p>
<pre><code>"scripts": {
  "build": "esbuild app/javascript/*.* --bundle --sourcemap --outdir=app/assets/builds --public-path=assets --loader:.js=jsx --loader:.svg=file",
  "check-types": "tsc --project tsconfig.json --noEmit --watch --preserveWatchOutput"
}
</code></pre>

<h3 id="avoid-sprocketsdoublelinkerror-applicationcss-error">Avoid Sprockets::DoubleLinkError application.css Error</h3>

<p>If esbuild is used in a Rails app, .css files need extra caution.
We might end up in having two application.css files generated by esbuild and originally created by <code>rails new</code> command.
If that happens, the conflict raises the Sprockets::DoubleLinkError application.css error.</p>

<p>When a .tsx(.jsx) file imports CSS, esbuild generates app/assets/builds/application.css.
Whereas we have app/assets/stylesheets/application.css generated by rails new command.
These two application.css files have the same name but different contents.</p>

<p>A couple to few ways would be there to avoid the error.
Probably, below two are easy ones.</p>

<ol>
  <li>Never ever import css files in .tsx(.jsx).
Instead, write all styles in <code>app/assets/stylesheets/application.css</code> or take a traditional Rails way.</li>
  <li>Rename <code>app/assets/stylesheets/application.css</code>.</li>
</ol>

<p>The app here mainly took the second approach, but partially the first approach.
The <code>app/assets/stylesheets/application.css</code> was renamed to <code>app/assets/stylesheets/application-rails.css</code>.
The <code>app/views/layouts/application.html.erb</code> file got one more stylesheet_link_tag shown below:</p>

<pre><code class="language-erbruby">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;React/Redux App&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt;
    &lt;%= favicon_link_tag 'favicon.ico' %&gt;
    &lt;%= csrf_meta_tags %&gt;
    &lt;%= csp_meta_tag %&gt;

    &lt;%= stylesheet_link_tag "application", "data-turbo-track": "reload" %&gt;
    &lt;%= stylesheet_link_tag "application-rails", "data-turbo-track": "reload" %&gt;
    &lt;%= javascript_include_tag "application", "data-turbo-track": "reload", defer: true %&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;%= yield %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>All styles in <code>index.css</code> and <code>App.css</code> are moved to <code>app/assets/stylesheets/application-rails.css</code>.
The css import was removed from <code>App.tsx</code> and <code>app/javascript/controllers/react_controller.js</code>.
However, <code>app/javascript/features/counter/Counter.module.css</code> is there, which is imported in
<code>app/javascript/features/counter/Counter.tsx</code>.</p>

<h3 id="use-bindev-not-rails-s">Use bin/dev, not rails s</h3>

<p>To run the Rails app, use <code>bin/dev</code>.
As defined in <code>Procfile.dev</code>, we need Rails server and esbuild with watch option.
The <code>bin/dev</code> command does that.
If everything goes well, the counter app below shows up at http://localhost:3000/ .</p>

<p><img src="http://localhost:4000/assets/img/react-redux-counter-app.jpeg" alt="img: react redux counter app" /></p>

<h3 id="code">Code</h3>

<p>The example Rails app code is on the GitHub repo.
Please see <a href="https://github.com/yokolet/rails7-typescript-redux-counter-example">https://github.com/yokolet/rails7-typescript-redux-counter-example</a></p>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[Rails 7 provides a couple of approaches to bundle a rich JavaScript application such as SPA. To create the JavaScript application, we should specify j|--javascript option with importmap (default), webpack, esbuild or rollup when rails new command gets run. Although webpack is still among the choices, it has been retired as describe in the https://github.com/rails/webpacker/blob/master/README.md. The choice here is esbuild since it is friendly to JavaScript development, for example, starting from yarn create react-app .... The esbuild is gaining popularity and known to run very fast with its Go-lang implementation.]]></summary></entry><entry><title type="html">Make it Secure 3, CSRF for GraphQL on Rails</title><link href="http://localhost:4000/2023/03/29/make-it-secure-3-csrf-for-graphql-on-rails.html" rel="alternate" type="text/html" title="Make it Secure 3, CSRF for GraphQL on Rails" /><published>2023-03-29T23:39:00+09:00</published><updated>2023-03-29T23:39:00+09:00</updated><id>http://localhost:4000/2023/03/29/make-it-secure-3-csrf-for-graphql-on-rails</id><content type="html" xml:base="http://localhost:4000/2023/03/29/make-it-secure-3-csrf-for-graphql-on-rails.html"><![CDATA[<p>This is the third post about securing Rails GraphQL API app.
The topic is CSRF protection for GraphQL API.
CSRF is an acronym of <a href="https://owasp.org/www-community/attacks/csrf">Cross-Site Request Forgery</a>,
and one of well-known vulnerabilities and a type of session hijack.</p>

<p>If an attacker succeeds to hijack session, the request from the attacker looks a proper one from a victim.
The attacker is able to execute state changing operations using victim’s identity.</p>

<p>According to the document, <a href="https://guides.rubyonrails.org/security.html">Securing Rails Applications</a>:</p>
<blockquote>
  <p>CSRF appears very rarely in CVE (Common Vulnerabilities and Exposures) - less than 0.1% in 2006 - but it really is
a ‘sleeping giant’ [Grossman]. This is in stark contrast to the results in many security contract works - CSRF is
an important security issue.</p>
</blockquote>

<p>Above being said, we should think about CSRF protection.</p>

<h4 id="graphql-needs-csrf-protection">GraphQL needs CSRF protection?</h4>

<p>OK, we had a basic idea of CSRF attack.
Then, the question is whether GraphQL API needs CSRF protection or not.
If it is truly API only app, the app doesn’t use a cookie nor session at all.
There should be no session to be hijacked…
Well, developers might have a vague belief that there should be no session skipping actual HTTP response headers checks.</p>

<p>Some GraphQL clients, such as GraphiQL, don’t handle HTTP request/response headers well.
People might miss what are passed in HTTP response headers.
In contract, Insomnia (<a href="https://insomnia.rest/">https://insomnia.rest/</a>) or Postman (<a href="https://www.postman.com/">https://www.postman.com/</a>)
does a good job.
Postman’s handling is awesome.
By default, Postman adds meaningful HTTP response headers to HTTP request header automatically.
Besides, those are controllable. We can choose what should be sent back with GraphQL request.
Postman is famous for REST API client, however, GraphQL support is also good.</p>

<p>Once we check HTTP response headers returned with GraphQL query result, cookie and/or session might be found.
For example, the previous post, <a href="/2023/03/23/make-it-secure-2-graphql-by-rails-and-devise.html">Make it Secure 2, GraphQL by Rails and Devise</a>
uses Devise for authentication.
To make it work, cookie and session setup was added to <code>config/application.rb</code> since Devise needs that.
The Rails app was created with <code>--api</code> option, so the addition of cookie and session was done manually.
We knew that GraphQL response would come back with the session.
If GraphQL API app is created without <code>--api</code> option, the cookie and sessions might come back with GraphQL response unknowingly.
The blog post, <a href="https://checkmarx.com/blog/whats-old-becomes-new-again-csrf-attacks-on-graphql-apis/">What’s Old Becomes New Again: CSRF Attacks on GraphQL APIs</a>,
mentions “misconfiguration,” which would include the case of “unknowingly.”</p>

<p>The answer to the question, GraphQL needs CSRF protection?, depends on what gems are used.</p>

<h4 id="csrf-protection-setup-for-graphql">CSRF Protection Setup for GraphQL</h4>

<p>Rails provides CSRF protection out of the box, however, it is based on traditional web application.
The meta tag is used to embed CSRF token.
It uses flash UI when the session nullify option is used.
API only, GraphQL app needs tweaks to make it work.</p>

<h5 id="how-rails-csrf-protection-works">How Rails CSRF Protection Works</h5>

<p>Before moving on to the code, let’s revisit how traditional Rails app does for CSRF protection.</p>

<ol>
  <li>Rails app creates CSRF token</li>
  <li>Rails app ties the CSRF token to a session</li>
  <li>Rails app passes the CSRF token to a client using HTML meta tag with the session</li>
  <li>A client sends back the CSRF token using X-CSRF-TOKEN HTTP request header with the session</li>
  <li>Rails app compares the CSRF token returned as X-CSRF-TOKEN and tokens in the session</li>
  <li>Rails app does what protect_from_forgery specifies if the token is failed to verify</li>
</ol>

<p>Among the steps above, API only app should do something else for step 3 and 6.
In general, the cookie is used to return a pair of CSRF-TOKEN as key and the token as value.
Using the cookie might be controversial in terms of better security.
Another way is to return the token as a part of GraphQL login/register mutation response body.
This might be better than the cookie, however, other queries and mutations lose a chance to get updated token.
It is recommended that the CSRF token should be updated in every interaction to the server.
Given that, using cookie would be an agreeable solution.</p>

<p>When the CSRF token verification fails, three below protect_from_forgery strategies are possible behaviors.</p>
<ul>
  <li><code>:exception</code> – Raises ActionController::InvalidAuthenticityToken exception, which is captured in the GraphQL response body.</li>
  <li><code>:reset_session</code> – Resets the session. New token will be created and returned to the client.</li>
  <li><code>:null_session</code> – Provides an empty session during request. The cookies/sessions added by Devise are also deleted.</li>
</ul>

<p>Not like REST API, GraphQL always uses HTTP POST method by design.
The HTTP methods is useless to control the protect_from_forgery strategies, so we should add a custom strategy.</p>

<h4 id="graphql-rails-app">GraphQL Rails app</h4>

<p>The CSRF protection will be added to the previously created mini-blog-2 app.
How to create the app is explained in
<a href="/2023/03/23/make-it-secure-2-graphql-by-rails-and-devise.html">Make it Secure 2, GraphQL by Rails and Devise</a>.
The code is at <a href="https://github.com/yokolet/mini-blog-2">https://github.com/yokolet/mini-blog-2</a>.</p>

<p>The app uses Devise gem for a user authentication.</p>

<h4 id="update-for-null-session-strategy">Update for null session strategy</h4>

<p>This is to fix a flash error caused by no UI, API only setting.
This GraphQL app doesn’t use null_session strategy, but it’s good to have the update below for a future change.</p>

<p>Add config.middleware.use ActionDispatch::Flash in config/application.rb.
The three lines for cookie and session were added when Devise authentication was set up.
The cookie and session are used for CSRF protection as well, so leave those lines as are.</p>

<pre><code class="language-ruby"># config/application.rb
# ...
# ...
module MiniBlog2
  class Application &lt; Rails::Application
    # ...
    # ...
    config.session_store :cookie_store, key: "_mini-blog-2_session_#{Rails.env}"
    config.middleware.use ActionDispatch::Cookies
    config.middleware.use config.session_store, config.session_options

    # when protect_from_forgery with: :null_session is used, add blow.
    config.middleware.use ActionDispatch::Flash
  end
end
</code></pre>

<h4 id="add-method-to-create-and-set-csrf-token">Add method to create and set CSRF token</h4>

<p>As mentioned above, the CSRF token will be added to cookie.
Add set_csrf_token method in ApplicationController.
Since the Rails app is configured API only, two modules are included to use cookie and form_authenticity_token method.
The form_authenticity_token method generates a token and ties it to the session.</p>

<pre><code class="language-ruby"># app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::API
  include GraphqlDevise::SetUserByToken
  include ActionController::Cookies
  include ActionController::RequestForgeryProtection

  protected
  
  def set_csrf_token
    cookies['CSRF-TOKEN'] = form_authenticity_token
  end
end
</code></pre>

<h4 id="implement-custom-protect_from_forgery-strategy">Implement Custom protect_from_forgery Strategy</h4>

<p>By the nature of GraphQL API, it’s very hard to choose protect_from_forgery strategies depending on queries and mutations.
For that reason, a custom strategy class is added here.
The strategy plan is:</p>
<ul>
  <li>userLogin and userRegister mutations don’t need CSRF token verification, but want the token for later queries. Use reset_session.</li>
  <li>users and posts queries, createPost mutation do CSRF token verification. Use exception.</li>
</ul>

<p>Something extra is that schema fetching query is issued very often while using the GraphQL client such as Insomnia or Postman.
Absolutely, that doesn’t need CSRF token verification.
We should consider such query exists to implement the custom strategy.</p>

<p>The below implementation parses GraphQL query and gets query/mutation names defined in the schema.
The implementation is primitive and doesn’t support multiple or nested queries done in a single HTTP request.
Assuming only one query comes in, it finds the name of a query or mutation.</p>

<pre><code class="language-ruby"># app/controllers/concerns/mini_blog_strategy.rb
class MiniBlogStrategy
  def initialize(controller)
    @controller = controller
  end

  def handle_unverified_request
    query_string = JSON.parse(@controller.request.body.string)["query"]
    operationName = GraphQL.parse(query_string).definitions[0].selections[0].name
    if %(users posts postCreate).include?(operationName)
      exception.handle_unverified_request
    else
      reset_session.handle_unverified_request
    end
  end

  private

  def reset_session
    ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession.new(@controller)
  end

  def exception
    ActionController::RequestForgeryProtection::ProtectionMethods::Exception.new(@controller)
  end
end
</code></pre>

<h4 id="update-graphql_controller">Update graphql_controller</h4>

<p>The last piece is a GraphqlController update.
It’s simple. Just add set_csrf_token method and the custom strategy.</p>

<pre><code class="language-ruby"># app/controllers/graphql_controller.rb
class GraphqlController &lt; ApplicationController
  # If accessing from outside this domain, nullify the session
  # This allows for outside API access while preventing CSRF attacks,
  # but you'll have to authenticate your user separately
  # protect_from_forgery with: :null_session
  protect_from_forgery with: MiniBlogStrategy
  after_action :set_csrf_token

  def execute
    # ...
  end

  # ...
  # ...
end
</code></pre>

<h4 id="try-csrf-protection">Try CSRF Protection</h4>

<p>All are ready. Let’s see CSRF Protection is working.
The GraphQL client used here is Postman since its HTTP request/response header handling is great.</p>

<p>The first step is the userLogin mutation.
Open Postman, then:</p>
<ul>
  <li>select POST for HTTP method</li>
  <li>input http://localhost:3000/graphql</li>
  <li>select Body</li>
  <li>select GraphQL</li>
</ul>

<p>Right after GraphQL is selected, Postman makes a schema fetch query.
As in the image below, “Schema Fetched” status appears.</p>

<p>What happened behind the scene?
The GraphQL request comes to GraphQLController.
Sine the HTTP request header doesn’t include x-csrf-token header, session reset was performed following the unverified strategy.
At the same time, the cookie and session are returned.
If we look at the terminal where Rails is running, “Can’t verify CSRF token authenticity.” should be spotted among the
bunch of outputs.</p>

<p><img src="http://localhost:4000/assets/img/postman-schema-fetch.jpeg" alt="img: postman schema fetch" />
<img src="http://localhost:4000/assets/img/postman-schema-fetch-cookie-session.jpeg" alt="img: postman schema fetch cookie session" /></p>

<p>The userLogin mutation looks like below:</p>
<pre><code class="language-graphql">mutation login {
    userLogin(
        email: "finn.smith@example.com"
        password: "password!"
    ) {
        credentials {
            accessToken
            client
            uid
        }
    }
}
</code></pre>

<p>Write the mutation and click “Send” button.
Again, we’ll see “Can’t verify CSRF token authenticity.” on the terminal, but get the CSRF-TOKEN cookie and session
in the HTTP response header.</p>

<p><img src="http://localhost:4000/assets/img/postman-login-query.jpeg" alt="img: postman login query" />
<img src="http://localhost:4000/assets/img/postman-login-query-cookie-session.jpeg" alt="img: postman login query cookie session" /></p>

<p>The next step is to make posts or users query.
For example, posts query looks like below:</p>
<pre><code class="language-graphql">query {
    posts {
        id
        userId
        title
        content
    }
}
</code></pre>

<p>Add X-CSRF-TOKEN to the HTTP request header.
The token can be seen in the login response’s header, so copy and paste it to the value column.
Also, make sure the session is set in the cookie.
Write the query and click “Send” button.</p>

<p><img src="http://localhost:4000/assets/img/postman-posts-query-x-csrf-token.jpeg" alt="img: postman posts query x-csrf token" />
<img src="http://localhost:4000/assets/img/postman-posts-query-session.jpeg" alt="img: postman posts query session" />
<img src="http://localhost:4000/assets/img/postman-posts-query.jpeg" alt="img: postman posts query" /></p>

<p>Let’s see CSRF verification failure.
Click check box on the left of X-CSRF-TOKEN to deactivate. The header won’t be sent.
Now we see ActionController::InvalidAuthenticityToken exception.
On the terminal where Rails is running, “Can’t verify CSRF token authenticity.” appears again.
That means the exception strategy is working.</p>

<p><img src="http://localhost:4000/assets/img/postman-posts-query-failure.jpeg" alt="img: postman posts query failure" /></p>

<p>Lastly, let’s try postCreate mutation.
The mutation looks like below:</p>
<pre><code class="language-graphql">mutation create_post {
    postCreate(input: {
        title: "This is a test post title",
        content: "This is a test post content."
    }) {
        post {
            id
            userId
            title
            content
        }
    }
}
</code></pre>

<p>As explained in the previous post, access-token, client and uid should be set in the HTTP request header
in addition to X-CSRF-TOKEN and session.
Previously tried userLogin mutation gave us those three values already. Set those to the request header.
Make sure the session is attached in the cookie if the GraphQL client is not Postman.</p>

<p><img src="http://localhost:4000/assets/img/postman-create-post-headers.jpeg" alt="img: postman create post headers" /></p>

<p>Write the mutation query and click “Send” button.</p>

<p><img src="http://localhost:4000/assets/img/postman-create-post-query.jpeg" alt="img: postman create post query" /></p>

<p>The new post was successfully created.</p>

<h3 id="code">Code</h3>

<p>The example Rails app code is on the GitHub repo.
Please see <a href="https://github.com/yokolet/mini-blog-3">https://github.com/yokolet/mini-blog-3</a>.</p>

<h3 id="references">References</h3>
<ul>
  <li>OWASP: <a href="https://owasp.org/www-community/attacks/csrf">Cross-Site Request Forgery</a></li>
  <li><a href="https://marcgg.com/blog/2016/08/22/csrf-rails/">Understanding Rails’ Forgery Protection Strategies</a></li>
  <li><a href="https://medium.com/rubyinside/a-deep-dive-into-csrf-protection-in-rails-19fa0a42c0ef">A Deep Dive into CSRF Protection in Rails</a></li>
  <li><a href="https://guides.rubyonrails.org/security.html">Securing Rails Applications</a></li>
  <li><a href="https://blog.eq8.eu/article/rails-api-authentication-with-spa-csrf-tokens.html">Rails CSRF protection for SPA</a></li>
  <li><a href="https://checkmarx.com/blog/whats-old-becomes-new-again-csrf-attacks-on-graphql-apis/">What’s Old Becomes New Again: CSRF Attacks on GraphQL APIs</a></li>
</ul>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[This is the third post about securing Rails GraphQL API app. The topic is CSRF protection for GraphQL API. CSRF is an acronym of Cross-Site Request Forgery, and one of well-known vulnerabilities and a type of session hijack.]]></summary></entry><entry><title type="html">Make it Secure 2, GraphQL by Rails and Devise</title><link href="http://localhost:4000/2023/03/23/make-it-secure-2-graphql-by-rails-and-devise.html" rel="alternate" type="text/html" title="Make it Secure 2, GraphQL by Rails and Devise" /><published>2023-03-23T17:46:00+09:00</published><updated>2023-03-23T17:46:00+09:00</updated><id>http://localhost:4000/2023/03/23/make-it-secure-2-graphql-by-rails-and-devise</id><content type="html" xml:base="http://localhost:4000/2023/03/23/make-it-secure-2-graphql-by-rails-and-devise.html"><![CDATA[<p>This is the second post about securing Rails GraphQL API app.
Most of conceptual explanations are in the previous post,
<a href="/2023/03/19/make-it-secure-graphql-by-rails.html">Make it Secure, GraphQL by Rails</a>.
This memo is focusing on how to add the authentication using Devise gem
(<a href="https://github.com/heartcombo/devise">https://github.com/heartcombo/devise</a>).</p>

<p>The GraphQL API itself is the same as the previous one.
The GraphQL app in the previous post uses Global ID and implements the user authentication from scratch.
The Devise gem covers many of those.
However the odds are: the Devise gem is for a traditional web application, so the GraphQL API only app can’t use as is.
Luckily, people have already tried the token based authentication by Devise and established a couple of ways to do that.
A combination with JWT (Jason Web Token, <a href="https://github.com/jwt/ruby-jwt">https://github.com/jwt/ruby-jwt</a>) is one,
while with Devise Token Auth
(<a href="https://github.com/lynndylanhurley/devise_token_auth">https://github.com/lynndylanhurley/devise_token_auth</a>)
is another one.
This memo uses GraphQLDevise gem
(<a href="https://github.com/graphql-devise/graphql_devise">https://github.com/graphql-devise/graphql_devise</a>),
which is implemented on top of Devise Token Auth.</p>

<p>Versions:</p>
<ul>
  <li>Ruby: 3.2.1</li>
  <li>Rails: 7.0.4.3</li>
</ul>

<h4 id="create-rails-app">Create Rails App</h4>

<p>The Rails app creation is same as previous two posts.
However, the app here introduces Devise gem, so this memo starts from creating the app for clarity.</p>

<p>Create an option list file, for example, ./.railsrc, with the following content.</p>
<pre><code>--api
--skip-action-mailer
--skip-action-mailbox
--skip-action-cable
--skip-action-text
--skip-active-job
--skip-active-storage
-T
</code></pre>

<p>This app skips email based user registration provided by Devise gem.
For this reason, the option list has <code>--skip-action-mailer</code>.
The option list above creates much smaller API only Rails app.</p>

<p>Run the command to create the app.</p>

<pre><code class="language-bash">$ rails new mini-blog-2 --rc=./.railsrc
</code></pre>

<h4 id="setup-graphql_devise-gem">Setup graphql_devise gem</h4>

<p>The app is going to use graphql_devise gem for the authentication.
The first step is to add and initialize the gem.</p>

<pre><code class="language-bash">$ cd mini-blog-2
$ bundle add graphql_devise
</code></pre>

<p>Above command installs graphql_devise gem as well as graphql, devise, devise_auth_token gems as dependencies.</p>

<p>The next step depends on the design decision, whether to create a new GraphQL path for the authentication or to use an existing path.
If the new path is chosen, GraphQL paths will have <code>/graphql</code> and <code>/graphql_auth</code>.
If the existing path is chosen, GraphQL path will be only <code>/graphql</code> as normal GraphQL app has.
To use existing path, graphql_devise initializer needs an existing GraphQL schema as a mount point.
The choice here is to mount on the exising schema.
For this reason, the second step is to initialize GraphQL gem.</p>

<pre><code class="language-bash">$ rails g graphql:install
</code></pre>

<p>Above command generates the schema <code>MiniBlog2Schema</code> in the app/graphql/mini_blog2_schema.rb.
This is the mount point.
The graphql_devise initialization includes Devise model creation, so it needs model name for the authentication.
The model name is typically User.</p>

<pre><code class="language-bash">$ rails g graphql_devise:install User --mount MiniBlog2Schema
</code></pre>

<p>Above command shows messages from Devise gem in addition to creating a bunch of files.
As for GraphQL side, <code>include GraphqlDevise::SetUserByToken</code> is added to app/controllers/application_controller.rb,
and a schema plugin is added to app/graphql/mini_blog2_schema.rb.</p>
<pre><code class="language-ruby"># app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::API
  include GraphqlDevise::SetUserByToken
end
</code></pre>
<pre><code class="language-ruby"># app/graphql/mini_blog2_schema.rb
class MiniBlog2Schema &lt; GraphQL::Schema
  use GraphqlDevise::SchemaPlugin.new(
    query:            Types::QueryType,
    mutation:         Types::MutationType,
    resource_loaders: [
      GraphqlDevise::ResourceLoader.new(User)
    ]
  )
  mutation(Types::MutationType)
  query(Types::QueryType)

  # more code here

end
</code></pre>

<p>The migration file for the user model has been created as well, so run the migration.</p>
<pre><code class="language-bash">$ rails db:migrate
</code></pre>

<h4 id="additional-graphql_devise-configuration">Additional graphql_devise configuration</h4>

<p>We are almost there.
Since the app mounts the authentication path to the existing GraphQL path, some more configurations are required.</p>

<p>Add <code>include GraphqlDevise::FieldAuthentication</code> in the file, app/graphql/types/base_field.rb.
Add <code>gql_devise_context(User)</code> in the file, app/controller/graphql_controller.rb, to receive
user info from GraphQL queries/mutations.</p>
<pre><code class="language-ruby"># app/graphql/types/base_field.rb.
module Types
  class BaseField &lt; GraphQL::Schema::Field
    include GraphqlDevise::FieldAuthentication

    argument_class Types::BaseArgument
  end
end
</code></pre>
<pre><code class="language-ruby"># app/controller/graphql_controller.rb
def execute
  variables = prepare_variables(params[:variables])
  query = params[:query]
  operation_name = params[:operationName]
  context = gql_devise_context(User)
  result = MiniBlog2Schema.execute(query, variables: variables, context: context, operation_name: operation_name)
  render json: result
rescue StandardError =&gt; e
  raise e unless Rails.env.development?
  handle_error_in_development(e)
end
</code></pre>

<h4 id="make-mutation-queries-to-register-and-login">Make Mutation Queries to Register and Login</h4>

<p>For now, we can register a user and login.
Let’s try.
As a GraphQL client, Insomnia (<a href="https://insomnia.rest/">https://insomnia.rest/</a>) is used since Insomnia has a nice UI
for HTTP request/response headers.</p>

<p>To register the user, make mutation query below.</p>
<pre><code class="language-graphql">mutation register {
	userRegister(
		email: "finn.smith@example.com"
		password: "password!"
		passwordConfirmation: "password!"
	) {
		authenticatable {
			email
		}
		credentials{
			accessToken
			client
			uid
		}
	}
}
</code></pre>
<p>Above query sets only required fields. Other fields can be seen in Insomnia’s Schema pane.
The response fields are the same. The accessToken, client and uid will be used for later queries, so those are requested.</p>

<p><img src="http://localhost:4000/assets/img/insomnia-devise-register.jpeg" alt="img: insomnia devise user register" /></p>

<p>Let’s check HTTP response headers. As in below, authentication related headers can been seen.</p>

<p><img src="http://localhost:4000/assets/img/insomnia-devise-register-response-header.jpeg" alt="img: insomnia devise user register response header" /></p>

<p>To login as a registered user, make mutation query below.</p>
<pre><code class="language-graphql">mutation login {
	userLogin(
		email: "finn.smith@example.com"
		password: "password!"
	) {
		authenticatable {
			email
		}
		credentials{
			accessToken
			client
			uid
		}
	}
}
</code></pre>

<p>Successful login returns the same result as the registration.</p>

<p><img src="http://localhost:4000/assets/img/insomnia-devise-login.jpeg" alt="img: insomnia devise user login" />
<img src="http://localhost:4000/assets/img/insomnia-devise-login-response-header.jpeg" alt="img: insomnia devise user login response header" /></p>

<h4 id="user-and-post-models">User and Post Models</h4>

<p>If we imagine to create a blog site, minimum models would be users and posts.
Those two models should have a relation: a user has many posts.</p>

<p>The user model is already created when graphql_devise was initialized.
The post model should be created, but nothing special.</p>

<pre><code class="language-bash">$ rails g model Post user:references title:string{50} content:text
</code></pre>

<p>We want to add some non-null constraints to user and post models.
Create migrations:</p>
<pre><code class="language-bash">$ rails g migration ChangeEmailNullOnUsers
$ rails g migration ChangeTitleContentNullOnPosts
</code></pre>

<p>Edit migration files:</p>
<pre><code class="language-ruby">#  db/migrate/[DATE TIME]_change_email_null_on_users.rb
class ChangeEmailNullOnUsers &lt; ActiveRecord::Migration[7.0]
  def change
    change_column_null :users, :email, false
  end
end

#  db/migrate/[DATE TIME]_change_title_content_null_on_posts.rb
class ChangeTitleContentNullOnPosts &lt; ActiveRecord::Migration[7.0]
  def change
    change_column_null :posts, :title, false
    change_column_null :posts, :content, false
  end
end
</code></pre>

<p>Run migration:</p>
<pre><code class="language-bash">$ rails db:migrate
</code></pre>

<p>Update models:</p>
<pre><code class="language-ruby"># app/models/user.rb
class User &lt; ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :validatable
  include GraphqlDevise::Authenticatable

  has_many :posts, dependent: :destroy

  validates :email, presence: true, uniqueness: true
end

# app/models/post.rb
class Post &lt; ApplicationRecord
  belongs_to :user

  validates :title, presence: true
  validates :content, presence: true
end
</code></pre>

<h4 id="graphql-queries">GraphQL Queries</h4>

<p>To make queries, we need GraphQL types.
Generate user and post types.</p>
<pre><code class="language-bash">$ rails g graphql:object user
$ rails g graphql:object post
</code></pre>
<p>Now, we got two types:</p>
<ul>
  <li>app/graphql/types/user_type.rb</li>
  <li>app/graphql/types/post_type.rb</li>
</ul>

<p>We need query definitions for both user and post.
Create resolvers as in below:</p>
<pre><code class="language-ruby"># app/graphql/resolvers/user_resolver.rb
module Resolvers
  class UserResolver &lt; GraphQL::Schema::Resolver
    type [Types::UserType], null: false

    argument :id, Int, required: false

    def resolve(**kwargs)
      if kwargs[:id]
        [User.find(kwargs[:id])]
      else
        User.all
      end
    end
  end
end

# app/graphql/resolvers/post_resolver.rb
module Resolvers
  class PostResolver &lt; GraphQL::Schema::Resolver
    type [Types::PostType], null: false

    argument :user_id, Int, required: false

    def resolve(**kwargs)
      if kwargs[:user_id]
        Post.where(user: kwargs[:user_id]).all
      else
        Post.all
      end
    end
  end
end
</code></pre>

<p>Update query_types to include user and post resolvers with authenticate option false.
An assumption here is that we don’t need to authenticate for queries.</p>
<pre><code class="language-ruby"># app/graphql/types/query_type.rb
module Types
  class QueryType &lt; Types::BaseObject
    # Add `node(id: ID!) and `nodes(ids: [ID!]!)`
    include GraphQL::Types::Relay::HasNodeField
    include GraphQL::Types::Relay::HasNodesField

    # Add root-level fields here.
    # They will be entry points for queries on your schema.
    field :users, resolver: Resolvers::UserResolver, authenticate: false
    field :posts, resolver: Resolvers::PostResolver, authenticate: false
  end
end
</code></pre>

<p>An example query to get all users will be blow:</p>
<pre><code class="language-graphql">query users {
	users {
		id
		email
	}
}
</code></pre>

<p><img src="http://localhost:4000/assets/img/insomnia-devise-users.jpeg" alt="img: insomnia devise users query" /></p>

<p>To make the query above, no authentication is required at all.</p>

<p>We can make post query as well, however, it returns an empty array at this moment.</p>

<h4 id="graphql-mutations">GraphQL Mutations</h4>

<p>The next is a create post mutation so that we can see some results from the post query.</p>

<pre><code class="language-bash">$ rails g graphql:mutation_create post
</code></pre>

<p>Above generates app/graphql/mutations/post_create.rb file.
After some editing, the post_create.rb looks like below:</p>
<pre><code class="language-ruby"># app/graphql/mutations/post_create.rb
module Mutations
  class PostCreate &lt; BaseMutation
    description "Creates a new post"

    field :post, Types::PostType, null: false

    argument :title, String, required: true
    argument :content, String, required: true

    def resolve(**kwargs)
      kwargs[:user_id] = context[:current_resource].id
      post = ::Post.new(**kwargs)
      raise GraphQL::ExecutionError.new "Error creating post", extensions: post.errors.to_hash unless post.save

      { post: post }
    end
  end
end
</code></pre>

<p>Since mutation queries require authentication, the logged in user information is available in the context.
The user id to create a post is retrieved from the authentication result.</p>

<p>Lastly, we need a little hack on Rails 7.0.4.3 and Devise 4.9.0.
In general, API only web application don’t use cookie or session.
However, Devise has been developed based on a traditional web application, so it still relies on the cookie.
The issue is on-going and discussed at
<a href="https://github.com/heartcombo/devise/issues/5443">https://github.com/heartcombo/devise/issues/5443</a>.</p>

<p>The workaround is adding below three lines to config/application.rb.
The session store’s key is, in general, “<em>[APP NAME]_session</em>#{Rails.env}”.</p>
<pre><code class="language-ruby"># config/application.rb
# ...
# ...
module MiniBlog2
  class Application &lt; Rails::Application
    # ...
    # ...
    config.session_store :cookie_store, key: "_mini-blog-2_session_#{Rails.env}"
    config.middleware.use ActionDispatch::Cookies
    config.middleware.use config.session_store, config.session_options
  end
end
</code></pre>

<p>Everything is ready.
It’s time to create some posts.
As the application designed like this, we need to log in first.
Try login mutation query.</p>

<pre><code class="language-graphql">mutation login {
	userLogin(
		email: "finn.smith@example.com"
		password: "password!"
	) {
		authenticatable {
			email
		}
		credentials{
			accessToken
			client
			uid
		}
	}
}
</code></pre>

<p><img src="http://localhost:4000/assets/img/insomnia-devise-login-for-post.jpeg" alt="img: insomnia devise login for post" /></p>

<p>The successful login returns accessToken, client, and uid.
These three are used to authenticate.
The create post mutation query looks like below:</p>
<pre><code class="language-graphql">mutation post {
	postCreate(input: {
		title: "Hello World, Again",
		content: "This is the second post from Finn."
	}) {
		post {id userId title content}
	}
}
</code></pre>

<p>Set three user authentication values to the HTTP request header.
Be careful, GraphQL result is accessToken, but HTTP request header is access-token.
Now, we could create a post.</p>

<p><img src="http://localhost:4000/assets/img/insomnia-devise-post.jpeg" alt="img: insomnia devise post mutation" /></p>

<p><img src="http://localhost:4000/assets/img/insomnia-devise-post-headers.jpeg" alt="img: insomnia devise post request headers" /></p>

<p>Add some more posts using different user’s authentication values.</p>

<p>To get all posts by all users, make below query.</p>
<pre><code class="language-graphql">query posts {
	posts {
		id
		userId
		title
		content
	}
}
</code></pre>

<p><img src="http://localhost:4000/assets/img/insomnia-devise-all-posts.jpeg" alt="img: insomnia devise all posts" /></p>

<p>To get all post of a specific user, make below query with user’s id.</p>
<pre><code class="language-graphql">query posts {
	posts(userId: 3) {
		id
		userId
		title
		content
	}
}
</code></pre>

<p><img src="http://localhost:4000/assets/img/insomnia-devise-post-of-a-user.jpeg" alt="img: insomnia devise posts of a user" /></p>

<h3 id="code">Code</h3>

<p>The example Rails app code is on the GitHub repo.
Please see <a href="https://github.com/yokolet/mini-blog-2">https://github.com/yokolet/mini-blog-2</a>.</p>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[This is the second post about securing Rails GraphQL API app. Most of conceptual explanations are in the previous post, Make it Secure, GraphQL by Rails. This memo is focusing on how to add the authentication using Devise gem (https://github.com/heartcombo/devise).]]></summary></entry><entry><title type="html">Make it Secure, GraphQL by Rails</title><link href="http://localhost:4000/2023/03/19/make-it-secure-graphql-by-rails.html" rel="alternate" type="text/html" title="Make it Secure, GraphQL by Rails" /><published>2023-03-19T01:04:00+09:00</published><updated>2023-03-19T01:04:00+09:00</updated><id>http://localhost:4000/2023/03/19/make-it-secure-graphql-by-rails</id><content type="html" xml:base="http://localhost:4000/2023/03/19/make-it-secure-graphql-by-rails.html"><![CDATA[<p>These days, attacks on a web application becomes more and more common.
Every web application should be protected to get rid of such attacks.
Ruby on Rails provides ways to make it secure out of the box.
Additionally, well-used gems in Rails world, such as Devise (<a href="https://github.com/heartcombo/devise">https://github.com/heartcombo/devise</a>),
give us convenient ways to protect the Rails app.</p>

<p>However, when it comes to an API only web application, it’s not straightforward.
For example, passing a token by meta tag won’t work.
This memo is focusing on GraphQL API and about how to make it secure.</p>

<p>Versions:</p>
<ul>
  <li>Ruby: 3.2.1</li>
  <li>Rails: 7.0.4.3</li>
</ul>

<h3 id="password-authentication">Password Authentication</h3>

<p>The most primitive idea to protect web application is adding a password authentication.
As we know, users who wants to modify resources on the web site should register themselves and
complete a login process by sending an id and credential combination to the web site.
The id and credential pair will be verified on the web application side.
Then, the logged in state will be maintained between the user and the web site.
With the logged in state, web application processes the resource update request and returns the result.
If not, an error message should be sent back to the user who tried.</p>

<p>The traditional web application would show the HTML login form, dropdown or sort for register and login.
Then, the web browser and application maintains the logged-in state by a session, cookie or hidden field in the HTML form.</p>

<p>The API only server should do what?
In general, the API server uses HTTP headers or explicit token exchanges.
For example, GraphQL API provides login mutation which returns a token after a successful verification.
The returned token should be added to an HTTP header to make successive mutations and/or queries.</p>

<p>At this moment, multiple techniques are out there, however, none is decisive for GraphQL API.
Sometime, REST API is used for login and register user since Devise gem works better with REST API.
Others do by GraphQL mutation API with the authentication implementation from scratch.</p>

<p>This memo mentions about a way to authenticate users by Global ID.</p>

<h4 id="global-id">Global ID</h4>

<p>The Global ID is “an app wide URI that uniquely identifies a model instance” as
described in <a href="https://github.com/rails/globalid">https://github.com/rails/globalid</a>.
The Global ID based authentication does two jobs below using Global ID as an uniquely identifiable value:</p>
<ul>
  <li>create a user with the uniquely identifiable value</li>
  <li>locate a user based on the uniquely identifiable value</li>
</ul>

<p>The Global ID authentication is explained in the YouTube video and GitHub repository below:</p>
<ul>
  <li>YouTube: Getting started with GraphQL in Rails <a href="https://www.youtube.com/watch?v=izgCaExV9Uo">https://www.youtube.com/watch?v=izgCaExV9Uo</a></li>
  <li>GitHub: <a href="https://github.com/phawk/coinfusion/tree/graphql_ruby_2">https://github.com/phawk/coinfusion/tree/graphql_ruby_2</a></li>
</ul>

<p>Let’s add Global ID based authentication to the GraphQL API created in the previous post,
<a href="/2023/03/12/getting-started-graphql-using-ruby-on-rails.html">Getting Started GraphQL Using Ruby on Rails</a>.</p>

<h5 id="add-gems">Add Gems</h5>

<p>The Global ID feature is provided by globalid gem.
The gem is pulled as an dependency of Action Text and Active Job.
When the GraphQL app was created in the previous blog post, those two were skipped.
So, the gem should be added manually.</p>

<p>Also, we need bcrypt gem, <a href="https://github.com/bcrypt-ruby/bcrypt-ruby">https://github.com/bcrypt-ruby/bcrypt-ruby</a>.
The bcrypt gem is used to create a password digest and provide user authentication feature.</p>

<p>To add those two gems, do below:</p>
<ol>
  <li>open Gemfile and uncomment bcrypt gem</li>
  <li>run <code>bundle add globalid</code></li>
</ol>

<h5 id="update-user-model">Update User Model</h5>

<p>The User model should have a <code>password_digest</code> column to save a password digest.
The User model should never ever save a raw password in the database which is to avoid the actual password to be stolen.
This is a very basic security practice.</p>

<p>The password digest is a hashed value of salt and given password.
On Rails, the bcrypt gem is responsible to create the hashed value.
The bcrypt gem is a Ruby implementation of <a href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt</a> password-hashing function.
Precisely, the bcrypt function creates a concatenated string of a hashing algorithm, cost, salt and checksum.
That sort of hashed value will be saved in the database instead of a raw password.</p>

<p>Let’s create a migration to add password_digest column to user model.</p>

<pre><code class="language-bash">$ rails g migration AddPasswordDigestToUsers
</code></pre>

<p>Edit the migration file and run the migration.</p>
<pre><code class="language-ruby"># db/migrate/[DATE TIME]_add_password_digest_to_users.rb
class AddPasswordDigestToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :password_digest, :string
  end
end
</code></pre>
<pre><code class="language-bash">$ rails db:migrate
</code></pre>

<p>The user model definition should be updated also.</p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  attr_accessor :token

  has_secure_password

  has_many :posts, dependent: :destroy

  validates :email, uniqueness: true
  validates :password, length: { minimum: 8 }, presence: true
end
</code></pre>

<p>Since this is a GraphQL API, the authentication is token based.
Because of that, <code>attr_accessor :token</code>, is added.
The <code>has_secure_password</code> is to signal that the user should be authenticated, which is a provided feature by bcrypt gem.
The line, <code>validates :password, length: { minimum: 8 }, presence: true</code> is to require the password input.
The database won’t have the password column, but still the model creation needs password.
For this reason, the password constraint is in the user model.</p>

<h5 id="update-graphql-controller-types-and-mutations">Update GraphQL Controller, Types and Mutations</h5>

<p>The next step is GraphQL controller, type and mutation updates.
The first one is a graphql_controller update.
The changes in the controller are:</p>
<ul>
  <li>add a private method, current_user, to locate a user based on Global ID using the token in the HTTP header.</li>
  <li>add a current_user entry in graphql context hash table.</li>
</ul>

<pre><code class="language-ruby"># app/controllers/graphql_controller.rb
class GraphqlController &lt; ApplicationController

  def execute
    variables = prepare_variables(params[:variables])
    query = params[:query]
    operation_name = params[:operationName]
    context = {
      current_user: current_user
    }
    result = MiniBlogSchema.execute(query, variables: variables, context: context, operation_name: operation_name)
    render json: result
  rescue StandardError =&gt; e
    raise e unless Rails.env.development?
    handle_error_in_development(e)
  end

  private

  def current_user
    header  = request.headers["AUTHORIZATION"]
    token = header&amp;.gsub(/\AToken\s/, "")
    GlobalID::Locator.locate_signed(token, for: 'graphql')
  end
  # snip
  # ...
  # ...
end
</code></pre>

<p>The second update is the user_type.
The user_type is used for both query and mutation, so it should have password and token fields.</p>
<pre><code class="language-ruby"># app/graphql/types/user_type.rb
module Types
  class UserType &lt; Types::BaseObject
    field :id, ID, null: false
    field :email, String, null: false
    field :first_name, String, null: true
    field :last_name, String, null: true
    field :password, String, null: true
    field :token, String, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
  end
end
</code></pre>

<p>The remaining updates are mutations.
The user registration and login mutations look like below:</p>
<pre><code class="language-ruby"># app/graphql/mutations/user_register.rb
module Mutations
  class UserRegister &lt; BaseMutation
    description "Register a new user"

    field :user, Types::UserType, null: false

    argument :email, String, required: true
    argument :password, String, required: true
    argument :first_name, String, required: false
    argument :last_name, String, required: false

    def resolve(**kwargs)
      user = ::User.new(**kwargs)
      if user.save
        user.token = user.to_sgid(expires_in: 6.hours, for: 'graphql')
        { user: user }
      else
        raise GraphQL::ExecutionError.new "Error creating user", extensions: user.errors.to_hash
      end
    end
  end
end
</code></pre>
<pre><code class="language-ruby"># app/graphql/mutations/user_login.rb
module Mutations
  class UserLogin &lt; BaseMutation
    description "Login an existing user"

    field :user, Types::UserType, null: false

    argument :email, String, required: true
    argument :password, String, required: true

    def resolve(email:, password:)
      user = User.find_by(email: email)
      if user&amp;.authenticate(password)
        user.token = user.to_sgid(expires_in: 6.hours, for: 'graphql')
        { user: user }
      else
        raise GraphQL::ExecutionError.new "Error creating user", extensions: user.errors.to_hash
      end
    end
  end
end
</code></pre>
<p>The mutation_type needs an update to include UserRegister and UserLogin mutations.
Also, we don’t need UserCreate mutation anymore, so delete it if it is there.</p>
<pre><code class="language-ruby"># app/graphql/types/mutation_type.rb
module Types
  class MutationType &lt; Types::BaseObject
    field :user_register, mutation: Mutations::UserRegister
    field :user_login, mutation: Mutations::UserLogin
    field :post_create, mutation: Mutations::PostCreate
  end
end
</code></pre>

<p>So far, the GraphQL API is able to provide user register and login feature.
The last piece is to create a post after the successful login.
To add the authentication feature to post creation mutation,
BaseMutation class is going to have two methods to check logged in state.
The GraphqlController already added the context[:current_user] parameter.
The the authenticate! method raises an exception if context[:current_user] is empty.</p>

<pre><code class="language-ruby">module Mutations
  class BaseMutation &lt; GraphQL::Schema::RelayClassicMutation
    argument_class Types::BaseArgument
    field_class Types::BaseField
    input_object_class Types::BaseInputObject
    object_class Types::BaseObject

    private

    def current_user
      context[:current_user]
    end

    def authenticate!
      if current_user.blank?
        raise GraphQL::ExecutionError.new "Authentication failed. Please log in."
      end
    end
  end
end
</code></pre>

<p>The PostCreate class will have one line of addition.
The resolve method gets <code>authenticate!</code> in its first line. That’s it.</p>
<pre><code class="language-ruby"># app/graphql/mutations/post_create.rb
module Mutations
  class PostCreate &lt; BaseMutation
    description "Creates a new post"

    field :post, Types::PostType, null: false

    argument :user_id, Integer, required: true
    argument :title, String, required: true
    argument :content, String, required: true

    def resolve(**kwargs)
      authenticate!
      post = ::Post.new(**kwargs)
      raise GraphQL::ExecutionError.new "Error creating post", extensions: post.errors.to_hash unless post.save

      { post: post }
    end
  end
end
</code></pre>

<h5 id="make-queries">Make Queries</h5>

<p>All are implemented.
It’s time to try those.
Here, GraphQL client is Insomnia (<a href="https://insomnia.rest/">https://insomnia.rest/</a>)
since both request and response HTTP headers are visible and easy to edit.</p>

<p>The first GraphQL query is the user registration.</p>
<pre><code class="language-graphql">mutation register {
	userRegister(input: {
		email: "finn.smith@example.com",
		password: "password!",
		firstName: "Finn",
		lastName: "Smith"
	}) {
		user {
			id
			email
			token
		}
	}
}
</code></pre>
<p>If the user is successfully registered, a tokenized signed Global ID will be returned.</p>

<p><img src="http://localhost:4000/assets/img/insomnia-register-query.jpeg" alt="img: insomnia user register query" /></p>

<p>The next is a login mutation.</p>
<pre><code class="language-graphql">mutation login {
	userLogin(input: {
		email: "finn.smith@example.com",
		password: "password!"
	}) {
		user {
		    id
			email
			token
		}
	}
}
</code></pre>
<p>The login mutation also returns a tokenized signed Global ID.</p>

<p><img src="http://localhost:4000/assets/img/insomnia-login-query.jpeg" alt="img: insomnia user login query" /></p>

<p>The post create mutation needs HTTP header to complete successfully.
So, let’s try without the token in the HTTP header to see it will fail.</p>

<pre><code class="language-graphql">mutation post {
	postCreate(input: {
		userId: 9,
		title: "Hello, World!",
		content: "This is the first from Finn"
	}) {
		post {
			id
			title
			content
		}
	}
}
</code></pre>

<p>As expected, it failed without the token in the HTTP header</p>

<p><img src="http://localhost:4000/assets/img/insomnia-post-failed.jpeg" alt="img: insomnia failed post query" /></p>

<p>Then, set Authorization HTTP request header with the token returned from register or login mutation.</p>

<pre><code>Authorization: Token BAh7CEkiCGdpZAY6BkVUSSIsZ2lk.......
</code></pre>

<p>Now, it succeeds.</p>

<p><img src="http://localhost:4000/assets/img/insomnia-post-with-header.jpeg" alt="img: insomnia post with header" /></p>

<h3 id="code">Code</h3>

<p>The example Rails app code is on the GitHub repo.
Please see <a href="https://github.com/yokolet/mini-blog">https://github.com/yokolet/mini-blog</a>.</p>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[These days, attacks on a web application becomes more and more common. Every web application should be protected to get rid of such attacks. Ruby on Rails provides ways to make it secure out of the box. Additionally, well-used gems in Rails world, such as Devise (https://github.com/heartcombo/devise), give us convenient ways to protect the Rails app.]]></summary></entry><entry><title type="html">Getting Started GraphQL Using Ruby on Rails</title><link href="http://localhost:4000/2023/03/12/getting-started-graphql-using-ruby-on-rails.html" rel="alternate" type="text/html" title="Getting Started GraphQL Using Ruby on Rails" /><published>2023-03-12T01:13:00+09:00</published><updated>2023-03-12T01:13:00+09:00</updated><id>http://localhost:4000/2023/03/12/getting-started-graphql-using-ruby-on-rails</id><content type="html" xml:base="http://localhost:4000/2023/03/12/getting-started-graphql-using-ruby-on-rails.html"><![CDATA[<p>GraphQL is an API standard to provide resources on the server-side to various types of clients.
GraphQL itself is a specification and doesn’t provide an implementation.
For Ruby on Rails, GraphQL Ruby <a href="https://graphql-ruby.org/">https://graphql-ruby.org/</a> is the most popular library.</p>

<p>Not like REST API, GraphQL has only one endpoint.
While REST API uses different endpoints (paths or URL) to access multiple types of resources,
GraphQL uses schema based queries.
The REST API clients receives all fields server returned.
However, GraphQL clients can specify what fields they want to receive from the API server.</p>

<p>For REST API, the swagger UI <a href="https://swagger.io/tools/swagger-ui/">https://swagger.io/tools/swagger-ui/</a> is often
used as a documentation and testing tool.
In general, the swagger UI is provided by the REST API server.</p>

<p>In contract, the GraphQL server doesn’t provide such UI tool.
Instead, GraphQL desktop apps are out there, which provides UI based documentation and testing tools.
The blog post “<a href="https://testfully.io/blog/graphql-clients/">Top 10 GraphQL clients</a>” lists desktop apps with some explanations.
Such apps have ability to pull the schema from GraphQL server and show that on UI.
Also, those have features to write GraphQL queries, send those and receive results.</p>

<p>Since Ruby on Rails is designed for REST API, we need additional steps to use Rails as a GraphQL server.
This is a memo how to get started GraphQL using Ruby on Rails.</p>

<h3 id="setting-up">Setting Up</h3>

<h4 id="create-rails-app">Create Rails App</h4>

<p>This memo focuses on creating GraphQL API server.
The App will be the API only and have a smaller stack with sqlite3 as a database.
Ruby and Rails versions are:</p>
<ul>
  <li>Ruby: 3.2.1</li>
  <li>Rails: 7.0.4.2</li>
</ul>

<p>Create <code>.railsrc</code> file with the content below:</p>
<pre><code class="language-bash">--api
--skip-action-mailer
--skip-action-mailbox
--skip-action-cable
--skip-action-text
--skip-active-job
--skip-active-storage
-T
</code></pre>

<p>The default location of <code>.railsrc</code> is a home directory just like <code>.zshrc</code> or <code>.bashrc</code>.
If it is created in another directory and/or another filename, use <code>--rc=RC</code> option to specify the file.</p>

<p>Create the Rails app named “mini-blog”, for example:</p>

<pre><code class="language-bash">$ rails new mini-blog --rc=./.railsrc
</code></pre>

<p>Test the app is created correctly:</p>

<pre><code class="language-bash">$ cd mini-blog
$ rails s
</code></pre>

<p>Then, hit http://localhost:3000/ on a web browser.
If you see Rails logo and Ruby/Rails versions, the server could start successfully.</p>

<h4 id="install-graphql-ruby-gem">Install GraphQL Ruby gem</h4>

<p>Once the Rails app is created, the next step is to install GraphQL Ruby (<a href="https://graphql-ruby.org/">https://graphql-ruby.org/</a>) gem.
Run two commands below:</p>
<pre><code class="language-bash">$ bundle add graphql
$ rails g graphql:install
</code></pre>

<p>The second command generates GraphQL basic types, default query/mutation types, and a default schema.
The schema name is <code>[APP_NAME]_schema.rb</code>.
All are located under <code>app/graphql</code> directory.
Also, the command adds a route to <code>/graphql</code>. Have a look at <code>config/route.rb</code>, which looks like:</p>
<pre><code class="language-ruby"># config/routes.rb
Rails.application.routes.draw do
  post "/graphql", to: "graphql#execute"
  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html

  # Defines the root path route ("/")
  # root "articles#index"
end
</code></pre>

<p>Lastly, the second command generates a default GraphQL controller, <code>app/controllers/graphql_controller.rb</code>.</p>

<p>Now, <code>app</code> directory looks like:</p>
<pre><code>app
├── controllers
│   ├── application_controller.rb
│   ├── concerns
│   └── graphql_controller.rb
├── graphql
│   ├── mini_blog_schema.rb
│   ├── mutations
│   │   └── base_mutation.rb
│   └── types
│       ├── base_argument.rb
│       ├── base_connection.rb
│       ├── base_edge.rb
│       ├── base_enum.rb
│       ├── base_field.rb
│       ├── base_input_object.rb
│       ├── base_interface.rb
│       ├── base_object.rb
│       ├── base_scalar.rb
│       ├── base_union.rb
│       ├── mutation_type.rb
│       ├── node_type.rb
│       └── query_type.rb
└── models
    ├── application_record.rb
    └── concerns
</code></pre>

<h4 id="try-how-graphql-looks-like">Try How GraphQL Looks Like</h4>

<p>For now, GraphQL has started working with the minimal setting.
The GraphQL gem’s generator already created a very simple API.
We can test that.</p>

<p>To test GraphQL, we need a GraphQL client.
Previously, Graphiql gem (notice, the name has “i” before ql) was often installed along with GraphQL Ruby gem.
However, once the Rails 7 app is configured as API only server, adding UI became not easy.
Besides, many free-to-use GraphQL clients are out there as mentioned at the beginning.</p>

<p>Among those desktop apps, below might be the choice.</p>
<ul>
  <li>GraphiQL <a href="https://github.com/skevy/graphiql-app">https://github.com/skevy/graphiql-app</a></li>
  <li>Altair <a href="https://altairgraphql.dev/">https://altairgraphql.dev/</a></li>
  <li>Insomnia <a href="https://insomnia.rest/">https://insomnia.rest/</a></li>
</ul>

<p>This memo is going to use GraphiQL desktop app.
If you are on MacOS and have brew, try below to install the app.</p>
<pre><code class="language-bash">$ brew install --cask graphiql
</code></pre>

<p>If you have other OS, you can install the desktop app by npm command as well.
Additional installations are on the GitHub repo.</p>

<p>When the GraphiQL window is firstly opened, it should look like this:</p>

<p><img src="http://localhost:4000/assets/img/graphiql-default.jpeg" alt="default graphiql window" /></p>

<p>Input http://localhost:3000/graphql in the GraphQL Endpoint field, which is defined in <code>config/routes.rb</code>
Also, check the Method choice. It is defined in <code>config/routes.rb</code> as POST.
Then, GraphiQL app connects to Rails and pulls the schema defined in the <code>app/graphql/types/query_type.rb</code>
and <code>app/graphql/types/mutation_type.rb</code>.
Those schemas show up when “&lt; DOCS” button on the right upper area of GraphiQL window is clicked.</p>

<p><img src="http://localhost:4000/assets/img/graphiql-docs.jpeg" alt="default graphiql window" /></p>

<p>Both Query and Mutation schemas are displayed when the links get clicked.</p>

<p>Let’s make a query to testField.
On the leftmost pane, input GraphQL query.</p>
<pre><code>{
  testField
}
</code></pre>

<p>Hit the right arrow button above the query input pane.
The result is on the center pane.
The message of “Hello World!” is from <code>app/graphql/types/query_type.rb</code> file.</p>

<p><img src="http://localhost:4000/assets/img/graphiql-query.jpeg" alt="default graphiql window" /></p>

<p>The mutation query can be sent, however, nothing changes since all are static just a test implementation.</p>

<h3 id="create-models-and-graphql-types">Create Models and GraphQL Types</h3>

<p>GraphQL itself is independent from the active record world.
However, API connects to a database to retrieve or update resources almost always.
On Ruby on Rails, creating an active record model is the way to connect to the database.</p>

<p>Well, a GraphQL type is the first? Or, an active record model should come before the GraphQL type?
The GraphQL generator can create a type without a model definition.
But, certainly, the type definition is almost empty.
When the active record model exists already, GraphQL generator looks at the database schema and generates the type.
By this, we will get a usable GraphQL type definition.</p>

<h4 id="define-models">Define Models</h4>

<p>Let’s imagine we will create a blog site.
The minimum models would be users and posts whose relation is: a user has multiple posts.
The user’s email should be unique so that the same email user won’t be created more than once.</p>

<p>The first thing is to generate user and post models as in below:</p>

<pre><code class="language-bash">$ rails g model User email:string:uniq first_name:string last_name:string
$ rails g model Post user:references title:string{50} content:text
</code></pre>

<p>We want to add some more constraints to models.
The user model’s email is implicitly non-null since it is an indexed unique value.
However, for the graphql generator, it’s better to have non-null constraint explicitly.
Additionally, we want post model’s title and content to be non-null fields also.
No need to say, we need migrations.</p>

<pre><code class="language-bash">$ rails g migration ChangeEmailNullOnUsers
$ rails g migration ChangeTitleContentNullOnPosts
</code></pre>

<p>Then, edit migration files:</p>
<pre><code class="language-ruby">#  db/migrate/[DATE TIME]_change_email_null_on_users.rb
class ChangeEmailNullOnUsers &lt; ActiveRecord::Migration[7.0]
  def change
    change_column_null :users, :email, false
  end
end

#  db/migrate/[DATE TIME]_change_title_content_null_on_posts.rb
class ChangeTitleContentNullOnPosts &lt; ActiveRecord::Migration[7.0]
  def change
    change_column_null :posts, :title, false
    change_column_null :posts, :content, false
  end
end
</code></pre>

<p>Create tables on the sqlite3 database.</p>

<pre><code class="language-bash">$ rails db:create db:migrate
</code></pre>

<p>We should update models as well.</p>

<p>Edit <code>app/models/user.rb</code> to add a has_many association and uniqueness validation.</p>

<pre><code class="language-ruby"># app/models/user.rb
class User &lt; ApplicationRecord
  has_many :posts, dependent: :destroy

  validates :email, uniqueness: true
end
</code></pre>

<p>Edit <code>app/models/post.rb</code> to add presence validations.</p>

<pre><code class="language-ruby"># app/models/post.rb
class Post &lt; ApplicationRecord
  belongs_to :user

  validates :title, presence: true
  validates :content, presence: true
end
</code></pre>

<p>The model definitions are ready. It’s time to add some seed data, so that we can see some results.</p>

<pre><code class="language-ruby"># db/seeds.rb
user1 = User.create(
  email: "john.doe@example.com",
  first_name: "John",
  last_name: "Doe"
)

user2 = User.create(
  email: "jane.smith@example.com",
  first_name: "Jane",
  last_name: "Smith"
)

Post.create(
  [{
     user: user1,
     title: "Accidentally, I created a Rails app!",
     content: "My days are this, that and blah. Wait! I accidentally created a Rails app!!"
   },
   {
     user: user2,
     title: "Blogging",
     content: "I like blogging. It's fun. One day, I started writing a blog post..."
   },
   {
     user: user2,
     title: "Spring!",
     content: "It's not about a web framework here. I'm talking about a season. Yes, Spring!"
   }
  ]
)
</code></pre>

<p>Run the command below to add seed data to the database.</p>

<pre><code class="language-bash">$ rails db:seed
</code></pre>

<p>To check above worked correctly, Rails console is one of ways to test it.</p>
<pre><code class="language-bash">$ rails c
Loading development environment (Rails 7.0.4.2)
irb(main):001:0&gt; User.all
...(user query result here)...
irb(main):002:0&gt; Post.all
...(post query result here)...
...
</code></pre>

<h4 id="generate-graphql-types">Generate GraphQL Types</h4>

<p>For now, active record models are ready.
The next step is to generate GraphQL types.
Run the command below.</p>

<pre><code class="language-bash">$ rails g graphql:object user
$ rails g graphql:object post
</code></pre>

<p>The generator captures the database schema definition in db/schema.rb to create user and post types.
Mostly, we can use generated types as those are.</p>

<p>The generated user_type.rb and post_type.rb look like this:</p>
<pre><code class="language-ruby"># app/graphql/types/user_type.rb
module Types
  class UserType &lt; Types::BaseObject
    field :id, ID, null: false
    field :email, String, null: false
    field :first_name, String, null: true
    field :last_name, String, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
  end
end
</code></pre>

<pre><code class="language-ruby"># app/graphql/types/post_type.rb
module Types
  class PostType &lt; Types::BaseObject
    field :id, ID, null: false
    field :user_id, Integer, null: false
    field :title, String, null: false
    field :content, String, null: false
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
  end
end
</code></pre>

<h3 id="make-graphql-queries">Make GraphQL Queries</h3>

<p>So far, we have some seed data in the database.
The next step is to make GraphQL queries.</p>

<p>GraphQL query schema is defined in <code>app/graphql/types/query_type.rb</code>, which has been generated when GraphQL Ruby gem was installed.
As we see “testField” in the above section, all query definitions should be in the query_type.rb.</p>

<p>GraphQL examples out there often write every query implementation in the query_type.rb.
It’s OK if the API is as simple as examples.
However, that might end up in adding bunch of methods in a single file in an actual application.
A concern is, the code will have poor readability and/or maintainability.
As far as I searched online, it looks no decisive solution exists for this.
What I found is a GraphQL Ruby’s Resolver (<a href="https://graphql-ruby.org/fields/resolvers.html">https://graphql-ruby.org/fields/resolvers.html</a>).
Although GraphQL Ruby team wants people to avoid Resolver, it is a good way to decouple each type’s query implementation.
For that reason, the Resolver is used here.</p>

<h4 id="define-resolvers">Define Resolvers</h4>

<p>Queries to be implemented are:</p>
<ul>
  <li>a single user query, parameter: user id</li>
  <li>all users query, parameter: none</li>
  <li>multiple posts query, parameter: none – all posts, user id – one user’s all posts</li>
</ul>

<p>The implementations of resolvers for those queries are defined:</p>

<pre><code class="language-ruby"># app/graphql/resolvers/user_resolver.rb
module Resolvers
  class UserResolver &lt; GraphQL::Schema::Resolver
    type Types::UserType, null: false

    argument :id, Int, required: true

    def resolve(id:)
      User.find(id)
    end
  end
end
</code></pre>

<pre><code class="language-ruby"># app/graphql/resolvers/user_collection_resolver.rb
module Resolvers
  class UserCollectionResolver &lt; GraphQL::Schema::Resolver
    type [Types::UserType], null: false

    def resolve(**kwargs)
      User.all
    end
  end
end
</code></pre>

<pre><code class="language-ruby"># app/graphql/resolvers/post_collection_resolver.rb
module Resolvers
  class PostCollectionResolver &lt; GraphQL::Schema::Resolver
    type [Types::PostType], null: false

    argument :user_id, Int, required: false

    def resolve(**kwargs)
      if kwargs[:user_id]
        Post.where(user: kwargs[:user_id]).all
      else
        Post.all
      end
    end
  end
end
</code></pre>

<p>Above three resolvers should be referenced in the query_type.rb.
Now query_type.rb becomes below:</p>
<pre><code class="language-ruby"># app/graphql/types/query_type.rb
module Types
  class QueryType &lt; Types::BaseObject
    # Add `node(id: ID!) and `nodes(ids: [ID!]!)`
    include GraphQL::Types::Relay::HasNodeField
    include GraphQL::Types::Relay::HasNodesField

    # Add root-level fields here.
    # They will be entry points for queries on your schema.
    field :user, resolver: Resolvers::UserResolver
    field :users, resolver: Resolvers::UserCollectionResolver
    field :posts, resolver: Resolvers::PostCollectionResolver
  end
end
</code></pre>

<h4 id="queries-on-graphiql">Queries on GraphiQL</h4>

<p>We are ready to test newly defined queries.
On GraphiQL desktop app, Command + w will delete the tab and initialize UI.
Input http://localhost:3000/graphql in the Endpoint text field and hit the return key.
The updated schema is pulled, which is displayed in the Docs pane.</p>

<p>To get all users, the query is simple.</p>
<pre><code class="language-graphql">{
	users {
    id
    email
    firstName
    lastName
  }
}
</code></pre>
<p><img src="http://localhost:4000/assets/img/graphiql-users-query.jpeg" alt="graphiql users query" /></p>

<p>To get one user using user’s id, the query needs a parameter.
The simple form is to write id in the query.</p>
<pre><code class="language-graphql">{
  user(id: 1) {
    id
    email
  }
}
</code></pre>

<p>Another form is to use a query variable. In this case, the query needs additional info about the variable.</p>
<pre><code class="language-graphql">query user($uid: Int!) {
  user(id: $uid) {
    id
    email
  }
}
</code></pre>
<p>Then, pass the variable in the query variables pane.</p>
<pre><code class="language-graphql">{
  "uid": 1
}
</code></pre>
<p><img src="http://localhost:4000/assets/img/graphiql-user-with-id-query.jpeg" alt="graphiql user with id query" /></p>

<p>For post queries, with/without user id are defined.
If the user id is not provided, the query gets all posts.</p>

<pre><code class="language-graphql">{
  posts {
    id
    userId
    title
    content
  }
}
</code></pre>

<p>If the user id is given, the query retrieves the specified user’s all posts.</p>

<pre><code class="language-graphql">query posts($uid: Int) {
  posts(userId: $uid) {
    id
    userId
    title
    content
  }
}
</code></pre>

<pre><code class="language-grapql">{
  "uid": 2
}
</code></pre>
<p><img src="http://localhost:4000/assets/img/graphiql-posts-query.jpeg" alt="graphiql posts query" /></p>

<h3 id="create-a-new-resource-by-mutation">Create a New Resource by Mutation</h3>

<p>GraphQL calls “mutation” to create/update/delete operations over resources.
Like queries, mutations need a definition for each types.</p>

<h4 id="user-and-post-mutations">User and Post Mutations</h4>

<p>GraphQL Ruby provides a mutation generator. It still needs to edit, however, the generator cuts down the amount of coding.
Run the command below to create user and post mutation definitions:</p>
<pre><code class="language-bash">$ rails g graphql:mutation_create user
$ rails g graphql:mutation_create post
</code></pre>

<p>After editing two mutations, those look like below:</p>
<pre><code class="language-ruby"># app/graphql/mutations/user_create.rb
module Mutations
  class UserCreate &lt; BaseMutation
    description "Creates a new user"

    field :user, Types::UserType, null: false

    argument :email, String, required: true
    argument :first_name, String, required: false
    argument :last_name, String, required: false

    def resolve(**kwargs)
      user = ::User.new(**kwargs)
      raise GraphQL::ExecutionError.new "Error creating user", extensions: user.errors.to_hash unless user.save

      { user: user }
    end
  end
end
</code></pre>

<pre><code class="language-ruby"># app/graphql/mutations/post_create.rb
module Mutations
  class PostCreate &lt; BaseMutation
    description "Creates a new post"

    field :post, Types::PostType, null: false

    argument :user_id, Integer, required: true
    argument :title, String, required: true
    argument :content, String, required: true

    def resolve(**kwargs)
      post = ::Post.new(**kwargs)
      raise GraphQL::ExecutionError.new "Error creating post", extensions: post.errors.to_hash unless post.save

      { post: post }
    end
  end
end
</code></pre>

<p>GraphQL Ruby generator has already updated <code>app/graphql/types/mutation_type.rb</code>, so we don’t need to edit this file.
For now, mutation type definition is like this:</p>

<pre><code class="language-ruby"># app/graphql/types/mutation_type.rb
module Types
  class MutationType &lt; Types::BaseObject
    field :post_create, mutation: Mutations::PostCreate
    field :user_create, mutation: Mutations::UserCreate
  end
end
</code></pre>

<h4 id="mutations-on-graphiql">Mutations on GraphiQL</h4>

<p>Everything is ready.
It’s time to create a user and post.
The mutations look like below:</p>

<pre><code class="language-graphql">mutation {
  userCreate(input: {
    email: "alice.jones@example.com",
    firstName: "Alice",
    lastName: "Jones"
  }) {
    user {
      id
      email
    }
  }
}
</code></pre>

<pre><code class="language-graphql">mutation {
  postCreate(input: {
    userId: 3,
    title: "Hello World!",
    content: "Hey, I made it to this world!"
  }) {
    post {
      id
      userId
      title
      content
    }
  }
}
</code></pre>

<p>After executing create user and post mutations, check the result by GraphQL queries we tried above.
A new user, posts should be created.
The Rails console is another way to test newly added user and post.</p>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[GraphQL is an API standard to provide resources on the server-side to various types of clients. GraphQL itself is a specification and doesn’t provide an implementation. For Ruby on Rails, GraphQL Ruby https://graphql-ruby.org/ is the most popular library.]]></summary></entry><entry><title type="html">Rails App Creation with Options</title><link href="http://localhost:4000/2023/03/05/rails-app-creation-with-options.html" rel="alternate" type="text/html" title="Rails App Creation with Options" /><published>2023-03-05T15:50:00+09:00</published><updated>2023-03-05T15:50:00+09:00</updated><id>http://localhost:4000/2023/03/05/rails-app-creation-with-options</id><content type="html" xml:base="http://localhost:4000/2023/03/05/rails-app-creation-with-options.html"><![CDATA[<p>The easiest way to create a Ruby on Rails app is absolutely to hit the command:</p>

<pre><code class="language-bash">rails new [APP_NAME]
</code></pre>

<p>Above generates files to develop an entry level app to high end complicated app.
It’s pretty handy.</p>

<p>However, that one-size-fits-all like command does too much often.
Basically, Ruby on Rails is a gorgeous web framework which provides every feature these days’ web application needs.
In reality, people might want to create a few pages with a database backend.
Other people might want to create just an API server.
To answer such various needs, Ruby on Rails has a lot of options to create an app — really a lot!</p>

<p>We can see all options by hitting the command below outside of a rails app directory.</p>

<pre><code class="language-bash">rails -h
# or 
rails --help
</code></pre>

<p>You’ll see a bunch of options showing up with descriptions.
The problem is, those descriptions are not always clear enough.
Besides, options change as Ruby on Rails version goes up.</p>

<p>To start using Rails 7, I did some googling to figure out what all those options are about.
This is a memo what I learned from my research.</p>

<h3 id="list-of-options">List of options</h3>

<p>Here’s an excerpt of <code>rails new</code> options of Ruby on Rails 7.
The list doesn’t have all.
I focused on something not clear enough.
The description column is what <code>rails --help</code> command prints out.
The additional info columns is what I added with my understanding.</p>

<table>
  <thead>
    <tr>
      <th>option</th>
      <th>short</th>
      <th>description</th>
      <th>additional info</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>–skip-namespace</td>
      <td> </td>
      <td>Skip namespace (affects only isolated engines)</td>
      <td>When a rails engine is created by rails new plugin command, the option has a meaning.</td>
    </tr>
    <tr>
      <td>–skip-collision-check</td>
      <td> </td>
      <td>Skip collision check</td>
      <td>When rails generate command modifies existing controller/model/view, the option has a meaning.</td>
    </tr>
    <tr>
      <td>–skip-git</td>
      <td>-G</td>
      <td>Skip .gitignore file</td>
      <td>The option skips creating .git, .gitignore and .gitattributes files.</td>
    </tr>
    <tr>
      <td>–skip-keeps</td>
      <td> </td>
      <td>Skip source control .keep files</td>
      <td>The .keep file is for git to track empty directories. The option skips creating .keep file.</td>
    </tr>
    <tr>
      <td>–skip-action-mailer</td>
      <td>-M</td>
      <td>Skip Action Mailer files</td>
      <td>The Action Mailer is used to send email from Rails app. The option skips the feature.</td>
    </tr>
    <tr>
      <td>–skip-action-mailbox</td>
      <td> </td>
      <td>Skip Action Mailbox gem</td>
      <td>The Action Mailbox routes incoming email to a controller. The option skips the feature.</td>
    </tr>
    <tr>
      <td>–skip-action-text</td>
      <td> </td>
      <td>Skip Action Text gem</td>
      <td>The Action Text handles a rich text content. The option skips the feature.</td>
    </tr>
    <tr>
      <td>–skip-active-record</td>
      <td>-O</td>
      <td>Skip Active Record files</td>
      <td>The Active Record provides models to interact with applications’ database</td>
    </tr>
    <tr>
      <td>–skip-active-job</td>
      <td> </td>
      <td>Skip Active Job</td>
      <td>The Active Job is a framework for a background job. The option skips the feature.</td>
    </tr>
    <tr>
      <td>–skip-active-storage</td>
      <td> </td>
      <td>Skip Active Storage files</td>
      <td>The Active Storage provides a feature to upload files to cloud storages such as AWS S3.</td>
    </tr>
    <tr>
      <td>–skip-action-cable</td>
      <td>-C</td>
      <td>Skip Action Cable files</td>
      <td>The Action Cable integrates the websockets. The option skips the feature.</td>
    </tr>
    <tr>
      <td>–skip-asset-pipeline</td>
      <td>-A</td>
      <td>Indicates when to generate skip asset pipeline</td>
      <td>The asset pipeline concatenates and minifies Javascript and CSS and is provided by sprockets. The option skips the feature.</td>
    </tr>
    <tr>
      <td>–skip-javascript</td>
      <td>-J</td>
      <td>Skip JavaScript files</td>
      <td>The option skips creating app/javascript directory. It’s useful when front-end app is separated from Rails.</td>
    </tr>
    <tr>
      <td>–skip-hotwire</td>
      <td> </td>
      <td>Skip Hotwire integration</td>
      <td>Hotwire is a default front-end framework for Rails and is a combination of Stimulus and Turbo. The option skips the feature.</td>
    </tr>
    <tr>
      <td>–skip-jbuilder</td>
      <td> </td>
      <td>Skip jbuilder gem</td>
      <td>Jbuilder is a JSON builder and provides a DSL to declare JSON structures.</td>
    </tr>
    <tr>
      <td>–skip-test</td>
      <td>-T</td>
      <td>Skip test files</td>
      <td>The option skips to generate unit test files. When RSpec will be used, specify this option.</td>
    </tr>
    <tr>
      <td>–skip-system-test</td>
      <td> </td>
      <td>Skip system test files</td>
      <td>The option skips to generate system test files which allow to test JavaScript functionalities.</td>
    </tr>
    <tr>
      <td>–skip-bootsnap</td>
      <td> </td>
      <td>Skip bootsnap gem</td>
      <td>The option skips bootsnap which optimizes and caches expensive computations for Ruby and Active Support.</td>
    </tr>
    <tr>
      <td>–skip-bundle</td>
      <td>-B</td>
      <td>Don’t run bundle install</td>
      <td>The option skips to run bundle install when the Rails app is created.</td>
    </tr>
    <tr>
      <td>–template=TEMPLATE</td>
      <td>-m</td>
      <td>Path to some application template (can be a filesystem path or URL)</td>
      <td>The TEMPLATE file configures gems to integrate in Rails’ Gemfile.</td>
    </tr>
    <tr>
      <td>–rc=RC</td>
      <td> </td>
      <td>Path to file containing extra configuration options for rails command</td>
      <td>The RC file is ~/.railsrc which has a list of options to run rails new command.</td>
    </tr>
    <tr>
      <td>–javascript=JAVASCRIPT</td>
      <td>-j</td>
      <td>Choose JavaScript approach [options: importmap (default), webpack, esbuild, rollup]</td>
      <td>The option specifies how to handle and bundle JavaScript files.</td>
    </tr>
    <tr>
      <td>–css=CSS</td>
      <td>-c</td>
      <td>Choose CSS processor [options: tailwind, bootstrap, bulma, postcss, sass. check https://github.com/rails/cssbundling-rails</td>
      <td>The option specifies a CSS framework.</td>
    </tr>
    <tr>
      <td>–asset-pipeline=ASSET_PIPELINE</td>
      <td>-a</td>
      <td>Choose your asset pipeline [options: sprockets (default), propshaft]</td>
      <td>The option specifies an asset pipeline library, legacy Sprockets or newer Propshaft.</td>
    </tr>
    <tr>
      <td>–database=DATABASE</td>
      <td>-d</td>
      <td>Preconfigure for selected database (options: mysql/postgresql/sqlite3/oracle/sqlserver/jdbcmysql/jdbcsqlite3/jdbcpostgresql/jdbc)</td>
      <td>The option specifies a database. Options start from jdbc are for JRuby.</td>
    </tr>
    <tr>
      <td>–api</td>
      <td> </td>
      <td>Preconfigure smaller stack for API only apps</td>
      <td>The option skips to create app/assets and etc directories which won’t be used in API only app.</td>
    </tr>
    <tr>
      <td>–minimal</td>
      <td> </td>
      <td>Preconfigure a minimal rails app</td>
      <td>The option creates a minimal Rails app with active record and a few more features.</td>
    </tr>
  </tbody>
</table>

<h3 id="front-end-options">Front-end Options</h3>

<p>Among <code>rails new</code> options, front-end related might draw your eyes.
Those are:</p>
<ul>
  <li>–skip-asset-pipeline</li>
  <li>–skip-javascript</li>
  <li>–skip-hotwire</li>
  <li>–javascript=JAVASCRIPT</li>
  <li>–css=CSS</li>
  <li>–asset-pipeline=ASSET_PIPELINE</li>
</ul>

<p>One thing I should mention is that the <code>--webpack</code> option is not there.
That’s because Webpacker has been retired as described in the GitHub repo <a href="https://github.com/rails/webpacker">https://github.com/rails/webpacker</a>.
The feasible replacement of Webpacker would be importmap or esbuild, which can be specified by the <code>--javascript=JAVASCRIPT</code> option.
Both importmap and esbuild are for a rick client such as React.
The importmap is specifically for Rails freed from npm or yarn, while esbuild is a tool of JavaScript world.</p>

<p>Another option I should mention is <code>--skip-hotwire</code>. To specify this option or not, we should understand what is Hotwire.
Hotwire was introduced in Ruby on Rails 7, and is a default front-end framework.
Not like React, Hotwire is a server-rendered type framework.
Hotwire avoids odds related to a rich client such as bundling, the first loading time, JavaScript framework chaos or other.
Whether you will stick to the JavaScript world to develop front-end code or not, it’s your choice.</p>

<p>One more options to look at is <code>--asset-pipeline=ASSET_PIPELINE</code>. The asset pipeline got a choice of Propshaft.
Propshaft is a kind of simplified Sprockets and workd with jsbundling-rails ans cssbundling-rails gems.
Its GitHub repo, <a href="https://github.com/rails/propshaft">https://github.com/rails/propshaft</a>, explains details.</p>

<h3 id="options-for-simplicity">Options for Simplicity</h3>

<p>You might think Ruby on Rails is too gorgeous to do just this, so better look at other frameworks.
In such a case, two options might help:</p>
<ul>
  <li>–api</li>
  <li>–minimal</li>
</ul>

<p>To develop an API server which doesn’t need any front-end stuff, <code>--api</code> option works.
When the option is given, <code>rails new</code> command strips out many features and creates a much smaller stack with necessities for an API server.</p>

<p>The <code>--minimal</code> option is interesting.
When the option is specified, <code>rails new</code> command creates a bare minimal web app stack.
It has features of database access, assets access, and just a couple more.</p>

<h3 id="dry-options">DRY Options</h3>

<p>OKey, we learned <code>rails new</code> options, so now, it’s time to create a Rails app.
Well, let’s specify this option, that option, those options and …
You might end up with typing long, long line to create the app.
When you hit return key, you might find a typo in one of options.
It might be a case that you repeat creating Rails apps for multiple projects with the same set of options.</p>

<p>Yes, Rails provides DRY, don’t repeat yourself, way:</p>
<ul>
  <li>–rc=RC</li>
  <li>–template=TEMPLATE</li>
</ul>

<p>The rc file is, like a .bashrc or .zshrc, ~/.railsrc by default.
If the location is not under the home directory and/or has a different file name, use <code>--rc=RC</code> option to point it.
The format of rc file is a list of options one in each line. For example,</p>

<pre><code>--api
-d postgresql
</code></pre>

<p>Adding extra gem might repeat in multiple projects, for example, rspec-rails gem.
For a DRY way, <code>--template=TEMPLATE</code> option is there.
Create a template file, <code>template.rb</code>, in general. The file name can be any, though.
Then, specify the template file using –template option.
The format is similar to Gemfile. For example:</p>

<pre><code class="language-ruby">gem_group :development, :test do
  gem 'rspec-rails', '~&gt; 6.0', '&gt;= 6.0.1'
end
</code></pre>

<p>So, now, <code>.railsrc</code> file looks like below:</p>

<pre><code>--api
-d postgresql
-T
-m /path/to/template.rb
</code></pre>

<p>Once, all are ready, hit <code>rails new app_name</code> command.
The Rails app with the desired configurations will be created.</p>]]></content><author><name>Yoko Harada</name></author><summary type="html"><![CDATA[The easiest way to create a Ruby on Rails app is absolutely to hit the command:]]></summary></entry></feed>