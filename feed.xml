<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-06-06T20:01:44+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">yokolet’s notelets</title><subtitle>Blog site mostly for programming topics.</subtitle><entry><title type="html">OAuth2 PKCE With Rails 7, React/Redux and esbuild</title><link href="http://localhost:4000/2023/06/05/oauth2-pkce-with-rails-7-react-redux-and-esbuild.html" rel="alternate" type="text/html" title="OAuth2 PKCE With Rails 7, React/Redux and esbuild" /><published>2023-06-05T22:47:00+09:00</published><updated>2023-06-05T22:47:00+09:00</updated><id>http://localhost:4000/2023/06/05/oauth2-pkce-with-rails-7-react-redux-and-esbuild</id><content type="html" xml:base="http://localhost:4000/2023/06/05/oauth2-pkce-with-rails-7-react-redux-and-esbuild.html">&lt;p&gt;Logging in to a web site is what users do quite a lot.
Suppose it is a blog site.
Once a user completes a log-in process, the user is allowed to create a new post, update contents and delete a post.
The blog site might have a feature to leave comments by logged in users.&lt;/p&gt;

&lt;p&gt;The login process is categorized roughly two types: use the login feature implemented in the web site or
the social login such as Twitter, GitHub, Google, etc.
For a Rails app, implementing a local login feature is not difficult since it can use an established gem called devise.
The Rails app has a choice to use a gem called OmniAuth for the social login
if the front-end is a legacy, server rendered app.&lt;/p&gt;

&lt;p&gt;However, we see a lot of rich clients built by ReactJS, Angular, Vue.js or such.
The client app is, sometime, called SPA (Single-Page Application).
Such sort of client app initiates the login process itself.
The social login becomes complicated.
The problem of the social login by SPA is that the app ends up revealing a social login secret parameter.&lt;/p&gt;

&lt;p&gt;The Authorization Code Flow, which is a commonly used grant type defined in OAuth2, uses the client id and client secret
provided by the authorization endpoint (Twitter, GitHub, Google, etc).
From a nature of JavaScript code, the client secret is mixed in to a bundled JavaScript code as is.
It might be minified, so very hard to find.
Even though, a reverse engineering would identify the client secret.&lt;/p&gt;

&lt;p&gt;To solve such potentially risky issue, the Authorization Code Flow had an extension called Proof Key for Code Exchange.
In short, it is referred as PKCE (pronounced “pixy”).
The PKCE uses a code verifier and code challenge instead of the client secret on the client app side.
The code verifier is a randomly generated string,
while the code challenge is generated by a specified algorithm using the code verifier as a seed.
During multiple interactions with the authorization endpoint,
one of code challenge or code verifier is used in a single interaction.
The client secret is still used on the server app side.
However, the server app can easily protect such secret parameters.&lt;/p&gt;

&lt;p&gt;This way, SPA can perform a secure social login.&lt;/p&gt;

&lt;h3 id=&quot;how-authorization-code-flow-with-proof-key-for-code-exchange-pkce-works&quot;&gt;How Authorization Code Flow with Proof Key for Code Exchange (PKCE) Works&lt;/h3&gt;

&lt;p&gt;The flow is complicated.
Multiple actors are involved in.
To make it clear, let’s start off from who are those actors.&lt;/p&gt;

&lt;h4 id=&quot;actors&quot;&gt;Actors&lt;/h4&gt;

&lt;p&gt;The actors involved in the PKCE are below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;User: human, who wants to be authenticated by a social login.&lt;/li&gt;
  &lt;li&gt;SPA: client side app.&lt;/li&gt;
  &lt;li&gt;Rails: server side app.&lt;/li&gt;
  &lt;li&gt;Auth Endpoint: social login such as Twitter, GitHub, Google, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pkce-flow&quot;&gt;PKCE Flow&lt;/h4&gt;

&lt;p&gt;With above actors, the PKCE flow in this example works like below:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SPA to User: show Login Button which is a link to social login with code challenge and client id&lt;/li&gt;
  &lt;li&gt;User to Auth Endpoint: click the button&lt;/li&gt;
  &lt;li&gt;Auth Endpoint to User: show the login page if the user is not logged in&lt;/li&gt;
  &lt;li&gt;User to Auth Endpoint: input username (or email, phone number, etc) and password, then click a login button&lt;/li&gt;
  &lt;li&gt;Auth Endpoint to User: show the Authorize app button with the information about Rails app&lt;/li&gt;
  &lt;li&gt;User to Auth Endpoint: click the Authorize app button&lt;/li&gt;
  &lt;li&gt;Auth Endpoint to Rails: redirect to Rails app with a code parameter&lt;/li&gt;
  &lt;li&gt;Rails to Auth Endpoint: make a request to get an access token with the code parameter, code verifier, client id/secret&lt;/li&gt;
  &lt;li&gt;Auth Endpoint to Rails: return the access token&lt;/li&gt;
  &lt;li&gt;Rails to Auth Endpoint: make a request to get a user profile with the access token&lt;/li&gt;
  &lt;li&gt;Rails to SPA: redirect to SPA’s page with the access token&lt;/li&gt;
  &lt;li&gt;SPA to Rails: make a request to know who is the user with the access token&lt;/li&gt;
  &lt;li&gt;Rails to SPA: return the user profile&lt;/li&gt;
  &lt;li&gt;SPA to User: show the user profile&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;example-application&quot;&gt;Example Application&lt;/h3&gt;

&lt;p&gt;Versions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ruby: 3.2.2&lt;/li&gt;
  &lt;li&gt;Rails: 7.0.5&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Source Code:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild&quot;&gt;https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we learned the basic idea about PKCE, it’s time to implement.
For an example application, the client app is created by ReactJS (TypeScript), Redux Toolkit and Chakra UI.
The server side is created by Ruby on Rails with esbuild setup.&lt;/p&gt;

&lt;p&gt;Although ReactJS and Rails have libraries for PKCE, the example app implements the flow from scratch.
It is a good way to understand how PKCE works.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For details about creating Rails and ReactJS apps with esbuild setting, please see the previous post:
&lt;a href=&quot;/2023/05/23/rails-7-react-redux-development-with-esbuild.html&quot;&gt;Rails 7 React/Redux Development with esbuild&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;setup-twitter-social-login&quot;&gt;Setup Twitter Social Login&lt;/h4&gt;

&lt;p&gt;The example app uses Twitter OAuth2 login.
Go to Twitter’s &lt;a href=&quot;https://developer.twitter.com/en/portal/dashboard&quot;&gt;Developer Portal&lt;/a&gt; and create an app.
The Callback URI / Redirect URL should have “www” in the URL.
This example sets “http://www.localhost:3000/oauth/twitter” for the redirect URL.&lt;/p&gt;

&lt;h4 id=&quot;server-app&quot;&gt;Server App&lt;/h4&gt;

&lt;p&gt;The first step is to create Rails app.
Then, add the faraday gem to make HTTP request to the authorization endpoint.
Also, add the jwt gem to sign the access token with some more additional info.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails new [APP NAME] -j esbuild -T
% cd [APP NAME]
% bundle add faraday
% bundle add jwt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a user model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails g model User username:string name:string provider:integer pid:string
% rails db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The provider here means how the user is authenticated.
It is an enum field, so the data type is integer.
The pid is an id returned from the authorization endpoint.
This example app treats username as a unique field, so it needs additional migration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails g migration add_index_to_users_username
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit, db/migrate/[DATE TIME]_add_index_to_users_username.rb&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# db/migrate/[DATE TIME]_add_index_to_users_username.rb

class AddIndexToUsersUsername &amp;lt; ActiveRecord::Migration[7.0]
  def change
    add_index :users, :username, unique: true
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, run&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit, app/models/user.rb to define the provider enum type and add the username constraint of uniqueness.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/user.rb

class User &amp;lt; ApplicationRecord
  enum provider: [:local, :twitter]

  validates :username, uniqueness: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Coming to a controller part, the first one is to create an entry point for the client app.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails g stimulus client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create another controller to mount the client app.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails g controller pages home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit app/views/pages/home.html.erb to add the div tag with id=root as the mount point.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;%# app/views/pages/home.html.erb %&amp;gt;

&amp;lt;h1&amp;gt;Pages#home&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;Find me in app/views/pages/home.html.erb&amp;lt;/p&amp;gt;
&amp;lt;%= content_tag(:div, &quot;&quot;, id:&quot;root&quot;, data:{ controller: &quot;client&quot; }) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit config/routes.rb to make the pages#home to the root route.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/routes.rb

Rails.application.routes.draw do
  root &apos;pages#home&apos;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a controller for the redirect URL.
The URL should be “http://www.localhost:3000/oauth/twitter” as it is set at Twitter Developer Portal.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails g controller oauth twitter --skip-template-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The oauth controller will have a core logic explained in the PKCE Flow section.
Among the steps, the oauth controller does step from 7 to 11.
Let’s get back for the PKCE implementation later.&lt;/p&gt;

&lt;p&gt;Lastly, create a controller for the me query.
The me query is used to fetch the profile of the currently authenticated user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails g controller me --skip-template-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The controller implementation will be discussed later, so for now, add profile method to create a route.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/me_controller.rb

class MeController &amp;lt; ApplicationController
  def profile
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit config/routes.rb to create a path to the me query.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/routes.rb

Rails.application.routes.draw do
  get &apos;oauth/twitter&apos;
  root &apos;pages#home&apos;
  get &apos;me&apos;, action: :profile, controller: &apos;me&apos;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;client-app&quot;&gt;Client App&lt;/h4&gt;

&lt;p&gt;The client app takes a typical Redux Toolkit directory structure described below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;app/javascript
├── App.tsx
├── app
│   ├── hooks.ts
│   └── store.ts
├── application.js
├── controllers
│   ├── application.js
│   ├── client_controller.js
│   └── index.js
├── features
│   ├── auth
│   │   └── authSlice.ts
│   └── twitter
│       ├── TwitterLogin.tsx
│       ├── TwitterProfile.tsx
│       └── twitterSlice.ts
└── utils
    ├── hashUtils.ts
    └── twitterOauthConfig.ts

7 directories, 13 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;environment-variable-setup&quot;&gt;Environment Variable Setup&lt;/h5&gt;

&lt;p&gt;This is a setup for environment variables for SPA.
In general, the dotenv is used for such purpose.
However, for SPA, the dotenv is quite hard stuff to setup also not meaningful.
Since the files for the app are bundled in a single JavaScript (and stylesheets),
it depends on the build tool how the dotenv is looked up.
Additionally, the content in dotenv will be hardcoded in the built JavaScript file.&lt;/p&gt;

&lt;p&gt;For an alternative way, this example app uses settings.js file which is put in the directory where the Rails asset
pipeline sees.&lt;/p&gt;

&lt;p&gt;Create app/assets/javascripts/settings.js and write your twitter app’s client id:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// app/assets/javascripts/settings.js

var environment = {
  &quot;REACT_APP_TWITTER_CLIENT_ID&quot;: &quot;YOUR-CLIENT-ID-HERE&quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add javascripts directory in app/assets/config/manifest.js as in the last line below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//= link_tree ../images
//= link_directory ../stylesheets .css
//= link_tree ../builds
//= link_directory ../javascripts .js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, add javascript tag in app/views/layouts/application.html.erb.
The tag should come before application.js since the variables defined in settings.js will be referenced in application.js.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;%# app/views/layouts/application.html.erb %&amp;gt;

...
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;TwitterOauthPkceExample&amp;lt;/title&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&amp;gt;
    &amp;lt;%= csrf_meta_tags %&amp;gt;
    &amp;lt;%= csp_meta_tag %&amp;gt;

    &amp;lt;%= stylesheet_link_tag &quot;application&quot;, &quot;data-turbo-track&quot;: &quot;reload&quot; %&amp;gt;
    &amp;lt;%= javascript_include_tag &quot;settings&quot;, &quot;data-turbo-track&quot;: &quot;reload&quot;, defer: true %&amp;gt;
    &amp;lt;%= javascript_include_tag &quot;application&quot;, &quot;data-turbo-track&quot;: &quot;reload&quot;, defer: true %&amp;gt;
  &amp;lt;/head&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;install-packages&quot;&gt;Install Packages&lt;/h5&gt;

&lt;p&gt;At Rails app’s root directory, run yarn add command to install packages.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% yarn add react react-dom
% yarn add typescript @types/node @types/react @types/react-dom
% yarn add react-redux @reduxjs/toolkit
% yarn add @chakra-ui/react @emotion/react @emotion/styled framer-motion
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;login-button&quot;&gt;Login Button&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/TwitterLogin.tsx&quot;&gt;TwitterLogin.tsx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/utils/twitterOauthConfig.ts&quot;&gt;twitterOauthConfig.ts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first step of the PKCE is to show the login button which has a link to the authorization endpoint with necessary info.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// app/javascript/features/twitter/TwitterLogin.tsx

...
return (
  &amp;lt;VStack spacing=&quot;4&quot;&amp;gt;
    {!isLoggedIn &amp;amp;&amp;amp;
      &amp;lt;Button
        colorScheme=&apos;blue&apos;
        aria-label=&quot;Log in using OAuth 2.0&quot;
        onClick={() =&amp;gt; window.open(getTwitterOauthUrl(), &apos;_self&apos;)}
      &amp;gt;
        Log in with Twitter
      &amp;lt;/Button&amp;gt;
    }
    {isLoggedIn &amp;amp;&amp;amp;
      &amp;lt;Text&amp;gt;
        Token expiry date: {tokenExpiryDate}
      &amp;lt;/Text&amp;gt;
    }
  &amp;lt;/VStack&amp;gt;
);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The link url is created in the function defined in twitterOauthConfig.ts.
The code challenge is hardcoded in this example app.
In the real world, it should be generated by a specified algorithm.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// app/javascript/utils/twitterOauthConfig.ts

const authEndpoint = &apos;https://twitter.com/i/oauth2/authorize&apos;;

const client_id = environment.REACT_APP_TWITTER_CLIENT_ID;
const redirect_uri = &quot;http://www.localhost:3000/oauth/twitter&quot;;

export const getTwitterOauthUrl = (): string =&amp;gt; {
  // temporarily uses static code verifier and challenge
  let code_challenge = &quot;WeI7ul0uzUr0Zv89EPknzv4iNqmQuEysEtkWan7P3FA&quot;;
  let state = &quot;state&quot;;
  let scope = [&quot;users.read&quot;, &quot;tweet.read&quot;, &quot;follows.read&quot;, &quot;follows.write&quot;].join(&quot; &quot;);
  // @ts-ignore
  let args = new URLSearchParams({
    redirect_uri,
    client_id,
    state,
    response_type: &apos;code&apos;,
    code_challenge,
    code_challenge_method: &quot;S256&quot;,
    scope,
  }).toString();
  return `${authEndpoint}?${args}`;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The button looks like below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/oauth-pkce-login-button.jpeg&quot; alt=&quot;img: oauth pkce login button&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When a user (human) clicks the button, Twitter navigates to the login page if the user has not yet logged in.
If the user is already logged in, this step is skipped.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/oauth-pkce-twitter-login-page.jpeg&quot; alt=&quot;img: oauth pkce twitter login page&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After the successful login, Twitter shows the authorize app page.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/oauth-pkce-twitter-authorize-app-page.jpeg&quot; alt=&quot;img: oauth pkce twitter authorize app page&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When the user clicks the Authorize app button, Twitter redirects to the given redirect URI with the code as the URL parameter.&lt;/p&gt;

&lt;p&gt;Up here, PKCE flow’s 1 to 6 steps are completed.&lt;/p&gt;

&lt;h5 id=&quot;user-profile&quot;&gt;User Profile&lt;/h5&gt;

&lt;p&gt;Let’s assume the server side app successfully gets the access token and the user profile from Twitter.
What the server app does at this point is to redirect back to the client app.
The example here sends back access_token and token expiry as URL parameters.
Those parameters are handled by TwitterLogin.tsx and hashUtils.ts.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/TwitterLogin.tsx&quot;&gt;TwitterLogin.tsx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/utils/hashUtils.ts&quot;&gt;hashUtils.ts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// app/javascript/features/twitter/TwitterLogin.tsx
...
const { access_token, expires_in } = getOAuthParams();
removeHashParamsFromUrl();
...
useEffect(() =&amp;gt; {
  if (access_token) {
    dispatch(setLoggedIn(true));
    dispatch(setAccessToken(access_token));
    dispatch(setTokenExpiryDate(Number(expires_in)));
    dispatch(setUserProfileAsync(access_token));
  }
}, [])
...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// app/javascript/utils/hashUtils.ts
export const getOAuthParams = () =&amp;gt; {
  const urlParams = new URLSearchParams(window.location.search);
  return {
    access_token: urlParams.get(&apos;access_token&apos;),
    expires_in: urlParams.get(&apos;expires_in&apos;),
  };
}

export const removeHashParamsFromUrl = () =&amp;gt; {
  window.history.pushState(&quot;&quot;, document.title, window.location.pathname);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last line in useEffect function, &lt;code&gt;dispatch(setUserProfileAsync(access_token));&lt;/code&gt;, triggers the me query.
The function is defined in twitterSlice.ts.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/twitterSlice.ts&quot;&gt;twitterSlice.ts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// app/javascript/features/twitter/twitterSlice.ts
...
export const setUserProfileAsync = (accessToken: string): AppThunk =&amp;gt; dispatch =&amp;gt; {
  fetch(&apos;http://www.localhost:3000/me&apos;, {
    method: &apos;GET&apos;,
    headers: {
      Authorization: &apos;Bearer &apos; + accessToken,
    },
  }).then(response =&amp;gt; response.json())
    .then((data) =&amp;gt; {
      dispatch(setLoggedIn(true));
      dispatch(setName(data.name ? data.name : data.id));
      dispatch(setUsername(data.username));
    }).catch((error) =&amp;gt; {
    console.log(error);
    if (error instanceof XMLHttpRequest) {
      if (error.status === 401) {
        dispatch(setLoggedIn(false));
      }
    }
  });
};
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The client app returns the access token as is in the Authorization header.
This is the step 12 of the PKCE flow.
When the server app returns the user profile, that will be rendered in TwitterProfile.tsx.
By that, the last step, 14, of the PKCE flow completes.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/javascript/features/twitter/TwitterProfile.tsx&quot;&gt;TwitterProfile.tsx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// app/javascript/features/twitter/TwitterProfile.tsx

...
export function TwitterProfile() {
  const name = useSelector(selectName);
  const username = useSelector(selectUsername);

  return (
    &amp;lt;VStack&amp;gt;
      {name &amp;amp;&amp;amp;
        &amp;lt;Box&amp;gt;
          &amp;lt;Text&amp;gt;Logged in as: {name}&amp;lt;/Text&amp;gt;
        &amp;lt;/Box&amp;gt;}
      {username &amp;amp;&amp;amp;
        &amp;lt;Box&amp;gt;
          &amp;lt;Text&amp;gt;Username: {username}&amp;lt;/Text&amp;gt;
        &amp;lt;/Box&amp;gt;
      }
      &amp;lt;/VStack&amp;gt;
  );
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/oauth-pkce-user-profile.jpeg&quot; alt=&quot;img: oauth pkce user profile&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;core-logic-on-the-server-side-app&quot;&gt;Core Logic on the Server Side App&lt;/h4&gt;

&lt;h5 id=&quot;setup-secrets&quot;&gt;Setup Secrets&lt;/h5&gt;

&lt;p&gt;The controllers needs some secret parameters.
Before going to the controller details, setup those parameters.
Choose your favorite editor, for example, EDITOR=”code –wait”.
The vim is the choice here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% EDITOR=vim rails credentials:edit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write your JWT secret, Twitter app’s client id and client secret in the format below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-yml&quot;&gt;jwt_secret: YOUR-JWT-SECRET-HERE
twitter:
  client_id: YOUR-TWITTER-APP-CLIENT-ID-HERE
  client_secret: YOUR-TWITTER-APP-CLIENT-SECRET-HERE
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;oauthcontroller-details&quot;&gt;OauthController Details&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/controllers/oauth_controller.rb&quot;&gt;oauth_controller.rb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The OauthController performs the PKCE flow’s step from 7 to 11.
The authentication request made by the client app ends up coming to the redirect uri,
http://www.localhost:3000/oauth/twitter with the code as a URL parameter.
The controller gets the code, then makes a request to the Twitter access token endpoint with the code and other parameters.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;// app/controllers/oauth_controller.rb

...
    def twitter
        client_id = Rails.application.credentials.twitter.client_id.strip
        client_secret = Rails.application.credentials.twitter.client_secret.strip
        oauthTokenParams = {
          redirect_uri: &apos;http://www.localhost:3000/oauth/twitter&apos;,
          code: params[:code]
        }
        access_token, expires_in = getOAuthToken(&quot;https://api.twitter.com&quot;, &quot;/2/oauth2/token&quot;,
                                                 client_id, client_secret,
                                                 oauthTokenParams) 
        ...
    end
...
    def getBasicAuthToken(client_id, client_secret)
      Base64.strict_encode64(&quot;#{client_id}:#{client_secret}&quot;)
    end

    def getOAuthToken(url, path, client_id, client_secret, oauth_token_params)
      oauth_token_params = oauth_token_params.merge({
                                                      grant_type: &apos;authorization_code&apos;,
                                                      client_id: client_id,
                                                      code_verifier: CODE_VERIFIER
                                                    }))
      conn = Faraday.new(
        url: url,
        headers: {
          &apos;Content-Type&apos; =&amp;gt; &apos;application/x-www-form-urlencoded&apos;,
          &apos;Authorization&apos; =&amp;gt; &quot;Basic #{getBasicAuthToken(client_id, client_secret)}&quot;
        }
      )
      response = conn.post(path, URI.encode_www_form(oauth_token_params))
      body_obj = JSON.parse(response.body)
      [body_obj[&apos;access_token&apos;], body_obj[&apos;expires_in&apos;]]
    end
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the access token is successfully returned from Twitter, the next step is to get a user profile.
The me query to Twitter does the job.
The access token is set in the Authorization header to make the me query.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;// app/controllers/oauth_controller.rb

def twitter
    ...
    data = getUser(&quot;https://api.twitter.com&quot;, &quot;/2/users/me&quot;, access_token)
    ...
end
...
def getUser(url, path, access_token)
    conn = Faraday.new(
      url: url,
      headers: {
        &apos;Content-Type&apos; =&amp;gt; &apos;application/x-www-form-urlencoded&apos;,
        &apos;Authorization&apos; =&amp;gt; &quot;Bearer #{access_token}&quot;
      }
    )
    response = conn.get(path)
    body_obj = JSON.parse(response.body)
    body_obj[&apos;data&apos;]
end
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the server side app gets the user profile, the user is either created on or retrieved from a local database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;// app/controllers/oauth_controller.rb

def twitter
  ...
  user = getUserFromDb(
    {
      username: data[&apos;username&apos;],
      name: data[&apos;name&apos;],
      provider: User.providers[:twitter],
      pid: data[&apos;id&apos;]
    }
  )
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Almost there.
The following step is to sign access token and user info.
This example app uses user’s username and name with the access token.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;// app/controllers/oauth_controller.rb

def twitter
  ...
  signedToken = getSignedToken(access_token, user)
  ...
end
...
def getSignedToken(access_token, user)
  JWT.encode(
    {
      username: user.username,
      provider: user.provider,
      accessToken: access_token
    },
    Rails.application.credentials.jwt_secret,
    &apos;HS256&apos;
  )
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the controller redirects back to the client app with the signed access token and token’s expiry.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;// app/controllers/oauth_controller.rb

def twitter
  ...
  redirect_to(root_path(access_token: signedToken, expires_in: expires_in))
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;mecontroller-details&quot;&gt;MeController Details&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/yokolet/twitter-oauth2-pkce-rails7-react-redux-esbuild/blob/main/app/controllers/me_controller.rb&quot;&gt;me_controller.rb&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The MeController gets signed access token from the Authorization header which is sent back by the client app.
Then, the token is decoded using the same JWT secret.
The decoded token has the user info which can be verified to make a query to the local database.
The result of the database query is returned to the client app.&lt;/p&gt;

&lt;p&gt;The example app skips the access token validity check since it focuses on the PKCE flow only.
However, in a real situation, the access token should be checked.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;// app/controllers/me_controller.rb

...
class MeController &amp;lt; ApplicationController
  def profile
    payload = decodeSignedJwtToken(getBearerToken()).first
    user = User.where(provider: payload[&quot;provider&quot;], username: payload[&quot;username&quot;]).first
    render json: user
  end

  def getBearerToken
    pattern = /^Bearer /
    request.authorization.gsub(pattern, &apos;&apos;) if request.authorization
  end

  def decodeSignedJwtToken(token)
    JWT.decode(
      token,
      Rails.application.credentials.jwt_secret,
      true,
      { algorithm: &apos;HS256&apos; }
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;The example app’s purpose is to show how PKCE flow works.
So, some parts are missing.
For example, the code verifier and code challenge should be generated in each authentication process, but not.
The access token should be saved in both client and server apps and re-requested when the token is expired.
The example app skips that as well.&lt;/p&gt;

&lt;p&gt;Even though, the example app would help to understand how the PKCE flow works between React app, Rails app and
Authorization endpoint.&lt;/p&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;
&lt;h4 id=&quot;proof-key-for-code-exchange&quot;&gt;Proof Key for Code Exchange&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://oauth.net/2/pkce/&quot;&gt;RFC 7636: Proof Key for Code Exchange&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.miniorange.com/auth-flow-with-pkce/&quot;&gt;Authorization Code Flow with Proof Key for Code Exchange (PKCE)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hceris.com/oauth-authorization-code-flow-pkce-for-react/&quot;&gt;Authorization Code Flow with PKCE (OAuth) in a React application&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.twitter.com/en/docs/authentication/oauth-2-0/authorization-code&quot;&gt;Twitter Documentation: Authentication&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.spotify.com/documentation/web-api/tutorials/code-pkce-flow&quot;&gt;Spotify for Developers: Authorization Code with PKCE Flow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;implementation&quot;&gt;Implementation&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.to/reinforz/implementing-authentication-with-twitter-oauth-20-using-typescript-node-js-express-js-and-next-js-in-a-full-stack-application-353d&quot;&gt;Implementing Authentication with Twitter OAuth 2.0 using Typescript, Express.js and Next.js&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/swlh/create-a-react-app-with-typescript-redux-and-oauth-2-0-7f62d57890df&quot;&gt;Create a React App with TS, Redux and OAuth 2.0 - Spotify login example&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.to/sbelzile/stop-using-dotenv-in-your-front-end-427p&quot;&gt;Stop using Dotenv in your front-end&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Yoko Harada</name></author><summary type="html">Logging in to a web site is what users do quite a lot. Suppose it is a blog site. Once a user completes a log-in process, the user is allowed to create a new post, update contents and delete a post. The blog site might have a feature to leave comments by logged in users.</summary></entry><entry><title type="html">Rails 7 React/Redux Development with esbuild</title><link href="http://localhost:4000/2023/05/23/rails-7-react-redux-development-with-esbuild.html" rel="alternate" type="text/html" title="Rails 7 React/Redux Development with esbuild" /><published>2023-05-23T21:47:00+09:00</published><updated>2023-05-23T21:47:00+09:00</updated><id>http://localhost:4000/2023/05/23/rails-7-react-redux-development-with-esbuild</id><content type="html" xml:base="http://localhost:4000/2023/05/23/rails-7-react-redux-development-with-esbuild.html">&lt;p&gt;Rails 7 provides a couple of approaches to bundle a rich JavaScript application such as SPA.
To create the JavaScript application, we should specify &lt;code&gt;j|--javascript&lt;/code&gt; option with
importmap (default), webpack, esbuild or rollup when &lt;code&gt;rails new&lt;/code&gt; command gets run.
Although webpack is still among the choices, it has been retired as describe in the
&lt;a href=&quot;https://github.com/rails/webpacker/blob/master/README.md&quot;&gt;https://github.com/rails/webpacker/blob/master/README.md&lt;/a&gt;.
The choice here is &lt;a href=&quot;https://esbuild.github.io/&quot;&gt;esbuild&lt;/a&gt; since it is friendly to JavaScript development,
for example, starting from &lt;code&gt;yarn create react-app ...&lt;/code&gt;.
The esbuild is gaining popularity and known to run very fast with its Go-lang implementation.&lt;/p&gt;

&lt;p&gt;This blog post creates React/Redux application on top of Rails 7.
The application is a sample counter app which comes from what &lt;code&gt;yarn create react-app [app name] --template redux-typescript&lt;/code&gt;
command creates.&lt;/p&gt;

&lt;h3 id=&quot;create-a-rails-app-with-esbuild-option&quot;&gt;Create a Rails App with esbuild Option&lt;/h3&gt;

&lt;p&gt;The command to create an app is something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails new [APP NAME] -j esbuild -T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-j esbuild&lt;/code&gt; option installs frontend development packages/tools.
Additionally, the command, &lt;code&gt;./bin/rails javascript:install:esbuild&lt;/code&gt;, gets run during the app creation.
The package.json, Procfile.dev and couple other files for JavaScript development are also created.&lt;/p&gt;

&lt;h3 id=&quot;create-an-entry-point-for-reactjs-app&quot;&gt;Create an Entry Point for ReactJS App&lt;/h3&gt;

&lt;p&gt;The next step is to create and entry point for ReactJS app.
All incoming HTTP requests are received by controllers on Rails.
Following such Rails style, the entry point to ReactJS app is also a controller.
However, instead of &lt;code&gt;rails g controller ...&lt;/code&gt;, stimulus generator is used for this.
The generated controller is a JavaScript class, which is a subclass of stimulus Controller.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails g stimulus react
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above generates &lt;code&gt;app/javascript/controllers/react_controller.js&lt;/code&gt; and updates &lt;code&gt;app/javascript/controllers/index.js&lt;/code&gt;.
The generated controller class is equivalent to ReactJS app’s index.tsx(jsx).
What we write in index.tsx should go to a connect method in the generated controller class.&lt;/p&gt;

&lt;h3 id=&quot;create-a-view-to-mount-reactjs-app&quot;&gt;Create a View to Mount ReactJS App&lt;/h3&gt;

&lt;p&gt;If the ReactJS app is created by &lt;code&gt;yarn create react-app ...&lt;/code&gt; or npm, npx command,
the app has a mount point in &lt;code&gt;public/index.html&lt;/code&gt;, something like: &lt;code&gt;&amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;.
It is Rails, so we should create a controller.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% rails g controller pages home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above creates a couple of files as we know.
Edit &lt;code&gt;app/views/pages/home.html.erb&lt;/code&gt; and add the mount point.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-erbruby&quot;&gt;&amp;lt;%# app/views/pages/home.html.erb %&amp;gt;

&amp;lt;h1&amp;gt;Pages#home&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;Find me in app/views/pages/home.html.erb&amp;lt;/p&amp;gt;
&amp;lt;%= content_tag(:div, &quot;&quot;, id:&quot;root&quot;, data:{ controller: &quot;react&quot; }) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, edit &lt;code&gt;config/routes.rb&lt;/code&gt; to add a path to pages#home.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/routes.rb

Rails.application.routes.draw do
  root &apos;pages#home&apos;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;setup-basic-react-typescript-app&quot;&gt;Setup Basic React TypeScript App&lt;/h3&gt;

&lt;p&gt;At this moment, the Rails side is ready.
However, the JavaScript side has a package.json file only, which is like right after &lt;code&gt;yarn --init&lt;/code&gt; ran.
Since it is a React TypeScript app, install basic packages.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% yarn add react react-dom @types/react @types/react-dom typescript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, TypeScript initialization should be done.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% tsc --init --project tsconfig.json --noEmit --jsx react-jsx
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;redux-toolkit-counter-example&quot;&gt;Redux Toolkit Counter Example&lt;/h3&gt;

&lt;p&gt;When the redux-typescript template is used to create a ReactJS App, the counter example comes with it.
For examples, &lt;code&gt;yarn create react-app my-app --template redux-typescript&lt;/code&gt; command creates files below
(excludes node_modules directory):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── README.md
├── package.json
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
├── src
│   ├── App.css
│   ├── App.test.tsx
│   ├── App.tsx
│   ├── app
│   │   ├── hooks.ts
│   │   └── store.ts
│   ├── features
│   │   └── counter
│   │       ├── Counter.module.css
│   │       ├── Counter.tsx
│   │       ├── counterAPI.ts
│   │       ├── counterSlice.spec.ts
│   │       └── counterSlice.ts
│   ├── index.css
│   ├── index.tsx
│   ├── logo.svg
│   ├── react-app-env.d.ts
│   ├── reportWebVitals.ts
│   └── setupTests.ts
├── tsconfig.json
└── yarn.lock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want files under src directory.
How to map those files under &lt;code&gt;app/javascript&lt;/code&gt; might be controversy.
Some might create a components directory.
However, as for Redux Toolkit, features and/or app directories are more common.&lt;/p&gt;

&lt;p&gt;The app here is created by copying files under &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;app/javascript&lt;/code&gt; almost as those are.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;app/javascript
├── App.tsx
├── app
│   ├── hooks.ts
│   └── store.ts
├── application.js
├── controllers
│   ├── application.js
│   ├── hello_controller.js
│   ├── index.js
│   └── react_controller.js
├── features
│   └── counter
│       ├── Counter.module.css
│       ├── Counter.tsx
│       ├── counterAPI.ts
│       ├── counterSlice.spec.ts
│       └── counterSlice.ts
└── logo.svg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Handling of .css files will be mentioned later since that needs a bit of fix.&lt;/p&gt;

&lt;p&gt;To run the counter app, Redux Toolkit and react binding packages should be installed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;% yarn add @reduxjs/toolkit react-redux
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;update-react_controllerjs&quot;&gt;Update react_controller.js&lt;/h3&gt;

&lt;p&gt;Previously mentioned, &lt;code&gt;app/javascript/controllers/react_controller.js&lt;/code&gt; is equivalent to ReactJS app’s index.tsx.&lt;/p&gt;

&lt;p&gt;The file looks like below to run the counter app.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-tsx&quot;&gt;// app/javascript/controllers/react_controller.js

import { Controller } from &quot;@hotwired/stimulus&quot;
import React from &apos;react&apos;;
import { createRoot } from &apos;react-dom/client&apos;;
import { Provider } from &quot;react-redux&quot;;
import App from &apos;../App&apos;;
import { store } from &apos;../app/store&apos;;

// Connects to data-controller=&quot;react&quot;
export default class extends Controller {
  connect() {
    const container = document.getElementById(&apos;root&apos;);
    const root = createRoot(container);

    root.render(
      &amp;lt;React.StrictMode&amp;gt;
        &amp;lt;Provider store={store}&amp;gt;
          &amp;lt;App /&amp;gt;
        &amp;lt;/Provider&amp;gt;
      &amp;lt;/React.StrictMode&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;update-packagejson-scripts-section&quot;&gt;Update package.json scripts section&lt;/h3&gt;

&lt;p&gt;When the Rails app is created, package.json’s scripts section looks like below.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;scripts&quot;: {
  &quot;build&quot;: &quot;esbuild app/javascript/*.* --bundle --sourcemap --outdir=app/assets/builds --public-path=assets&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As in the above directory tree, the counter app has .tsx and .svg files under app/javascript.
So that esbuild can load those, two loaders should be added to the esbuild option.&lt;/p&gt;

&lt;p&gt;Additionally, the script section should have TypeScript check.&lt;/p&gt;

&lt;p&gt;After the update, the script section looks like below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;scripts&quot;: {
  &quot;build&quot;: &quot;esbuild app/javascript/*.* --bundle --sourcemap --outdir=app/assets/builds --public-path=assets --loader:.js=jsx --loader:.svg=file&quot;,
  &quot;check-types&quot;: &quot;tsc --project tsconfig.json --noEmit --watch --preserveWatchOutput&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;avoid-sprocketsdoublelinkerror-applicationcss-error&quot;&gt;Avoid Sprockets::DoubleLinkError application.css Error&lt;/h3&gt;

&lt;p&gt;If esbuild is used in a Rails app, .css files need extra caution.
We might end up in having two application.css files generated by esbuild and originally created by &lt;code&gt;rails new&lt;/code&gt; command.
If that happens, the conflict raises the Sprockets::DoubleLinkError application.css error.&lt;/p&gt;

&lt;p&gt;When a .tsx(.jsx) file imports CSS, esbuild generates app/assets/builds/application.css.
Whereas we have app/assets/stylesheets/application.css generated by rails new command.
These two application.css files have the same name but different contents.&lt;/p&gt;

&lt;p&gt;A couple to few ways would be there to avoid the error.
Probably, below two are easy ones.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Never ever import css files in .tsx(.jsx).
Instead, write all styles in &lt;code&gt;app/assets/stylesheets/application.css&lt;/code&gt; or take a traditional Rails way.&lt;/li&gt;
  &lt;li&gt;Rename &lt;code&gt;app/assets/stylesheets/application.css&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The app here mainly took the second approach, but partially the first approach.
The &lt;code&gt;app/assets/stylesheets/application.css&lt;/code&gt; was renamed to &lt;code&gt;app/assets/stylesheets/application-rails.css&lt;/code&gt;.
The &lt;code&gt;app/views/layouts/application.html.erb&lt;/code&gt; file got one more stylesheet_link_tag shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-erbruby&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;React/Redux App&amp;lt;/title&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&amp;gt;
    &amp;lt;%= favicon_link_tag &apos;favicon.ico&apos; %&amp;gt;
    &amp;lt;%= csrf_meta_tags %&amp;gt;
    &amp;lt;%= csp_meta_tag %&amp;gt;

    &amp;lt;%= stylesheet_link_tag &quot;application&quot;, &quot;data-turbo-track&quot;: &quot;reload&quot; %&amp;gt;
    &amp;lt;%= stylesheet_link_tag &quot;application-rails&quot;, &quot;data-turbo-track&quot;: &quot;reload&quot; %&amp;gt;
    &amp;lt;%= javascript_include_tag &quot;application&quot;, &quot;data-turbo-track&quot;: &quot;reload&quot;, defer: true %&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body&amp;gt;
    &amp;lt;%= yield %&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All styles in &lt;code&gt;index.css&lt;/code&gt; and &lt;code&gt;App.css&lt;/code&gt; are moved to &lt;code&gt;app/assets/stylesheets/application-rails.css&lt;/code&gt;.
The css import was removed from &lt;code&gt;App.tsx&lt;/code&gt; and &lt;code&gt;app/javascript/controllers/react_controller.js&lt;/code&gt;.
However, &lt;code&gt;app/javascript/features/counter/Counter.module.css&lt;/code&gt; is there, which is imported in
&lt;code&gt;app/javascript/features/counter/Counter.tsx&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;use-bindev-not-rails-s&quot;&gt;Use bin/dev, not rails s&lt;/h3&gt;

&lt;p&gt;To run the Rails app, use &lt;code&gt;bin/dev&lt;/code&gt;.
As defined in &lt;code&gt;Procfile.dev&lt;/code&gt;, we need Rails server and esbuild with watch option.
The &lt;code&gt;bin/dev&lt;/code&gt; command does that.
If everything goes well, the counter app below shows up at http://localhost:3000/ .&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/react-redux-counter-app.jpeg&quot; alt=&quot;img: react redux counter app&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;The example Rails app code is on the GitHub repo.
Please see &lt;a href=&quot;https://github.com/yokolet/rails7-typescript-redux-counter-example&quot;&gt;https://github.com/yokolet/rails7-typescript-redux-counter-example&lt;/a&gt;&lt;/p&gt;</content><author><name>Yoko Harada</name></author><summary type="html">Rails 7 provides a couple of approaches to bundle a rich JavaScript application such as SPA. To create the JavaScript application, we should specify j|--javascript option with importmap (default), webpack, esbuild or rollup when rails new command gets run. Although webpack is still among the choices, it has been retired as describe in the https://github.com/rails/webpacker/blob/master/README.md. The choice here is esbuild since it is friendly to JavaScript development, for example, starting from yarn create react-app .... The esbuild is gaining popularity and known to run very fast with its Go-lang implementation.</summary></entry><entry><title type="html">Make it Secure 3, CSRF for GraphQL on Rails</title><link href="http://localhost:4000/2023/03/29/make-it-secure-3-csrf-for-graphql-on-rails.html" rel="alternate" type="text/html" title="Make it Secure 3, CSRF for GraphQL on Rails" /><published>2023-03-29T23:39:00+09:00</published><updated>2023-03-29T23:39:00+09:00</updated><id>http://localhost:4000/2023/03/29/make-it-secure-3-csrf-for-graphql-on-rails</id><content type="html" xml:base="http://localhost:4000/2023/03/29/make-it-secure-3-csrf-for-graphql-on-rails.html">&lt;p&gt;This is the third post about securing Rails GraphQL API app.
The topic is CSRF protection for GraphQL API.
CSRF is an acronym of &lt;a href=&quot;https://owasp.org/www-community/attacks/csrf&quot;&gt;Cross-Site Request Forgery&lt;/a&gt;,
and one of well-known vulnerabilities and a type of session hijack.&lt;/p&gt;

&lt;p&gt;If an attacker succeeds to hijack session, the request from the attacker looks a proper one from a victim.
The attacker is able to execute state changing operations using victim’s identity.&lt;/p&gt;

&lt;p&gt;According to the document, &lt;a href=&quot;https://guides.rubyonrails.org/security.html&quot;&gt;Securing Rails Applications&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;CSRF appears very rarely in CVE (Common Vulnerabilities and Exposures) - less than 0.1% in 2006 - but it really is
a ‘sleeping giant’ [Grossman]. This is in stark contrast to the results in many security contract works - CSRF is
an important security issue.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Above being said, we should think about CSRF protection.&lt;/p&gt;

&lt;h4 id=&quot;graphql-needs-csrf-protection&quot;&gt;GraphQL needs CSRF protection?&lt;/h4&gt;

&lt;p&gt;OK, we had a basic idea of CSRF attack.
Then, the question is whether GraphQL API needs CSRF protection or not.
If it is truly API only app, the app doesn’t use a cookie nor session at all.
There should be no session to be hijacked…
Well, developers might have a vague belief that there should be no session skipping actual HTTP response headers checks.&lt;/p&gt;

&lt;p&gt;Some GraphQL clients, such as GraphiQL, don’t handle HTTP request/response headers well.
People might miss what are passed in HTTP response headers.
In contract, Insomnia (&lt;a href=&quot;https://insomnia.rest/&quot;&gt;https://insomnia.rest/&lt;/a&gt;) or Postman (&lt;a href=&quot;https://www.postman.com/&quot;&gt;https://www.postman.com/&lt;/a&gt;)
does a good job.
Postman’s handling is awesome.
By default, Postman adds meaningful HTTP response headers to HTTP request header automatically.
Besides, those are controllable. We can choose what should be sent back with GraphQL request.
Postman is famous for REST API client, however, GraphQL support is also good.&lt;/p&gt;

&lt;p&gt;Once we check HTTP response headers returned with GraphQL query result, cookie and/or session might be found.
For example, the previous post, &lt;a href=&quot;/2023/03/23/make-it-secure-2-graphql-by-rails-and-devise.html&quot;&gt;Make it Secure 2, GraphQL by Rails and Devise&lt;/a&gt;
uses Devise for authentication.
To make it work, cookie and session setup was added to &lt;code&gt;config/application.rb&lt;/code&gt; since Devise needs that.
The Rails app was created with &lt;code&gt;--api&lt;/code&gt; option, so the addition of cookie and session was done manually.
We knew that GraphQL response would come back with the session.
If GraphQL API app is created without &lt;code&gt;--api&lt;/code&gt; option, the cookie and sessions might come back with GraphQL response unknowingly.
The blog post, &lt;a href=&quot;https://checkmarx.com/blog/whats-old-becomes-new-again-csrf-attacks-on-graphql-apis/&quot;&gt;What’s Old Becomes New Again: CSRF Attacks on GraphQL APIs&lt;/a&gt;,
mentions “misconfiguration,” which would include the case of “unknowingly.”&lt;/p&gt;

&lt;p&gt;The answer to the question, GraphQL needs CSRF protection?, depends on what gems are used.&lt;/p&gt;

&lt;h4 id=&quot;csrf-protection-setup-for-graphql&quot;&gt;CSRF Protection Setup for GraphQL&lt;/h4&gt;

&lt;p&gt;Rails provides CSRF protection out of the box, however, it is based on traditional web application.
The meta tag is used to embed CSRF token.
It uses flash UI when the session nullify option is used.
API only, GraphQL app needs tweaks to make it work.&lt;/p&gt;

&lt;h5 id=&quot;how-rails-csrf-protection-works&quot;&gt;How Rails CSRF Protection Works&lt;/h5&gt;

&lt;p&gt;Before moving on to the code, let’s revisit how traditional Rails app does for CSRF protection.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Rails app creates CSRF token&lt;/li&gt;
  &lt;li&gt;Rails app ties the CSRF token to a session&lt;/li&gt;
  &lt;li&gt;Rails app passes the CSRF token to a client using HTML meta tag with the session&lt;/li&gt;
  &lt;li&gt;A client sends back the CSRF token using X-CSRF-TOKEN HTTP request header with the session&lt;/li&gt;
  &lt;li&gt;Rails app compares the CSRF token returned as X-CSRF-TOKEN and tokens in the session&lt;/li&gt;
  &lt;li&gt;Rails app does what protect_from_forgery specifies if the token is failed to verify&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Among the steps above, API only app should do something else for step 3 and 6.
In general, the cookie is used to return a pair of CSRF-TOKEN as key and the token as value.
Using the cookie might be controversial in terms of better security.
Another way is to return the token as a part of GraphQL login/register mutation response body.
This might be better than the cookie, however, other queries and mutations lose a chance to get updated token.
It is recommended that the CSRF token should be updated in every interaction to the server.
Given that, using cookie would be an agreeable solution.&lt;/p&gt;

&lt;p&gt;When the CSRF token verification fails, three below protect_from_forgery strategies are possible behaviors.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;:exception&lt;/code&gt; – Raises ActionController::InvalidAuthenticityToken exception, which is captured in the GraphQL response body.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;:reset_session&lt;/code&gt; – Resets the session. New token will be created and returned to the client.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;:null_session&lt;/code&gt; – Provides an empty session during request. The cookies/sessions added by Devise are also deleted.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Not like REST API, GraphQL always uses HTTP POST method by design.
The HTTP methods is useless to control the protect_from_forgery strategies, so we should add a custom strategy.&lt;/p&gt;

&lt;h4 id=&quot;graphql-rails-app&quot;&gt;GraphQL Rails app&lt;/h4&gt;

&lt;p&gt;The CSRF protection will be added to the previously created mini-blog-2 app.
How to create the app is explained in
&lt;a href=&quot;/2023/03/23/make-it-secure-2-graphql-by-rails-and-devise.html&quot;&gt;Make it Secure 2, GraphQL by Rails and Devise&lt;/a&gt;.
The code is at &lt;a href=&quot;https://github.com/yokolet/mini-blog-2&quot;&gt;https://github.com/yokolet/mini-blog-2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The app uses Devise gem for a user authentication.&lt;/p&gt;

&lt;h4 id=&quot;update-for-null-session-strategy&quot;&gt;Update for null session strategy&lt;/h4&gt;

&lt;p&gt;This is to fix a flash error caused by no UI, API only setting.
This GraphQL app doesn’t use null_session strategy, but it’s good to have the update below for a future change.&lt;/p&gt;

&lt;p&gt;Add config.middleware.use ActionDispatch::Flash in config/application.rb.
The three lines for cookie and session were added when Devise authentication was set up.
The cookie and session are used for CSRF protection as well, so leave those lines as are.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/application.rb
# ...
# ...
module MiniBlog2
  class Application &amp;lt; Rails::Application
    # ...
    # ...
    config.session_store :cookie_store, key: &quot;_mini-blog-2_session_#{Rails.env}&quot;
    config.middleware.use ActionDispatch::Cookies
    config.middleware.use config.session_store, config.session_options

    # when protect_from_forgery with: :null_session is used, add blow.
    config.middleware.use ActionDispatch::Flash
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;add-method-to-create-and-set-csrf-token&quot;&gt;Add method to create and set CSRF token&lt;/h4&gt;

&lt;p&gt;As mentioned above, the CSRF token will be added to cookie.
Add set_csrf_token method in ApplicationController.
Since the Rails app is configured API only, two modules are included to use cookie and form_authenticity_token method.
The form_authenticity_token method generates a token and ties it to the session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/application_controller.rb
class ApplicationController &amp;lt; ActionController::API
  include GraphqlDevise::SetUserByToken
  include ActionController::Cookies
  include ActionController::RequestForgeryProtection

  protected
  
  def set_csrf_token
    cookies[&apos;CSRF-TOKEN&apos;] = form_authenticity_token
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;implement-custom-protect_from_forgery-strategy&quot;&gt;Implement Custom protect_from_forgery Strategy&lt;/h4&gt;

&lt;p&gt;By the nature of GraphQL API, it’s very hard to choose protect_from_forgery strategies depending on queries and mutations.
For that reason, a custom strategy class is added here.
The strategy plan is:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;userLogin and userRegister mutations don’t need CSRF token verification, but want the token for later queries. Use reset_session.&lt;/li&gt;
  &lt;li&gt;users and posts queries, createPost mutation do CSRF token verification. Use exception.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Something extra is that schema fetching query is issued very often while using the GraphQL client such as Insomnia or Postman.
Absolutely, that doesn’t need CSRF token verification.
We should consider such query exists to implement the custom strategy.&lt;/p&gt;

&lt;p&gt;The below implementation parses GraphQL query and gets query/mutation names defined in the schema.
The implementation is primitive and doesn’t support multiple or nested queries done in a single HTTP request.
Assuming only one query comes in, it finds the name of a query or mutation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/concerns/mini_blog_strategy.rb
class MiniBlogStrategy
  def initialize(controller)
    @controller = controller
  end

  def handle_unverified_request
    query_string = JSON.parse(@controller.request.body.string)[&quot;query&quot;]
    operationName = GraphQL.parse(query_string).definitions[0].selections[0].name
    if %(users posts postCreate).include?(operationName)
      exception.handle_unverified_request
    else
      reset_session.handle_unverified_request
    end
  end

  private

  def reset_session
    ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession.new(@controller)
  end

  def exception
    ActionController::RequestForgeryProtection::ProtectionMethods::Exception.new(@controller)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;update-graphql_controller&quot;&gt;Update graphql_controller&lt;/h4&gt;

&lt;p&gt;The last piece is a GraphqlController update.
It’s simple. Just add set_csrf_token method and the custom strategy.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/graphql_controller.rb
class GraphqlController &amp;lt; ApplicationController
  # If accessing from outside this domain, nullify the session
  # This allows for outside API access while preventing CSRF attacks,
  # but you&apos;ll have to authenticate your user separately
  # protect_from_forgery with: :null_session
  protect_from_forgery with: MiniBlogStrategy
  after_action :set_csrf_token

  def execute
    # ...
  end

  # ...
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;try-csrf-protection&quot;&gt;Try CSRF Protection&lt;/h4&gt;

&lt;p&gt;All are ready. Let’s see CSRF Protection is working.
The GraphQL client used here is Postman since its HTTP request/response header handling is great.&lt;/p&gt;

&lt;p&gt;The first step is the userLogin mutation.
Open Postman, then:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;select POST for HTTP method&lt;/li&gt;
  &lt;li&gt;input http://localhost:3000/graphql&lt;/li&gt;
  &lt;li&gt;select Body&lt;/li&gt;
  &lt;li&gt;select GraphQL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Right after GraphQL is selected, Postman makes a schema fetch query.
As in the image below, “Schema Fetched” status appears.&lt;/p&gt;

&lt;p&gt;What happened behind the scene?
The GraphQL request comes to GraphQLController.
Sine the HTTP request header doesn’t include x-csrf-token header, session reset was performed following the unverified strategy.
At the same time, the cookie and session are returned.
If we look at the terminal where Rails is running, “Can’t verify CSRF token authenticity.” should be spotted among the
bunch of outputs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/postman-schema-fetch.jpeg&quot; alt=&quot;img: postman schema fetch&quot; /&gt;
&lt;img src=&quot;http://localhost:4000/assets/img/postman-schema-fetch-cookie-session.jpeg&quot; alt=&quot;img: postman schema fetch cookie session&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The userLogin mutation looks like below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation login {
    userLogin(
        email: &quot;finn.smith@example.com&quot;
        password: &quot;password!&quot;
    ) {
        credentials {
            accessToken
            client
            uid
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write the mutation and click “Send” button.
Again, we’ll see “Can’t verify CSRF token authenticity.” on the terminal, but get the CSRF-TOKEN cookie and session
in the HTTP response header.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/postman-login-query.jpeg&quot; alt=&quot;img: postman login query&quot; /&gt;
&lt;img src=&quot;http://localhost:4000/assets/img/postman-login-query-cookie-session.jpeg&quot; alt=&quot;img: postman login query cookie session&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The next step is to make posts or users query.
For example, posts query looks like below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;query {
    posts {
        id
        userId
        title
        content
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add X-CSRF-TOKEN to the HTTP request header.
The token can be seen in the login response’s header, so copy and paste it to the value column.
Also, make sure the session is set in the cookie.
Write the query and click “Send” button.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/postman-posts-query-x-csrf-token.jpeg&quot; alt=&quot;img: postman posts query x-csrf token&quot; /&gt;
&lt;img src=&quot;http://localhost:4000/assets/img/postman-posts-query-session.jpeg&quot; alt=&quot;img: postman posts query session&quot; /&gt;
&lt;img src=&quot;http://localhost:4000/assets/img/postman-posts-query.jpeg&quot; alt=&quot;img: postman posts query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s see CSRF verification failure.
Click check box on the left of X-CSRF-TOKEN to deactivate. The header won’t be sent.
Now we see ActionController::InvalidAuthenticityToken exception.
On the terminal where Rails is running, “Can’t verify CSRF token authenticity.” appears again.
That means the exception strategy is working.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/postman-posts-query-failure.jpeg&quot; alt=&quot;img: postman posts query failure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Lastly, let’s try postCreate mutation.
The mutation looks like below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation create_post {
    postCreate(input: {
        title: &quot;This is a test post title&quot;,
        content: &quot;This is a test post content.&quot;
    }) {
        post {
            id
            userId
            title
            content
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As explained in the previous post, access-token, client and uid should be set in the HTTP request header
in addition to X-CSRF-TOKEN and session.
Previously tried userLogin mutation gave us those three values already. Set those to the request header.
Make sure the session is attached in the cookie if the GraphQL client is not Postman.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/postman-create-post-headers.jpeg&quot; alt=&quot;img: postman create post headers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Write the mutation query and click “Send” button.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/postman-create-post-query.jpeg&quot; alt=&quot;img: postman create post query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The new post was successfully created.&lt;/p&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;The example Rails app code is on the GitHub repo.
Please see &lt;a href=&quot;https://github.com/yokolet/mini-blog-3&quot;&gt;https://github.com/yokolet/mini-blog-3&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;OWASP: &lt;a href=&quot;https://owasp.org/www-community/attacks/csrf&quot;&gt;Cross-Site Request Forgery&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://marcgg.com/blog/2016/08/22/csrf-rails/&quot;&gt;Understanding Rails’ Forgery Protection Strategies&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/rubyinside/a-deep-dive-into-csrf-protection-in-rails-19fa0a42c0ef&quot;&gt;A Deep Dive into CSRF Protection in Rails&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.rubyonrails.org/security.html&quot;&gt;Securing Rails Applications&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.eq8.eu/article/rails-api-authentication-with-spa-csrf-tokens.html&quot;&gt;Rails CSRF protection for SPA&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://checkmarx.com/blog/whats-old-becomes-new-again-csrf-attacks-on-graphql-apis/&quot;&gt;What’s Old Becomes New Again: CSRF Attacks on GraphQL APIs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Yoko Harada</name></author><summary type="html">This is the third post about securing Rails GraphQL API app. The topic is CSRF protection for GraphQL API. CSRF is an acronym of Cross-Site Request Forgery, and one of well-known vulnerabilities and a type of session hijack.</summary></entry><entry><title type="html">Make it Secure 2, GraphQL by Rails and Devise</title><link href="http://localhost:4000/2023/03/23/make-it-secure-2-graphql-by-rails-and-devise.html" rel="alternate" type="text/html" title="Make it Secure 2, GraphQL by Rails and Devise" /><published>2023-03-23T17:46:00+09:00</published><updated>2023-03-23T17:46:00+09:00</updated><id>http://localhost:4000/2023/03/23/make-it-secure-2-graphql-by-rails-and-devise</id><content type="html" xml:base="http://localhost:4000/2023/03/23/make-it-secure-2-graphql-by-rails-and-devise.html">&lt;p&gt;This is the second post about securing Rails GraphQL API app.
Most of conceptual explanations are in the previous post,
&lt;a href=&quot;/2023/03/19/make-it-secure-graphql-by-rails.html&quot;&gt;Make it Secure, GraphQL by Rails&lt;/a&gt;.
This memo is focusing on how to add the authentication using Devise gem
(&lt;a href=&quot;https://github.com/heartcombo/devise&quot;&gt;https://github.com/heartcombo/devise&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The GraphQL API itself is the same as the previous one.
The GraphQL app in the previous post uses Global ID and implements the user authentication from scratch.
The Devise gem covers many of those.
However the odds are: the Devise gem is for a traditional web application, so the GraphQL API only app can’t use as is.
Luckily, people have already tried the token based authentication by Devise and established a couple of ways to do that.
A combination with JWT (Jason Web Token, &lt;a href=&quot;https://github.com/jwt/ruby-jwt&quot;&gt;https://github.com/jwt/ruby-jwt&lt;/a&gt;) is one,
while with Devise Token Auth
(&lt;a href=&quot;https://github.com/lynndylanhurley/devise_token_auth&quot;&gt;https://github.com/lynndylanhurley/devise_token_auth&lt;/a&gt;)
is another one.
This memo uses GraphQLDevise gem
(&lt;a href=&quot;https://github.com/graphql-devise/graphql_devise&quot;&gt;https://github.com/graphql-devise/graphql_devise&lt;/a&gt;),
which is implemented on top of Devise Token Auth.&lt;/p&gt;

&lt;p&gt;Versions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ruby: 3.2.1&lt;/li&gt;
  &lt;li&gt;Rails: 7.0.4.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;create-rails-app&quot;&gt;Create Rails App&lt;/h4&gt;

&lt;p&gt;The Rails app creation is same as previous two posts.
However, the app here introduces Devise gem, so this memo starts from creating the app for clarity.&lt;/p&gt;

&lt;p&gt;Create an option list file, for example, ./.railsrc, with the following content.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--api
--skip-action-mailer
--skip-action-mailbox
--skip-action-cable
--skip-action-text
--skip-active-job
--skip-active-storage
-T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This app skips email based user registration provided by Devise gem.
For this reason, the option list has &lt;code&gt;--skip-action-mailer&lt;/code&gt;.
The option list above creates much smaller API only Rails app.&lt;/p&gt;

&lt;p&gt;Run the command to create the app.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails new mini-blog-2 --rc=./.railsrc
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;setup-graphql_devise-gem&quot;&gt;Setup graphql_devise gem&lt;/h4&gt;

&lt;p&gt;The app is going to use graphql_devise gem for the authentication.
The first step is to add and initialize the gem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ cd mini-blog-2
$ bundle add graphql_devise
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above command installs graphql_devise gem as well as graphql, devise, devise_auth_token gems as dependencies.&lt;/p&gt;

&lt;p&gt;The next step depends on the design decision, whether to create a new GraphQL path for the authentication or to use an existing path.
If the new path is chosen, GraphQL paths will have &lt;code&gt;/graphql&lt;/code&gt; and &lt;code&gt;/graphql_auth&lt;/code&gt;.
If the existing path is chosen, GraphQL path will be only &lt;code&gt;/graphql&lt;/code&gt; as normal GraphQL app has.
To use existing path, graphql_devise initializer needs an existing GraphQL schema as a mount point.
The choice here is to mount on the exising schema.
For this reason, the second step is to initialize GraphQL gem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g graphql:install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above command generates the schema &lt;code&gt;MiniBlog2Schema&lt;/code&gt; in the app/graphql/mini_blog2_schema.rb.
This is the mount point.
The graphql_devise initialization includes Devise model creation, so it needs model name for the authentication.
The model name is typically User.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g graphql_devise:install User --mount MiniBlog2Schema
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above command shows messages from Devise gem in addition to creating a bunch of files.
As for GraphQL side, &lt;code&gt;include GraphqlDevise::SetUserByToken&lt;/code&gt; is added to app/controllers/application_controller.rb,
and a schema plugin is added to app/graphql/mini_blog2_schema.rb.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/application_controller.rb
class ApplicationController &amp;lt; ActionController::API
  include GraphqlDevise::SetUserByToken
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/mini_blog2_schema.rb
class MiniBlog2Schema &amp;lt; GraphQL::Schema
  use GraphqlDevise::SchemaPlugin.new(
    query:            Types::QueryType,
    mutation:         Types::MutationType,
    resource_loaders: [
      GraphqlDevise::ResourceLoader.new(User)
    ]
  )
  mutation(Types::MutationType)
  query(Types::QueryType)

  # more code here

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The migration file for the user model has been created as well, so run the migration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;additional-graphql_devise-configuration&quot;&gt;Additional graphql_devise configuration&lt;/h4&gt;

&lt;p&gt;We are almost there.
Since the app mounts the authentication path to the existing GraphQL path, some more configurations are required.&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;include GraphqlDevise::FieldAuthentication&lt;/code&gt; in the file, app/graphql/types/base_field.rb.
Add &lt;code&gt;gql_devise_context(User)&lt;/code&gt; in the file, app/controller/graphql_controller.rb, to receive
user info from GraphQL queries/mutations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/types/base_field.rb.
module Types
  class BaseField &amp;lt; GraphQL::Schema::Field
    include GraphqlDevise::FieldAuthentication

    argument_class Types::BaseArgument
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controller/graphql_controller.rb
def execute
  variables = prepare_variables(params[:variables])
  query = params[:query]
  operation_name = params[:operationName]
  context = gql_devise_context(User)
  result = MiniBlog2Schema.execute(query, variables: variables, context: context, operation_name: operation_name)
  render json: result
rescue StandardError =&amp;gt; e
  raise e unless Rails.env.development?
  handle_error_in_development(e)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;make-mutation-queries-to-register-and-login&quot;&gt;Make Mutation Queries to Register and Login&lt;/h4&gt;

&lt;p&gt;For now, we can register a user and login.
Let’s try.
As a GraphQL client, Insomnia (&lt;a href=&quot;https://insomnia.rest/&quot;&gt;https://insomnia.rest/&lt;/a&gt;) is used since Insomnia has a nice UI
for HTTP request/response headers.&lt;/p&gt;

&lt;p&gt;To register the user, make mutation query below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation register {
	userRegister(
		email: &quot;finn.smith@example.com&quot;
		password: &quot;password!&quot;
		passwordConfirmation: &quot;password!&quot;
	) {
		authenticatable {
			email
		}
		credentials{
			accessToken
			client
			uid
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Above query sets only required fields. Other fields can be seen in Insomnia’s Schema pane.
The response fields are the same. The accessToken, client and uid will be used for later queries, so those are requested.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-devise-register.jpeg&quot; alt=&quot;img: insomnia devise user register&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s check HTTP response headers. As in below, authentication related headers can been seen.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-devise-register-response-header.jpeg&quot; alt=&quot;img: insomnia devise user register response header&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To login as a registered user, make mutation query below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation login {
	userLogin(
		email: &quot;finn.smith@example.com&quot;
		password: &quot;password!&quot;
	) {
		authenticatable {
			email
		}
		credentials{
			accessToken
			client
			uid
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Successful login returns the same result as the registration.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-devise-login.jpeg&quot; alt=&quot;img: insomnia devise user login&quot; /&gt;
&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-devise-login-response-header.jpeg&quot; alt=&quot;img: insomnia devise user login response header&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;user-and-post-models&quot;&gt;User and Post Models&lt;/h4&gt;

&lt;p&gt;If we imagine to create a blog site, minimum models would be users and posts.
Those two models should have a relation: a user has many posts.&lt;/p&gt;

&lt;p&gt;The user model is already created when graphql_devise was initialized.
The post model should be created, but nothing special.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g model Post user:references title:string{50} content:text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to add some non-null constraints to user and post models.
Create migrations:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g migration ChangeEmailNullOnUsers
$ rails g migration ChangeTitleContentNullOnPosts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit migration files:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;#  db/migrate/[DATE TIME]_change_email_null_on_users.rb
class ChangeEmailNullOnUsers &amp;lt; ActiveRecord::Migration[7.0]
  def change
    change_column_null :users, :email, false
  end
end

#  db/migrate/[DATE TIME]_change_title_content_null_on_posts.rb
class ChangeTitleContentNullOnPosts &amp;lt; ActiveRecord::Migration[7.0]
  def change
    change_column_null :posts, :title, false
    change_column_null :posts, :content, false
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run migration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update models:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/user.rb
class User &amp;lt; ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable, :trackable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :validatable
  include GraphqlDevise::Authenticatable

  has_many :posts, dependent: :destroy

  validates :email, presence: true, uniqueness: true
end

# app/models/post.rb
class Post &amp;lt; ApplicationRecord
  belongs_to :user

  validates :title, presence: true
  validates :content, presence: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;graphql-queries&quot;&gt;GraphQL Queries&lt;/h4&gt;

&lt;p&gt;To make queries, we need GraphQL types.
Generate user and post types.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g graphql:object user
$ rails g graphql:object post
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we got two types:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;app/graphql/types/user_type.rb&lt;/li&gt;
  &lt;li&gt;app/graphql/types/post_type.rb&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We need query definitions for both user and post.
Create resolvers as in below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/resolvers/user_resolver.rb
module Resolvers
  class UserResolver &amp;lt; GraphQL::Schema::Resolver
    type [Types::UserType], null: false

    argument :id, Int, required: false

    def resolve(**kwargs)
      if kwargs[:id]
        [User.find(kwargs[:id])]
      else
        User.all
      end
    end
  end
end

# app/graphql/resolvers/post_resolver.rb
module Resolvers
  class PostResolver &amp;lt; GraphQL::Schema::Resolver
    type [Types::PostType], null: false

    argument :user_id, Int, required: false

    def resolve(**kwargs)
      if kwargs[:user_id]
        Post.where(user: kwargs[:user_id]).all
      else
        Post.all
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update query_types to include user and post resolvers with authenticate option false.
An assumption here is that we don’t need to authenticate for queries.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/types/query_type.rb
module Types
  class QueryType &amp;lt; Types::BaseObject
    # Add `node(id: ID!) and `nodes(ids: [ID!]!)`
    include GraphQL::Types::Relay::HasNodeField
    include GraphQL::Types::Relay::HasNodesField

    # Add root-level fields here.
    # They will be entry points for queries on your schema.
    field :users, resolver: Resolvers::UserResolver, authenticate: false
    field :posts, resolver: Resolvers::PostResolver, authenticate: false
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An example query to get all users will be blow:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;query users {
	users {
		id
		email
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-devise-users.jpeg&quot; alt=&quot;img: insomnia devise users query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To make the query above, no authentication is required at all.&lt;/p&gt;

&lt;p&gt;We can make post query as well, however, it returns an empty array at this moment.&lt;/p&gt;

&lt;h4 id=&quot;graphql-mutations&quot;&gt;GraphQL Mutations&lt;/h4&gt;

&lt;p&gt;The next is a create post mutation so that we can see some results from the post query.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g graphql:mutation_create post
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above generates app/graphql/mutations/post_create.rb file.
After some editing, the post_create.rb looks like below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/mutations/post_create.rb
module Mutations
  class PostCreate &amp;lt; BaseMutation
    description &quot;Creates a new post&quot;

    field :post, Types::PostType, null: false

    argument :title, String, required: true
    argument :content, String, required: true

    def resolve(**kwargs)
      kwargs[:user_id] = context[:current_resource].id
      post = ::Post.new(**kwargs)
      raise GraphQL::ExecutionError.new &quot;Error creating post&quot;, extensions: post.errors.to_hash unless post.save

      { post: post }
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since mutation queries require authentication, the logged in user information is available in the context.
The user id to create a post is retrieved from the authentication result.&lt;/p&gt;

&lt;p&gt;Lastly, we need a little hack on Rails 7.0.4.3 and Devise 4.9.0.
In general, API only web application don’t use cookie or session.
However, Devise has been developed based on a traditional web application, so it still relies on the cookie.
The issue is on-going and discussed at
&lt;a href=&quot;https://github.com/heartcombo/devise/issues/5443&quot;&gt;https://github.com/heartcombo/devise/issues/5443&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The workaround is adding below three lines to config/application.rb.
The session store’s key is, in general, “&lt;em&gt;[APP NAME]_session&lt;/em&gt;#{Rails.env}”.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/application.rb
# ...
# ...
module MiniBlog2
  class Application &amp;lt; Rails::Application
    # ...
    # ...
    config.session_store :cookie_store, key: &quot;_mini-blog-2_session_#{Rails.env}&quot;
    config.middleware.use ActionDispatch::Cookies
    config.middleware.use config.session_store, config.session_options
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything is ready.
It’s time to create some posts.
As the application designed like this, we need to log in first.
Try login mutation query.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation login {
	userLogin(
		email: &quot;finn.smith@example.com&quot;
		password: &quot;password!&quot;
	) {
		authenticatable {
			email
		}
		credentials{
			accessToken
			client
			uid
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-devise-login-for-post.jpeg&quot; alt=&quot;img: insomnia devise login for post&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The successful login returns accessToken, client, and uid.
These three are used to authenticate.
The create post mutation query looks like below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation post {
	postCreate(input: {
		title: &quot;Hello World, Again&quot;,
		content: &quot;This is the second post from Finn.&quot;
	}) {
		post {id userId title content}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Set three user authentication values to the HTTP request header.
Be careful, GraphQL result is accessToken, but HTTP request header is access-token.
Now, we could create a post.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-devise-post.jpeg&quot; alt=&quot;img: insomnia devise post mutation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-devise-post-headers.jpeg&quot; alt=&quot;img: insomnia devise post request headers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Add some more posts using different user’s authentication values.&lt;/p&gt;

&lt;p&gt;To get all posts by all users, make below query.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;query posts {
	posts {
		id
		userId
		title
		content
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-devise-all-posts.jpeg&quot; alt=&quot;img: insomnia devise all posts&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To get all post of a specific user, make below query with user’s id.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;query posts {
	posts(userId: 3) {
		id
		userId
		title
		content
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-devise-post-of-a-user.jpeg&quot; alt=&quot;img: insomnia devise posts of a user&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;The example Rails app code is on the GitHub repo.
Please see &lt;a href=&quot;https://github.com/yokolet/mini-blog-2&quot;&gt;https://github.com/yokolet/mini-blog-2&lt;/a&gt;.&lt;/p&gt;</content><author><name>Yoko Harada</name></author><summary type="html">This is the second post about securing Rails GraphQL API app. Most of conceptual explanations are in the previous post, Make it Secure, GraphQL by Rails. This memo is focusing on how to add the authentication using Devise gem (https://github.com/heartcombo/devise).</summary></entry><entry><title type="html">Make it Secure, GraphQL by Rails</title><link href="http://localhost:4000/2023/03/19/make-it-secure-graphql-by-rails.html" rel="alternate" type="text/html" title="Make it Secure, GraphQL by Rails" /><published>2023-03-19T01:04:00+09:00</published><updated>2023-03-19T01:04:00+09:00</updated><id>http://localhost:4000/2023/03/19/make-it-secure-graphql-by-rails</id><content type="html" xml:base="http://localhost:4000/2023/03/19/make-it-secure-graphql-by-rails.html">&lt;p&gt;These days, attacks on a web application becomes more and more common.
Every web application should be protected to get rid of such attacks.
Ruby on Rails provides ways to make it secure out of the box.
Additionally, well-used gems in Rails world, such as Devise (&lt;a href=&quot;https://github.com/heartcombo/devise&quot;&gt;https://github.com/heartcombo/devise&lt;/a&gt;),
give us convenient ways to protect the Rails app.&lt;/p&gt;

&lt;p&gt;However, when it comes to an API only web application, it’s not straightforward.
For example, passing a token by meta tag won’t work.
This memo is focusing on GraphQL API and about how to make it secure.&lt;/p&gt;

&lt;p&gt;Versions:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ruby: 3.2.1&lt;/li&gt;
  &lt;li&gt;Rails: 7.0.4.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;password-authentication&quot;&gt;Password Authentication&lt;/h3&gt;

&lt;p&gt;The most primitive idea to protect web application is adding a password authentication.
As we know, users who wants to modify resources on the web site should register themselves and
complete a login process by sending an id and credential combination to the web site.
The id and credential pair will be verified on the web application side.
Then, the logged in state will be maintained between the user and the web site.
With the logged in state, web application processes the resource update request and returns the result.
If not, an error message should be sent back to the user who tried.&lt;/p&gt;

&lt;p&gt;The traditional web application would show the HTML login form, dropdown or sort for register and login.
Then, the web browser and application maintains the logged-in state by a session, cookie or hidden field in the HTML form.&lt;/p&gt;

&lt;p&gt;The API only server should do what?
In general, the API server uses HTTP headers or explicit token exchanges.
For example, GraphQL API provides login mutation which returns a token after a successful verification.
The returned token should be added to an HTTP header to make successive mutations and/or queries.&lt;/p&gt;

&lt;p&gt;At this moment, multiple techniques are out there, however, none is decisive for GraphQL API.
Sometime, REST API is used for login and register user since Devise gem works better with REST API.
Others do by GraphQL mutation API with the authentication implementation from scratch.&lt;/p&gt;

&lt;p&gt;This memo mentions about a way to authenticate users by Global ID.&lt;/p&gt;

&lt;h4 id=&quot;global-id&quot;&gt;Global ID&lt;/h4&gt;

&lt;p&gt;The Global ID is “an app wide URI that uniquely identifies a model instance” as
described in &lt;a href=&quot;https://github.com/rails/globalid&quot;&gt;https://github.com/rails/globalid&lt;/a&gt;.
The Global ID based authentication does two jobs below using Global ID as an uniquely identifiable value:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;create a user with the uniquely identifiable value&lt;/li&gt;
  &lt;li&gt;locate a user based on the uniquely identifiable value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Global ID authentication is explained in the YouTube video and GitHub repository below:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;YouTube: Getting started with GraphQL in Rails &lt;a href=&quot;https://www.youtube.com/watch?v=izgCaExV9Uo&quot;&gt;https://www.youtube.com/watch?v=izgCaExV9Uo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;GitHub: &lt;a href=&quot;https://github.com/phawk/coinfusion/tree/graphql_ruby_2&quot;&gt;https://github.com/phawk/coinfusion/tree/graphql_ruby_2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s add Global ID based authentication to the GraphQL API created in the previous post,
&lt;a href=&quot;/2023/03/12/getting-started-graphql-using-ruby-on-rails.html&quot;&gt;Getting Started GraphQL Using Ruby on Rails&lt;/a&gt;.&lt;/p&gt;

&lt;h5 id=&quot;add-gems&quot;&gt;Add Gems&lt;/h5&gt;

&lt;p&gt;The Global ID feature is provided by globalid gem.
The gem is pulled as an dependency of Action Text and Active Job.
When the GraphQL app was created in the previous blog post, those two were skipped.
So, the gem should be added manually.&lt;/p&gt;

&lt;p&gt;Also, we need bcrypt gem, &lt;a href=&quot;https://github.com/bcrypt-ruby/bcrypt-ruby&quot;&gt;https://github.com/bcrypt-ruby/bcrypt-ruby&lt;/a&gt;.
The bcrypt gem is used to create a password digest and provide user authentication feature.&lt;/p&gt;

&lt;p&gt;To add those two gems, do below:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;open Gemfile and uncomment bcrypt gem&lt;/li&gt;
  &lt;li&gt;run &lt;code&gt;bundle add globalid&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;update-user-model&quot;&gt;Update User Model&lt;/h5&gt;

&lt;p&gt;The User model should have a &lt;code&gt;password_digest&lt;/code&gt; column to save a password digest.
The User model should never ever save a raw password in the database which is to avoid the actual password to be stolen.
This is a very basic security practice.&lt;/p&gt;

&lt;p&gt;The password digest is a hashed value of salt and given password.
On Rails, the bcrypt gem is responsible to create the hashed value.
The bcrypt gem is a Ruby implementation of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bcrypt&quot;&gt;bcrypt&lt;/a&gt; password-hashing function.
Precisely, the bcrypt function creates a concatenated string of a hashing algorithm, cost, salt and checksum.
That sort of hashed value will be saved in the database instead of a raw password.&lt;/p&gt;

&lt;p&gt;Let’s create a migration to add password_digest column to user model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g migration AddPasswordDigestToUsers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit the migration file and run the migration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# db/migrate/[DATE TIME]_add_password_digest_to_users.rb
class AddPasswordDigestToUsers &amp;lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :password_digest, :string
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The user model definition should be updated also.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User &amp;lt; ApplicationRecord
  attr_accessor :token

  has_secure_password

  has_many :posts, dependent: :destroy

  validates :email, uniqueness: true
  validates :password, length: { minimum: 8 }, presence: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since this is a GraphQL API, the authentication is token based.
Because of that, &lt;code&gt;attr_accessor :token&lt;/code&gt;, is added.
The &lt;code&gt;has_secure_password&lt;/code&gt; is to signal that the user should be authenticated, which is a provided feature by bcrypt gem.
The line, &lt;code&gt;validates :password, length: { minimum: 8 }, presence: true&lt;/code&gt; is to require the password input.
The database won’t have the password column, but still the model creation needs password.
For this reason, the password constraint is in the user model.&lt;/p&gt;

&lt;h5 id=&quot;update-graphql-controller-types-and-mutations&quot;&gt;Update GraphQL Controller, Types and Mutations&lt;/h5&gt;

&lt;p&gt;The next step is GraphQL controller, type and mutation updates.
The first one is a graphql_controller update.
The changes in the controller are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;add a private method, current_user, to locate a user based on Global ID using the token in the HTTP header.&lt;/li&gt;
  &lt;li&gt;add a current_user entry in graphql context hash table.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/graphql_controller.rb
class GraphqlController &amp;lt; ApplicationController

  def execute
    variables = prepare_variables(params[:variables])
    query = params[:query]
    operation_name = params[:operationName]
    context = {
      current_user: current_user
    }
    result = MiniBlogSchema.execute(query, variables: variables, context: context, operation_name: operation_name)
    render json: result
  rescue StandardError =&amp;gt; e
    raise e unless Rails.env.development?
    handle_error_in_development(e)
  end

  private

  def current_user
    header  = request.headers[&quot;AUTHORIZATION&quot;]
    token = header&amp;amp;.gsub(/\AToken\s/, &quot;&quot;)
    GlobalID::Locator.locate_signed(token, for: &apos;graphql&apos;)
  end
  # snip
  # ...
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second update is the user_type.
The user_type is used for both query and mutation, so it should have password and token fields.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/types/user_type.rb
module Types
  class UserType &amp;lt; Types::BaseObject
    field :id, ID, null: false
    field :email, String, null: false
    field :first_name, String, null: true
    field :last_name, String, null: true
    field :password, String, null: true
    field :token, String, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The remaining updates are mutations.
The user registration and login mutations look like below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/mutations/user_register.rb
module Mutations
  class UserRegister &amp;lt; BaseMutation
    description &quot;Register a new user&quot;

    field :user, Types::UserType, null: false

    argument :email, String, required: true
    argument :password, String, required: true
    argument :first_name, String, required: false
    argument :last_name, String, required: false

    def resolve(**kwargs)
      user = ::User.new(**kwargs)
      if user.save
        user.token = user.to_sgid(expires_in: 6.hours, for: &apos;graphql&apos;)
        { user: user }
      else
        raise GraphQL::ExecutionError.new &quot;Error creating user&quot;, extensions: user.errors.to_hash
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/mutations/user_login.rb
module Mutations
  class UserLogin &amp;lt; BaseMutation
    description &quot;Login an existing user&quot;

    field :user, Types::UserType, null: false

    argument :email, String, required: true
    argument :password, String, required: true

    def resolve(email:, password:)
      user = User.find_by(email: email)
      if user&amp;amp;.authenticate(password)
        user.token = user.to_sgid(expires_in: 6.hours, for: &apos;graphql&apos;)
        { user: user }
      else
        raise GraphQL::ExecutionError.new &quot;Error creating user&quot;, extensions: user.errors.to_hash
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The mutation_type needs an update to include UserRegister and UserLogin mutations.
Also, we don’t need UserCreate mutation anymore, so delete it if it is there.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/types/mutation_type.rb
module Types
  class MutationType &amp;lt; Types::BaseObject
    field :user_register, mutation: Mutations::UserRegister
    field :user_login, mutation: Mutations::UserLogin
    field :post_create, mutation: Mutations::PostCreate
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, the GraphQL API is able to provide user register and login feature.
The last piece is to create a post after the successful login.
To add the authentication feature to post creation mutation,
BaseMutation class is going to have two methods to check logged in state.
The GraphqlController already added the context[:current_user] parameter.
The the authenticate! method raises an exception if context[:current_user] is empty.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Mutations
  class BaseMutation &amp;lt; GraphQL::Schema::RelayClassicMutation
    argument_class Types::BaseArgument
    field_class Types::BaseField
    input_object_class Types::BaseInputObject
    object_class Types::BaseObject

    private

    def current_user
      context[:current_user]
    end

    def authenticate!
      if current_user.blank?
        raise GraphQL::ExecutionError.new &quot;Authentication failed. Please log in.&quot;
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The PostCreate class will have one line of addition.
The resolve method gets &lt;code&gt;authenticate!&lt;/code&gt; in its first line. That’s it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/mutations/post_create.rb
module Mutations
  class PostCreate &amp;lt; BaseMutation
    description &quot;Creates a new post&quot;

    field :post, Types::PostType, null: false

    argument :user_id, Integer, required: true
    argument :title, String, required: true
    argument :content, String, required: true

    def resolve(**kwargs)
      authenticate!
      post = ::Post.new(**kwargs)
      raise GraphQL::ExecutionError.new &quot;Error creating post&quot;, extensions: post.errors.to_hash unless post.save

      { post: post }
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;make-queries&quot;&gt;Make Queries&lt;/h5&gt;

&lt;p&gt;All are implemented.
It’s time to try those.
Here, GraphQL client is Insomnia (&lt;a href=&quot;https://insomnia.rest/&quot;&gt;https://insomnia.rest/&lt;/a&gt;)
since both request and response HTTP headers are visible and easy to edit.&lt;/p&gt;

&lt;p&gt;The first GraphQL query is the user registration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation register {
	userRegister(input: {
		email: &quot;finn.smith@example.com&quot;,
		password: &quot;password!&quot;,
		firstName: &quot;Finn&quot;,
		lastName: &quot;Smith&quot;
	}) {
		user {
			id
			email
			token
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the user is successfully registered, a tokenized signed Global ID will be returned.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-register-query.jpeg&quot; alt=&quot;img: insomnia user register query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The next is a login mutation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation login {
	userLogin(input: {
		email: &quot;finn.smith@example.com&quot;,
		password: &quot;password!&quot;
	}) {
		user {
		    id
			email
			token
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The login mutation also returns a tokenized signed Global ID.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-login-query.jpeg&quot; alt=&quot;img: insomnia user login query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The post create mutation needs HTTP header to complete successfully.
So, let’s try without the token in the HTTP header to see it will fail.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation post {
	postCreate(input: {
		userId: 9,
		title: &quot;Hello, World!&quot;,
		content: &quot;This is the first from Finn&quot;
	}) {
		post {
			id
			title
			content
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As expected, it failed without the token in the HTTP header&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-post-failed.jpeg&quot; alt=&quot;img: insomnia failed post query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Then, set Authorization HTTP request header with the token returned from register or login mutation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Authorization: Token BAh7CEkiCGdpZAY6BkVUSSIsZ2lk.......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, it succeeds.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/insomnia-post-with-header.jpeg&quot; alt=&quot;img: insomnia post with header&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;The example Rails app code is on the GitHub repo.
Please see &lt;a href=&quot;https://github.com/yokolet/mini-blog&quot;&gt;https://github.com/yokolet/mini-blog&lt;/a&gt;.&lt;/p&gt;</content><author><name>Yoko Harada</name></author><summary type="html">These days, attacks on a web application becomes more and more common. Every web application should be protected to get rid of such attacks. Ruby on Rails provides ways to make it secure out of the box. Additionally, well-used gems in Rails world, such as Devise (https://github.com/heartcombo/devise), give us convenient ways to protect the Rails app.</summary></entry><entry><title type="html">Getting Started GraphQL Using Ruby on Rails</title><link href="http://localhost:4000/2023/03/12/getting-started-graphql-using-ruby-on-rails.html" rel="alternate" type="text/html" title="Getting Started GraphQL Using Ruby on Rails" /><published>2023-03-12T01:13:00+09:00</published><updated>2023-03-12T01:13:00+09:00</updated><id>http://localhost:4000/2023/03/12/getting-started-graphql-using-ruby-on-rails</id><content type="html" xml:base="http://localhost:4000/2023/03/12/getting-started-graphql-using-ruby-on-rails.html">&lt;p&gt;GraphQL is an API standard to provide resources on the server-side to various types of clients.
GraphQL itself is a specification and doesn’t provide an implementation.
For Ruby on Rails, GraphQL Ruby &lt;a href=&quot;https://graphql-ruby.org/&quot;&gt;https://graphql-ruby.org/&lt;/a&gt; is the most popular library.&lt;/p&gt;

&lt;p&gt;Not like REST API, GraphQL has only one endpoint.
While REST API uses different endpoints (paths or URL) to access multiple types of resources,
GraphQL uses schema based queries.
The REST API clients receives all fields server returned.
However, GraphQL clients can specify what fields they want to receive from the API server.&lt;/p&gt;

&lt;p&gt;For REST API, the swagger UI &lt;a href=&quot;https://swagger.io/tools/swagger-ui/&quot;&gt;https://swagger.io/tools/swagger-ui/&lt;/a&gt; is often
used as a documentation and testing tool.
In general, the swagger UI is provided by the REST API server.&lt;/p&gt;

&lt;p&gt;In contract, the GraphQL server doesn’t provide such UI tool.
Instead, GraphQL desktop apps are out there, which provides UI based documentation and testing tools.
The blog post “&lt;a href=&quot;https://testfully.io/blog/graphql-clients/&quot;&gt;Top 10 GraphQL clients&lt;/a&gt;” lists desktop apps with some explanations.
Such apps have ability to pull the schema from GraphQL server and show that on UI.
Also, those have features to write GraphQL queries, send those and receive results.&lt;/p&gt;

&lt;p&gt;Since Ruby on Rails is designed for REST API, we need additional steps to use Rails as a GraphQL server.
This is a memo how to get started GraphQL using Ruby on Rails.&lt;/p&gt;

&lt;h3 id=&quot;setting-up&quot;&gt;Setting Up&lt;/h3&gt;

&lt;h4 id=&quot;create-rails-app&quot;&gt;Create Rails App&lt;/h4&gt;

&lt;p&gt;This memo focuses on creating GraphQL API server.
The App will be the API only and have a smaller stack with sqlite3 as a database.
Ruby and Rails versions are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ruby: 3.2.1&lt;/li&gt;
  &lt;li&gt;Rails: 7.0.4.2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Create &lt;code&gt;.railsrc&lt;/code&gt; file with the content below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;--api
--skip-action-mailer
--skip-action-mailbox
--skip-action-cable
--skip-action-text
--skip-active-job
--skip-active-storage
-T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default location of &lt;code&gt;.railsrc&lt;/code&gt; is a home directory just like &lt;code&gt;.zshrc&lt;/code&gt; or &lt;code&gt;.bashrc&lt;/code&gt;.
If it is created in another directory and/or another filename, use &lt;code&gt;--rc=RC&lt;/code&gt; option to specify the file.&lt;/p&gt;

&lt;p&gt;Create the Rails app named “mini-blog”, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails new mini-blog --rc=./.railsrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Test the app is created correctly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ cd mini-blog
$ rails s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, hit http://localhost:3000/ on a web browser.
If you see Rails logo and Ruby/Rails versions, the server could start successfully.&lt;/p&gt;

&lt;h4 id=&quot;install-graphql-ruby-gem&quot;&gt;Install GraphQL Ruby gem&lt;/h4&gt;

&lt;p&gt;Once the Rails app is created, the next step is to install GraphQL Ruby (&lt;a href=&quot;https://graphql-ruby.org/&quot;&gt;https://graphql-ruby.org/&lt;/a&gt;) gem.
Run two commands below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ bundle add graphql
$ rails g graphql:install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second command generates GraphQL basic types, default query/mutation types, and a default schema.
The schema name is &lt;code&gt;[APP_NAME]_schema.rb&lt;/code&gt;.
All are located under &lt;code&gt;app/graphql&lt;/code&gt; directory.
Also, the command adds a route to &lt;code&gt;/graphql&lt;/code&gt;. Have a look at &lt;code&gt;config/route.rb&lt;/code&gt;, which looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/routes.rb
Rails.application.routes.draw do
  post &quot;/graphql&quot;, to: &quot;graphql#execute&quot;
  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html

  # Defines the root path route (&quot;/&quot;)
  # root &quot;articles#index&quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly, the second command generates a default GraphQL controller, &lt;code&gt;app/controllers/graphql_controller.rb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, &lt;code&gt;app&lt;/code&gt; directory looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app
├── controllers
│   ├── application_controller.rb
│   ├── concerns
│   └── graphql_controller.rb
├── graphql
│   ├── mini_blog_schema.rb
│   ├── mutations
│   │   └── base_mutation.rb
│   └── types
│       ├── base_argument.rb
│       ├── base_connection.rb
│       ├── base_edge.rb
│       ├── base_enum.rb
│       ├── base_field.rb
│       ├── base_input_object.rb
│       ├── base_interface.rb
│       ├── base_object.rb
│       ├── base_scalar.rb
│       ├── base_union.rb
│       ├── mutation_type.rb
│       ├── node_type.rb
│       └── query_type.rb
└── models
    ├── application_record.rb
    └── concerns
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;try-how-graphql-looks-like&quot;&gt;Try How GraphQL Looks Like&lt;/h4&gt;

&lt;p&gt;For now, GraphQL has started working with the minimal setting.
The GraphQL gem’s generator already created a very simple API.
We can test that.&lt;/p&gt;

&lt;p&gt;To test GraphQL, we need a GraphQL client.
Previously, Graphiql gem (notice, the name has “i” before ql) was often installed along with GraphQL Ruby gem.
However, once the Rails 7 app is configured as API only server, adding UI became not easy.
Besides, many free-to-use GraphQL clients are out there as mentioned at the beginning.&lt;/p&gt;

&lt;p&gt;Among those desktop apps, below might be the choice.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GraphiQL &lt;a href=&quot;https://github.com/skevy/graphiql-app&quot;&gt;https://github.com/skevy/graphiql-app&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Altair &lt;a href=&quot;https://altairgraphql.dev/&quot;&gt;https://altairgraphql.dev/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Insomnia &lt;a href=&quot;https://insomnia.rest/&quot;&gt;https://insomnia.rest/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This memo is going to use GraphiQL desktop app.
If you are on MacOS and have brew, try below to install the app.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ brew install --cask graphiql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have other OS, you can install the desktop app by npm command as well.
Additional installations are on the GitHub repo.&lt;/p&gt;

&lt;p&gt;When the GraphiQL window is firstly opened, it should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/graphiql-default.jpeg&quot; alt=&quot;default graphiql window&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Input http://localhost:3000/graphql in the GraphQL Endpoint field, which is defined in &lt;code&gt;config/routes.rb&lt;/code&gt;
Also, check the Method choice. It is defined in &lt;code&gt;config/routes.rb&lt;/code&gt; as POST.
Then, GraphiQL app connects to Rails and pulls the schema defined in the &lt;code&gt;app/graphql/types/query_type.rb&lt;/code&gt;
and &lt;code&gt;app/graphql/types/mutation_type.rb&lt;/code&gt;.
Those schemas show up when “&amp;lt; DOCS” button on the right upper area of GraphiQL window is clicked.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/graphiql-docs.jpeg&quot; alt=&quot;default graphiql window&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Both Query and Mutation schemas are displayed when the links get clicked.&lt;/p&gt;

&lt;p&gt;Let’s make a query to testField.
On the leftmost pane, input GraphQL query.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  testField
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hit the right arrow button above the query input pane.
The result is on the center pane.
The message of “Hello World!” is from &lt;code&gt;app/graphql/types/query_type.rb&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/graphiql-query.jpeg&quot; alt=&quot;default graphiql window&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The mutation query can be sent, however, nothing changes since all are static just a test implementation.&lt;/p&gt;

&lt;h3 id=&quot;create-models-and-graphql-types&quot;&gt;Create Models and GraphQL Types&lt;/h3&gt;

&lt;p&gt;GraphQL itself is independent from the active record world.
However, API connects to a database to retrieve or update resources almost always.
On Ruby on Rails, creating an active record model is the way to connect to the database.&lt;/p&gt;

&lt;p&gt;Well, a GraphQL type is the first? Or, an active record model should come before the GraphQL type?
The GraphQL generator can create a type without a model definition.
But, certainly, the type definition is almost empty.
When the active record model exists already, GraphQL generator looks at the database schema and generates the type.
By this, we will get a usable GraphQL type definition.&lt;/p&gt;

&lt;h4 id=&quot;define-models&quot;&gt;Define Models&lt;/h4&gt;

&lt;p&gt;Let’s imagine we will create a blog site.
The minimum models would be users and posts whose relation is: a user has multiple posts.
The user’s email should be unique so that the same email user won’t be created more than once.&lt;/p&gt;

&lt;p&gt;The first thing is to generate user and post models as in below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g model User email:string:uniq first_name:string last_name:string
$ rails g model Post user:references title:string{50} content:text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to add some more constraints to models.
The user model’s email is implicitly non-null since it is an indexed unique value.
However, for the graphql generator, it’s better to have non-null constraint explicitly.
Additionally, we want post model’s title and content to be non-null fields also.
No need to say, we need migrations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g migration ChangeEmailNullOnUsers
$ rails g migration ChangeTitleContentNullOnPosts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, edit migration files:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;#  db/migrate/[DATE TIME]_change_email_null_on_users.rb
class ChangeEmailNullOnUsers &amp;lt; ActiveRecord::Migration[7.0]
  def change
    change_column_null :users, :email, false
  end
end

#  db/migrate/[DATE TIME]_change_title_content_null_on_posts.rb
class ChangeTitleContentNullOnPosts &amp;lt; ActiveRecord::Migration[7.0]
  def change
    change_column_null :posts, :title, false
    change_column_null :posts, :content, false
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create tables on the sqlite3 database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails db:create db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should update models as well.&lt;/p&gt;

&lt;p&gt;Edit &lt;code&gt;app/models/user.rb&lt;/code&gt; to add a has_many association and uniqueness validation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/user.rb
class User &amp;lt; ApplicationRecord
  has_many :posts, dependent: :destroy

  validates :email, uniqueness: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit &lt;code&gt;app/models/post.rb&lt;/code&gt; to add presence validations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/post.rb
class Post &amp;lt; ApplicationRecord
  belongs_to :user

  validates :title, presence: true
  validates :content, presence: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The model definitions are ready. It’s time to add some seed data, so that we can see some results.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# db/seeds.rb
user1 = User.create(
  email: &quot;john.doe@example.com&quot;,
  first_name: &quot;John&quot;,
  last_name: &quot;Doe&quot;
)

user2 = User.create(
  email: &quot;jane.smith@example.com&quot;,
  first_name: &quot;Jane&quot;,
  last_name: &quot;Smith&quot;
)

Post.create(
  [{
     user: user1,
     title: &quot;Accidentally, I created a Rails app!&quot;,
     content: &quot;My days are this, that and blah. Wait! I accidentally created a Rails app!!&quot;
   },
   {
     user: user2,
     title: &quot;Blogging&quot;,
     content: &quot;I like blogging. It&apos;s fun. One day, I started writing a blog post...&quot;
   },
   {
     user: user2,
     title: &quot;Spring!&quot;,
     content: &quot;It&apos;s not about a web framework here. I&apos;m talking about a season. Yes, Spring!&quot;
   }
  ]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the command below to add seed data to the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails db:seed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check above worked correctly, Rails console is one of ways to test it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails c
Loading development environment (Rails 7.0.4.2)
irb(main):001:0&amp;gt; User.all
...(user query result here)...
irb(main):002:0&amp;gt; Post.all
...(post query result here)...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;generate-graphql-types&quot;&gt;Generate GraphQL Types&lt;/h4&gt;

&lt;p&gt;For now, active record models are ready.
The next step is to generate GraphQL types.
Run the command below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g graphql:object user
$ rails g graphql:object post
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The generator captures the database schema definition in db/schema.rb to create user and post types.
Mostly, we can use generated types as those are.&lt;/p&gt;

&lt;p&gt;The generated user_type.rb and post_type.rb look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/types/user_type.rb
module Types
  class UserType &amp;lt; Types::BaseObject
    field :id, ID, null: false
    field :email, String, null: false
    field :first_name, String, null: true
    field :last_name, String, null: true
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/types/post_type.rb
module Types
  class PostType &amp;lt; Types::BaseObject
    field :id, ID, null: false
    field :user_id, Integer, null: false
    field :title, String, null: false
    field :content, String, null: false
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    field :updated_at, GraphQL::Types::ISO8601DateTime, null: false
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;make-graphql-queries&quot;&gt;Make GraphQL Queries&lt;/h3&gt;

&lt;p&gt;So far, we have some seed data in the database.
The next step is to make GraphQL queries.&lt;/p&gt;

&lt;p&gt;GraphQL query schema is defined in &lt;code&gt;app/graphql/types/query_type.rb&lt;/code&gt;, which has been generated when GraphQL Ruby gem was installed.
As we see “testField” in the above section, all query definitions should be in the query_type.rb.&lt;/p&gt;

&lt;p&gt;GraphQL examples out there often write every query implementation in the query_type.rb.
It’s OK if the API is as simple as examples.
However, that might end up in adding bunch of methods in a single file in an actual application.
A concern is, the code will have poor readability and/or maintainability.
As far as I searched online, it looks no decisive solution exists for this.
What I found is a GraphQL Ruby’s Resolver (&lt;a href=&quot;https://graphql-ruby.org/fields/resolvers.html&quot;&gt;https://graphql-ruby.org/fields/resolvers.html&lt;/a&gt;).
Although GraphQL Ruby team wants people to avoid Resolver, it is a good way to decouple each type’s query implementation.
For that reason, the Resolver is used here.&lt;/p&gt;

&lt;h4 id=&quot;define-resolvers&quot;&gt;Define Resolvers&lt;/h4&gt;

&lt;p&gt;Queries to be implemented are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a single user query, parameter: user id&lt;/li&gt;
  &lt;li&gt;all users query, parameter: none&lt;/li&gt;
  &lt;li&gt;multiple posts query, parameter: none – all posts, user id – one user’s all posts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The implementations of resolvers for those queries are defined:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/resolvers/user_resolver.rb
module Resolvers
  class UserResolver &amp;lt; GraphQL::Schema::Resolver
    type Types::UserType, null: false

    argument :id, Int, required: true

    def resolve(id:)
      User.find(id)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/resolvers/user_collection_resolver.rb
module Resolvers
  class UserCollectionResolver &amp;lt; GraphQL::Schema::Resolver
    type [Types::UserType], null: false

    def resolve(**kwargs)
      User.all
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/resolvers/post_collection_resolver.rb
module Resolvers
  class PostCollectionResolver &amp;lt; GraphQL::Schema::Resolver
    type [Types::PostType], null: false

    argument :user_id, Int, required: false

    def resolve(**kwargs)
      if kwargs[:user_id]
        Post.where(user: kwargs[:user_id]).all
      else
        Post.all
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above three resolvers should be referenced in the query_type.rb.
Now query_type.rb becomes below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/types/query_type.rb
module Types
  class QueryType &amp;lt; Types::BaseObject
    # Add `node(id: ID!) and `nodes(ids: [ID!]!)`
    include GraphQL::Types::Relay::HasNodeField
    include GraphQL::Types::Relay::HasNodesField

    # Add root-level fields here.
    # They will be entry points for queries on your schema.
    field :user, resolver: Resolvers::UserResolver
    field :users, resolver: Resolvers::UserCollectionResolver
    field :posts, resolver: Resolvers::PostCollectionResolver
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;queries-on-graphiql&quot;&gt;Queries on GraphiQL&lt;/h4&gt;

&lt;p&gt;We are ready to test newly defined queries.
On GraphiQL desktop app, Command + w will delete the tab and initialize UI.
Input http://localhost:3000/graphql in the Endpoint text field and hit the return key.
The updated schema is pulled, which is displayed in the Docs pane.&lt;/p&gt;

&lt;p&gt;To get all users, the query is simple.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;{
	users {
    id
    email
    firstName
    lastName
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/graphiql-users-query.jpeg&quot; alt=&quot;graphiql users query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To get one user using user’s id, the query needs a parameter.
The simple form is to write id in the query.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;{
  user(id: 1) {
    id
    email
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another form is to use a query variable. In this case, the query needs additional info about the variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;query user($uid: Int!) {
  user(id: $uid) {
    id
    email
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, pass the variable in the query variables pane.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;{
  &quot;uid&quot;: 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/graphiql-user-with-id-query.jpeg&quot; alt=&quot;graphiql user with id query&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For post queries, with/without user id are defined.
If the user id is not provided, the query gets all posts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;{
  posts {
    id
    userId
    title
    content
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user id is given, the query retrieves the specified user’s all posts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;query posts($uid: Int) {
  posts(userId: $uid) {
    id
    userId
    title
    content
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-grapql&quot;&gt;{
  &quot;uid&quot;: 2
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/graphiql-posts-query.jpeg&quot; alt=&quot;graphiql posts query&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;create-a-new-resource-by-mutation&quot;&gt;Create a New Resource by Mutation&lt;/h3&gt;

&lt;p&gt;GraphQL calls “mutation” to create/update/delete operations over resources.
Like queries, mutations need a definition for each types.&lt;/p&gt;

&lt;h4 id=&quot;user-and-post-mutations&quot;&gt;User and Post Mutations&lt;/h4&gt;

&lt;p&gt;GraphQL Ruby provides a mutation generator. It still needs to edit, however, the generator cuts down the amount of coding.
Run the command below to create user and post mutation definitions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rails g graphql:mutation_create user
$ rails g graphql:mutation_create post
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After editing two mutations, those look like below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/mutations/user_create.rb
module Mutations
  class UserCreate &amp;lt; BaseMutation
    description &quot;Creates a new user&quot;

    field :user, Types::UserType, null: false

    argument :email, String, required: true
    argument :first_name, String, required: false
    argument :last_name, String, required: false

    def resolve(**kwargs)
      user = ::User.new(**kwargs)
      raise GraphQL::ExecutionError.new &quot;Error creating user&quot;, extensions: user.errors.to_hash unless user.save

      { user: user }
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/mutations/post_create.rb
module Mutations
  class PostCreate &amp;lt; BaseMutation
    description &quot;Creates a new post&quot;

    field :post, Types::PostType, null: false

    argument :user_id, Integer, required: true
    argument :title, String, required: true
    argument :content, String, required: true

    def resolve(**kwargs)
      post = ::Post.new(**kwargs)
      raise GraphQL::ExecutionError.new &quot;Error creating post&quot;, extensions: post.errors.to_hash unless post.save

      { post: post }
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GraphQL Ruby generator has already updated &lt;code&gt;app/graphql/types/mutation_type.rb&lt;/code&gt;, so we don’t need to edit this file.
For now, mutation type definition is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/graphql/types/mutation_type.rb
module Types
  class MutationType &amp;lt; Types::BaseObject
    field :post_create, mutation: Mutations::PostCreate
    field :user_create, mutation: Mutations::UserCreate
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;mutations-on-graphiql&quot;&gt;Mutations on GraphiQL&lt;/h4&gt;

&lt;p&gt;Everything is ready.
It’s time to create a user and post.
The mutations look like below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation {
  userCreate(input: {
    email: &quot;alice.jones@example.com&quot;,
    firstName: &quot;Alice&quot;,
    lastName: &quot;Jones&quot;
  }) {
    user {
      id
      email
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-graphql&quot;&gt;mutation {
  postCreate(input: {
    userId: 3,
    title: &quot;Hello World!&quot;,
    content: &quot;Hey, I made it to this world!&quot;
  }) {
    post {
      id
      userId
      title
      content
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After executing create user and post mutations, check the result by GraphQL queries we tried above.
A new user, posts should be created.
The Rails console is another way to test newly added user and post.&lt;/p&gt;</content><author><name>Yoko Harada</name></author><summary type="html">GraphQL is an API standard to provide resources on the server-side to various types of clients. GraphQL itself is a specification and doesn’t provide an implementation. For Ruby on Rails, GraphQL Ruby https://graphql-ruby.org/ is the most popular library.</summary></entry><entry><title type="html">Rails App Creation with Options</title><link href="http://localhost:4000/2023/03/05/rails-app-creation-with-options.html" rel="alternate" type="text/html" title="Rails App Creation with Options" /><published>2023-03-05T15:50:00+09:00</published><updated>2023-03-05T15:50:00+09:00</updated><id>http://localhost:4000/2023/03/05/rails-app-creation-with-options</id><content type="html" xml:base="http://localhost:4000/2023/03/05/rails-app-creation-with-options.html">&lt;p&gt;The easiest way to create a Ruby on Rails app is absolutely to hit the command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails new [APP_NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Above generates files to develop an entry level app to high end complicated app.
It’s pretty handy.&lt;/p&gt;

&lt;p&gt;However, that one-size-fits-all like command does too much often.
Basically, Ruby on Rails is a gorgeous web framework which provides every feature these days’ web application needs.
In reality, people might want to create a few pages with a database backend.
Other people might want to create just an API server.
To answer such various needs, Ruby on Rails has a lot of options to create an app — really a lot!&lt;/p&gt;

&lt;p&gt;We can see all options by hitting the command below outside of a rails app directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails -h
# or 
rails --help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You’ll see a bunch of options showing up with descriptions.
The problem is, those descriptions are not always clear enough.
Besides, options change as Ruby on Rails version goes up.&lt;/p&gt;

&lt;p&gt;To start using Rails 7, I did some googling to figure out what all those options are about.
This is a memo what I learned from my research.&lt;/p&gt;

&lt;h3 id=&quot;list-of-options&quot;&gt;List of options&lt;/h3&gt;

&lt;p&gt;Here’s an excerpt of &lt;code&gt;rails new&lt;/code&gt; options of Ruby on Rails 7.
The list doesn’t have all.
I focused on something not clear enough.
The description column is what &lt;code&gt;rails --help&lt;/code&gt; command prints out.
The additional info columns is what I added with my understanding.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;option&lt;/th&gt;
      &lt;th&gt;short&lt;/th&gt;
      &lt;th&gt;description&lt;/th&gt;
      &lt;th&gt;additional info&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-namespace&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip namespace (affects only isolated engines)&lt;/td&gt;
      &lt;td&gt;When a rails engine is created by rails new plugin command, the option has a meaning.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-collision-check&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip collision check&lt;/td&gt;
      &lt;td&gt;When rails generate command modifies existing controller/model/view, the option has a meaning.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-git&lt;/td&gt;
      &lt;td&gt;-G&lt;/td&gt;
      &lt;td&gt;Skip .gitignore file&lt;/td&gt;
      &lt;td&gt;The option skips creating .git, .gitignore and .gitattributes files.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-keeps&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip source control .keep files&lt;/td&gt;
      &lt;td&gt;The .keep file is for git to track empty directories. The option skips creating .keep file.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-action-mailer&lt;/td&gt;
      &lt;td&gt;-M&lt;/td&gt;
      &lt;td&gt;Skip Action Mailer files&lt;/td&gt;
      &lt;td&gt;The Action Mailer is used to send email from Rails app. The option skips the feature.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-action-mailbox&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip Action Mailbox gem&lt;/td&gt;
      &lt;td&gt;The Action Mailbox routes incoming email to a controller. The option skips the feature.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-action-text&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip Action Text gem&lt;/td&gt;
      &lt;td&gt;The Action Text handles a rich text content. The option skips the feature.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-active-record&lt;/td&gt;
      &lt;td&gt;-O&lt;/td&gt;
      &lt;td&gt;Skip Active Record files&lt;/td&gt;
      &lt;td&gt;The Active Record provides models to interact with applications’ database&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-active-job&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip Active Job&lt;/td&gt;
      &lt;td&gt;The Active Job is a framework for a background job. The option skips the feature.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-active-storage&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip Active Storage files&lt;/td&gt;
      &lt;td&gt;The Active Storage provides a feature to upload files to cloud storages such as AWS S3.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-action-cable&lt;/td&gt;
      &lt;td&gt;-C&lt;/td&gt;
      &lt;td&gt;Skip Action Cable files&lt;/td&gt;
      &lt;td&gt;The Action Cable integrates the websockets. The option skips the feature.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-asset-pipeline&lt;/td&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;Indicates when to generate skip asset pipeline&lt;/td&gt;
      &lt;td&gt;The asset pipeline concatenates and minifies Javascript and CSS and is provided by sprockets. The option skips the feature.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-javascript&lt;/td&gt;
      &lt;td&gt;-J&lt;/td&gt;
      &lt;td&gt;Skip JavaScript files&lt;/td&gt;
      &lt;td&gt;The option skips creating app/javascript directory. It’s useful when front-end app is separated from Rails.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-hotwire&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip Hotwire integration&lt;/td&gt;
      &lt;td&gt;Hotwire is a default front-end framework for Rails and is a combination of Stimulus and Turbo. The option skips the feature.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-jbuilder&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip jbuilder gem&lt;/td&gt;
      &lt;td&gt;Jbuilder is a JSON builder and provides a DSL to declare JSON structures.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-test&lt;/td&gt;
      &lt;td&gt;-T&lt;/td&gt;
      &lt;td&gt;Skip test files&lt;/td&gt;
      &lt;td&gt;The option skips to generate unit test files. When RSpec will be used, specify this option.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-system-test&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip system test files&lt;/td&gt;
      &lt;td&gt;The option skips to generate system test files which allow to test JavaScript functionalities.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-bootsnap&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Skip bootsnap gem&lt;/td&gt;
      &lt;td&gt;The option skips bootsnap which optimizes and caches expensive computations for Ruby and Active Support.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–skip-bundle&lt;/td&gt;
      &lt;td&gt;-B&lt;/td&gt;
      &lt;td&gt;Don’t run bundle install&lt;/td&gt;
      &lt;td&gt;The option skips to run bundle install when the Rails app is created.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–template=TEMPLATE&lt;/td&gt;
      &lt;td&gt;-m&lt;/td&gt;
      &lt;td&gt;Path to some application template (can be a filesystem path or URL)&lt;/td&gt;
      &lt;td&gt;The TEMPLATE file configures gems to integrate in Rails’ Gemfile.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–rc=RC&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Path to file containing extra configuration options for rails command&lt;/td&gt;
      &lt;td&gt;The RC file is ~/.railsrc which has a list of options to run rails new command.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–javascript=JAVASCRIPT&lt;/td&gt;
      &lt;td&gt;-j&lt;/td&gt;
      &lt;td&gt;Choose JavaScript approach [options: importmap (default), webpack, esbuild, rollup]&lt;/td&gt;
      &lt;td&gt;The option specifies how to handle and bundle JavaScript files.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–css=CSS&lt;/td&gt;
      &lt;td&gt;-c&lt;/td&gt;
      &lt;td&gt;Choose CSS processor [options: tailwind, bootstrap, bulma, postcss, sass. check https://github.com/rails/cssbundling-rails&lt;/td&gt;
      &lt;td&gt;The option specifies a CSS framework.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–asset-pipeline=ASSET_PIPELINE&lt;/td&gt;
      &lt;td&gt;-a&lt;/td&gt;
      &lt;td&gt;Choose your asset pipeline [options: sprockets (default), propshaft]&lt;/td&gt;
      &lt;td&gt;The option specifies an asset pipeline library, legacy Sprockets or newer Propshaft.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–database=DATABASE&lt;/td&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;Preconfigure for selected database (options: mysql/postgresql/sqlite3/oracle/sqlserver/jdbcmysql/jdbcsqlite3/jdbcpostgresql/jdbc)&lt;/td&gt;
      &lt;td&gt;The option specifies a database. Options start from jdbc are for JRuby.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–api&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Preconfigure smaller stack for API only apps&lt;/td&gt;
      &lt;td&gt;The option skips to create app/assets and etc directories which won’t be used in API only app.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–minimal&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Preconfigure a minimal rails app&lt;/td&gt;
      &lt;td&gt;The option creates a minimal Rails app with active record and a few more features.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;front-end-options&quot;&gt;Front-end Options&lt;/h3&gt;

&lt;p&gt;Among &lt;code&gt;rails new&lt;/code&gt; options, front-end related might draw your eyes.
Those are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;–skip-asset-pipeline&lt;/li&gt;
  &lt;li&gt;–skip-javascript&lt;/li&gt;
  &lt;li&gt;–skip-hotwire&lt;/li&gt;
  &lt;li&gt;–javascript=JAVASCRIPT&lt;/li&gt;
  &lt;li&gt;–css=CSS&lt;/li&gt;
  &lt;li&gt;–asset-pipeline=ASSET_PIPELINE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One thing I should mention is that the &lt;code&gt;--webpack&lt;/code&gt; option is not there.
That’s because Webpacker has been retired as described in the GitHub repo &lt;a href=&quot;https://github.com/rails/webpacker&quot;&gt;https://github.com/rails/webpacker&lt;/a&gt;.
The feasible replacement of Webpacker would be importmap or esbuild, which can be specified by the &lt;code&gt;--javascript=JAVASCRIPT&lt;/code&gt; option.
Both importmap and esbuild are for a rick client such as React.
The importmap is specifically for Rails freed from npm or yarn, while esbuild is a tool of JavaScript world.&lt;/p&gt;

&lt;p&gt;Another option I should mention is &lt;code&gt;--skip-hotwire&lt;/code&gt;. To specify this option or not, we should understand what is Hotwire.
Hotwire was introduced in Ruby on Rails 7, and is a default front-end framework.
Not like React, Hotwire is a server-rendered type framework.
Hotwire avoids odds related to a rich client such as bundling, the first loading time, JavaScript framework chaos or other.
Whether you will stick to the JavaScript world to develop front-end code or not, it’s your choice.&lt;/p&gt;

&lt;p&gt;One more options to look at is &lt;code&gt;--asset-pipeline=ASSET_PIPELINE&lt;/code&gt;. The asset pipeline got a choice of Propshaft.
Propshaft is a kind of simplified Sprockets and workd with jsbundling-rails ans cssbundling-rails gems.
Its GitHub repo, &lt;a href=&quot;https://github.com/rails/propshaft&quot;&gt;https://github.com/rails/propshaft&lt;/a&gt;, explains details.&lt;/p&gt;

&lt;h3 id=&quot;options-for-simplicity&quot;&gt;Options for Simplicity&lt;/h3&gt;

&lt;p&gt;You might think Ruby on Rails is too gorgeous to do just this, so better look at other frameworks.
In such a case, two options might help:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;–api&lt;/li&gt;
  &lt;li&gt;–minimal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To develop an API server which doesn’t need any front-end stuff, &lt;code&gt;--api&lt;/code&gt; option works.
When the option is given, &lt;code&gt;rails new&lt;/code&gt; command strips out many features and creates a much smaller stack with necessities for an API server.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;--minimal&lt;/code&gt; option is interesting.
When the option is specified, &lt;code&gt;rails new&lt;/code&gt; command creates a bare minimal web app stack.
It has features of database access, assets access, and just a couple more.&lt;/p&gt;

&lt;h3 id=&quot;dry-options&quot;&gt;DRY Options&lt;/h3&gt;

&lt;p&gt;OKey, we learned &lt;code&gt;rails new&lt;/code&gt; options, so now, it’s time to create a Rails app.
Well, let’s specify this option, that option, those options and …
You might end up with typing long, long line to create the app.
When you hit return key, you might find a typo in one of options.
It might be a case that you repeat creating Rails apps for multiple projects with the same set of options.&lt;/p&gt;

&lt;p&gt;Yes, Rails provides DRY, don’t repeat yourself, way:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;–rc=RC&lt;/li&gt;
  &lt;li&gt;–template=TEMPLATE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The rc file is, like a .bashrc or .zshrc, ~/.railsrc by default.
If the location is not under the home directory and/or has a different file name, use &lt;code&gt;--rc=RC&lt;/code&gt; option to point it.
The format of rc file is a list of options one in each line. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--api
-d postgresql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding extra gem might repeat in multiple projects, for example, rspec-rails gem.
For a DRY way, &lt;code&gt;--template=TEMPLATE&lt;/code&gt; option is there.
Create a template file, &lt;code&gt;template.rb&lt;/code&gt;, in general. The file name can be any, though.
Then, specify the template file using –template option.
The format is similar to Gemfile. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;gem_group :development, :test do
  gem &apos;rspec-rails&apos;, &apos;~&amp;gt; 6.0&apos;, &apos;&amp;gt;= 6.0.1&apos;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, now, &lt;code&gt;.railsrc&lt;/code&gt; file looks like below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--api
-d postgresql
-T
-m /path/to/template.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once, all are ready, hit &lt;code&gt;rails new app_name&lt;/code&gt; command.
The Rails app with the desired configurations will be created.&lt;/p&gt;</content><author><name>Yoko Harada</name></author><summary type="html">The easiest way to create a Ruby on Rails app is absolutely to hit the command:</summary></entry><entry><title type="html">Datomic Quick Start in 2023</title><link href="http://localhost:4000/2023/02/07/datomic-quick-start-in-2023.html" rel="alternate" type="text/html" title="Datomic Quick Start in 2023" /><published>2023-02-07T18:03:00+09:00</published><updated>2023-02-07T18:03:00+09:00</updated><id>http://localhost:4000/2023/02/07/datomic-quick-start-in-2023</id><content type="html" xml:base="http://localhost:4000/2023/02/07/datomic-quick-start-in-2023.html">&lt;p&gt;I used to use Datomic, &lt;a href=&quot;https://www.datomic.com&quot;&gt;https://www.datomic.com&lt;/a&gt;, a lot.
Datomic is a unique database. The most attractive feature would be the idea of preserving transactions.
Based on the transaction id, Datomic is able to pull out the past data which has been already updated later.&lt;/p&gt;

&lt;p&gt;Other than that Datomic has more unique and remarkable features.
However, the downside is, it is not so easy to get started.
Datomic has an excellent documentation on its web site.
Even though, just getting started requires a bit of hustle since it is for high-end skill-full people.
Besides, changes were made since I used it last time which is roughly a few years back.&lt;/p&gt;

&lt;p&gt;Recently, I had a chance to use Datomic.
As I mentioned, I experienced some kind of hustle.
Not to do the same hustle again, I’ll write a memo here about the attempt in early 2023.&lt;/p&gt;

&lt;h3 id=&quot;get-datomic&quot;&gt;Get Datomic&lt;/h3&gt;

&lt;p&gt;The first thing to do is absolutely to get Datomic.
If you haven’t, sign up yourself at &lt;a href=&quot;https://my.datomic.com/&quot;&gt;https://my.datomic.com/&lt;/a&gt;.
The choice here is the no cost, starter edition here, still, you need to sing up.
(My memory is not clear, but I might have selected Starter version during the sign up.)
Once you are successfully registered, the license key will be emailed.
The license key needs to run Datomic with a transactor. I’ll explain later.&lt;/p&gt;

&lt;p&gt;You are now able to download Datomic from the Downloads link at my datomic web site.
I downloaded the latest version, datomic-pro-1.0.6610.zip, as of early February, 2023.
The archive name is datomic-pro, however, my license is of “Datomic Pro Starter Edition, “ as I see it at my Account page.
It looks the archive name doesn’t matter in terms of the type of license.&lt;/p&gt;

&lt;h3 id=&quot;types-of-datomic&quot;&gt;Types of Datomic&lt;/h3&gt;

&lt;p&gt;As of now, Datomic has types below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cloud&lt;/li&gt;
  &lt;li&gt;On-Prem
    &lt;ul&gt;
      &lt;li&gt;on memory&lt;/li&gt;
      &lt;li&gt;on local storage (disk)&lt;/li&gt;
      &lt;li&gt;on storage service such as PostgreSQL, DynamoDB, Cassandra&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This memo is for a quick start, so on-prem’s memory or local storage is an option.
The on memory type is easy and runs without a specific setup.
However, it’s just for a handy test. When a process is terminated, all will be gone.
Given that, this memo is about on-prem’s local storage type.&lt;/p&gt;

&lt;h4 id=&quot;set-license-key&quot;&gt;Set License Key&lt;/h4&gt;

&lt;p&gt;Assuming downloaded Datomic archive has been extracted in somewhere,
this section explains how to set the license key.&lt;/p&gt;

&lt;p&gt;You should have the Datomic license key emailed when you registered yourself at my.datomic.com.
The email has &lt;code&gt;license-key=[long-long-six-line-or-so-text key]&lt;/code&gt; in its body part.
You may copy paste the email text to the config file.
You might want to open the attachment to copy/paste.
Both are the same.&lt;/p&gt;

&lt;p&gt;The document you should look at is: &lt;a href=&quot;https://docs.datomic.com/on-prem/getting-started/transactor.htm&quot;&gt;Run a Transactor&lt;/a&gt;.
As the document says, copy the template config file, config/samples/dev-transactor-template.properties, to
config/dev-transactor-template.properties.
Then, open the properties file and paste the license key to the line, &lt;code&gt;license-key=&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is all for the quick start set up.&lt;/p&gt;

&lt;h4 id=&quot;run-datomic&quot;&gt;Run Datomic&lt;/h4&gt;

&lt;p&gt;It’s time to start Datomic.
If it is an RDBMS like PostgreSQL, people say “start the server.”
However, as for Datomic, it is “run the transactor.”
This is because Datomic works as a transactor when storage services are used.
So, the document you should look at is:
&lt;a href=&quot;https://docs.datomic.com/on-prem/getting-started/transactor.htm&quot;&gt;Run a Transactor&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Assuming you are on the top directory of the unzipped Datomic archive,
hit the command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;bin/transactor -Ddatomic.printConnectionInfo=true config/dev-transactor-template.properties
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, Datomic started running.
The local storage, db/datomic.h2.db, should be created.&lt;/p&gt;

&lt;h4 id=&quot;connect-to-datomic-and-do-things&quot;&gt;Connect to Datomic and do things&lt;/h4&gt;

&lt;p&gt;Datomic comes with the repl.
Its usability is not so nice like lein repl, but enough to test things.
Now what you can do are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;create and connect to the database: &lt;a href=&quot;https://docs.datomic.com/on-prem/getting-started/connect-to-a-database.html&quot;&gt;Connect to a Database&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;transact a schema (create a table definition in RDBMS): &lt;a href=&quot;https://docs.datomic.com/on-prem/getting-started/transact-schema.html&quot;&gt;Transact Schema&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;transact data (insert a data in RDBMS): &lt;a href=&quot;https://docs.datomic.com/on-prem/getting-started/transact-data.html&quot;&gt;Transact Data&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;make a query: &lt;a href=&quot;https://docs.datomic.com/on-prem/getting-started/query-the-data.html&quot;&gt;Query the Data&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Start the Datomic repl by &lt;code&gt;bin/repl&lt;/code&gt;.
Copy texts from the document above and paste it on Datomic repl.
All should work.&lt;/p&gt;

&lt;h4 id=&quot;use-datomic-from-leiningen-project&quot;&gt;Use Datomic from Leiningen project&lt;/h4&gt;

&lt;p&gt;Datomic’s repl is handy. Everything is set up.
But, Clojure dev won’t do all on Datomic’s repl.
In general, Clojure people create and configure a project.&lt;/p&gt;

&lt;p&gt;One thing not straightforward is a repository for Datomic client API.
In many cases, Clojure libraries are hosted on &lt;a href=&quot;https://clojars.org&quot;&gt;https://clojars.org&lt;/a&gt;.
No authentication is required.
On the other hand, Datomic client API is hosted on the private repository which needs authentication to download.&lt;/p&gt;

&lt;p&gt;If you visit your datomic account page, &lt;a href=&quot;https://my.datomic.com/account&quot;&gt;https://my.datomic.com/account&lt;/a&gt;,
you will find brief explanation how to use from Leiningen.
To me, that was not so clear. I had to do some googling to figure out how.&lt;/p&gt;

&lt;p&gt;Eventually, I could use Datomic client API in the leiningen project.
Here’s how I made it.&lt;/p&gt;

&lt;h5 id=&quot;install-gpg-and-configure-a-key-pair&quot;&gt;Install gpg and configure a key pair&lt;/h5&gt;

&lt;p&gt;Leiningen uses a GPG encrypted credential to connect private repositories.
It is explained in the document,
&lt;a href=&quot;https://github.com/technomancy/leiningen/blob/master/doc/DEPLOY.md#authentication&quot;&gt;https://github.com/technomancy/leiningen/blob/master/doc/DEPLOY.md#authentication&lt;/a&gt;.
As the document says, gpg should be installed, and a key pair should be configured.
About installation, another document,
&lt;a href=&quot;https://github.com/technomancy/leiningen/blob/stable/doc/GPG.md&quot;&gt;https://github.com/technomancy/leiningen/blob/stable/doc/GPG.md&lt;/a&gt;
is helpful.&lt;/p&gt;

&lt;p&gt;Following the document, install the gpg first if not yet installed.
I’m on OSX, so I hit the command, &lt;code&gt;brew install gnupg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After a successful installation, create the gpg key pair by &lt;code&gt;gpg --gen-key&lt;/code&gt;.
While creating the key pair, user name, email and passphrase were asked.
There might be a variation depends on the OS, gnupg version or other.&lt;/p&gt;

&lt;p&gt;The document above explains more about how to use gpg command.
However, once the key pair is created, that’s all.&lt;/p&gt;

&lt;h5 id=&quot;create-a-credential-file-and-encrypt-it&quot;&gt;Create a credential file and encrypt it&lt;/h5&gt;

&lt;p&gt;Create &lt;code&gt;~/.lein/credentials.clj&lt;/code&gt; file with the content displayed in the my.datomic.com account page.
It is like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-clojure&quot;&gt;{#&quot;my\.datomic\.com&quot; {:username &quot;YOUR EMAIL HERE&quot;
                      :password &quot;YOUR PASSWORD HERE&quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy and paste it in &lt;code&gt;~/.lein/credentials.clj&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;The next step is to encrypt the credential file.
As the leiningen authentication document describes, hit the command,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gpg --default-recipient-self -e \
    ~/.lein/credentials.clj &amp;gt; ~/.lein/credentials.clj.gpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, the gpg encrypted credential is ready.&lt;/p&gt;

&lt;h5 id=&quot;edit-projectclj&quot;&gt;Edit project.clj&lt;/h5&gt;

&lt;p&gt;The last piece is to configure the Datomic private repository in the project.clj file.
How to setup is written in the my Datomic account page.
I wrote earlier “I downloaded the latest version, datomic-pro-1.0.6610.zip, as of early February, 2023.”
So the datomic-pro version is 1.0.6610.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-clojure&quot;&gt;:repositories {&quot;my.datomic.com&quot; {:url &quot;https://my.datomic.com/repo&quot;
                                 :creds :gpg}}
:dependencies [[com.datomic/datomic-pro 1.0.6610]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;test-repl&quot;&gt;Test Repl&lt;/h5&gt;

&lt;p&gt;As you know the command is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;lein repl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the first time, a bunch of libraries in dependency will be downloaded.
When the leiningen repl is started, try “Connect Datomic and do things” following the Datomic document.
All should work.&lt;/p&gt;</content><author><name>Yoko Harada</name></author><summary type="html">I used to use Datomic, https://www.datomic.com, a lot. Datomic is a unique database. The most attractive feature would be the idea of preserving transactions. Based on the transaction id, Datomic is able to pull out the past data which has been already updated later.</summary></entry><entry><title type="html">Number of Ways to Build Sturdy Brick Wall</title><link href="http://localhost:4000/2022/10/30/number-of-ways-to-build-sturdy-brick-wall.html" rel="alternate" type="text/html" title="Number of Ways to Build Sturdy Brick Wall" /><published>2022-10-30T17:09:57+09:00</published><updated>2022-10-30T17:09:57+09:00</updated><id>http://localhost:4000/2022/10/30/number-of-ways-to-build-sturdy-brick-wall</id><content type="html" xml:base="http://localhost:4000/2022/10/30/number-of-ways-to-build-sturdy-brick-wall.html"></content><author><name>Yoko Harada</name></author><summary type="html"></summary></entry><entry><title type="html">Setting Up GCP Instance for Deep Learning</title><link href="http://localhost:4000/2019/10/30/setting-up-gcp-instance-for-deep-learning.html" rel="alternate" type="text/html" title="Setting Up GCP Instance for Deep Learning" /><published>2019-10-30T09:40:00+09:00</published><updated>2019-10-30T09:40:00+09:00</updated><id>http://localhost:4000/2019/10/30/setting-up-gcp-instance-for-deep-learning</id><content type="html" xml:base="http://localhost:4000/2019/10/30/setting-up-gcp-instance-for-deep-learning.html">&lt;p&gt;This post is going to be very different from what I write here.
The content is a memo how I create a GCP (Google Cloud Platform) instance for Deep Learning.
While I study algorithm stuff, I also have been studying Deep Learning.
In my early days, I tried to train my Deep Learning model only on a laptop.
My laptop is 2012 model MacBook Pro, so I would say it is reasonably fast.
However, when it comes to Deep Learning, the training was quite painful on the such machine.
Often, I ran the training over night to get a disappointed result.
Still, I didn’t use any of pricey cloud environment
since it was my personal study unrelated to my day job.
I wanted to save money.&lt;/p&gt;

&lt;p&gt;A couple of years later, I took a &lt;a href=&quot;https://www.fast.ai/&quot;&gt;fast.ai&lt;/a&gt; course to study Deep Learning again.
During an introductory session, the instructor said “Pay money. That makes the training easy.”
Yes, that’s right.
Google Colab is fantastic, but it won’t save the instance I create.
Every time, I need to upload data, install libraries, start training from the beginning, etc.
Since then, I started using GCP for my Deep Learning study.&lt;/p&gt;

&lt;p&gt;In the introductory session, the instructor mentioned 4 or 5 platforms.
The reason I chose GCP is:
it provides a command line tool and allows to ssh to the instance.
This style is something I’m familiar with from my past experience on AWS.
The cost should not be so expensive as far as the instance is stopped when not using.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I once made a painful mistake while I was studying Kubernetes.
I interrupted my study for a reason, just a chore, then totally forgot some instances were up and running.
After a week or so, I realized I left those running…ouch!
I had to pay some hundred bucks for nothing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The fast.ai document “&lt;a href=&quot;https://course.fast.ai/start_gcp.html&quot;&gt;GCP&lt;/a&gt;” is very helpful.
Just following the document, people can easily get their instance running on GCP.
One caveat is the document has a fast.ai specific part.
For example, fast.ai library is written on top of PyTorch, so the image is pytorch-xxx.
Now, I wanted to use TensorFlow, so I should change some of parameters.
Additionally, I wanted to figure out what those parameters mean.
That’s why I decided to write this memo.
This blog post includes resources what I found after some research.&lt;/p&gt;

&lt;h3 id=&quot;get-started-gcp&quot;&gt;Get Started GCP&lt;/h3&gt;

&lt;p&gt;I’m a Google platform user since Google App Engine (GAE) was firstly released.
The account is the same as GAE, so I didn’t need to create my account for GCP.
However, if this is the very first time, you need to create an account.
This should be fairly easy.
Go to &lt;a href=&quot;https://cloud.google.com&quot;&gt;https://cloud.google.com&lt;/a&gt; and click “Get started for free” button.
Again, if this is the very first time to use Google platform, you will get $300 of an initial credit.
In my case, unfortunately, the sweet treat of 300 bucks were disappeared, probably, far back.
Even though this is the first time to use &lt;strong&gt;GCP&lt;/strong&gt; (after renamed to it), no free credit to old users.&lt;/p&gt;

&lt;p&gt;Don’t forget or postpone to add your credit card to the account.
Whether the free credit is there or not, GCP requires the billing setup.
Go to &lt;a href=&quot;https://console.cloud.google.com/billing&quot;&gt;https://console.cloud.google.com/billing&lt;/a&gt;
and create the billing account.&lt;/p&gt;

&lt;h3 id=&quot;install-or-update-google-cli-sdk&quot;&gt;Install or Update Google CLI (SDK)&lt;/h3&gt;

&lt;p&gt;If you don’t like a command line tool, I believe you can do all using web interface.
If you go to &lt;a href=&quot;https://console.cloud.google.com/&quot;&gt;https://console.cloud.google.com/&lt;/a&gt;, you see menus.&lt;/p&gt;

&lt;p&gt;I like the command line tool, so I’m going to write about CLI.&lt;/p&gt;

&lt;p&gt;The first step is to install Google CLI or update if already installed.
The CLI is called &lt;strong&gt;SDK&lt;/strong&gt; and whose installation document resides at &lt;a href=&quot;https://cloud.google.com/sdk/docs/quickstarts&quot;&gt;https://cloud.google.com/sdk/docs/quickstarts&lt;/a&gt;.
Since I’m a macOS user, I followed &lt;a href=&quot;https://cloud.google.com/sdk/docs/quickstart-macos&quot;&gt;https://cloud.google.com/sdk/docs/quickstart-macos&lt;/a&gt;.
The document says it needs Python 2.7, but I didn’t need Python 2.7.
The latest SDK version is 269.0.0 as of the end of October 2019.
The document says an experimental support of Python 3.4+ is from version 206.0.0 which is much old.
In my guess, the document has not been updated for long.&lt;/p&gt;

&lt;p&gt;If you have SDK installed already, update it by:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ gcloud components update
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;setting-up-sdk&quot;&gt;Setting up SDK&lt;/h3&gt;

&lt;p&gt;The next step is to set up SDK.
The document to look at is
&lt;a href=&quot;https://cloud.google.com/sdk/docs/initializing&quot;&gt;https://cloud.google.com/sdk/docs/initializing&lt;/a&gt;.
Type the command below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ gcloud init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command does:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;create/re-initialize/switch configuration&lt;/li&gt;
  &lt;li&gt;login authentication&lt;/li&gt;
  &lt;li&gt;create/switch project&lt;/li&gt;
  &lt;li&gt;set region/zone&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The configuration has four types of information: zone, account, project, reporting.
You should set parameters except reporting during the configuration.
Setting up goes interactive on command line.&lt;/p&gt;

&lt;p&gt;Among three parameters, the region/zone choice may confuse you.
Have a look at the document &lt;a href=&quot;https://cloud.google.com/compute/docs/regions-zones/&quot;&gt;https://cloud.google.com/compute/docs/regions-zones/&lt;/a&gt;.
The document describes an actual location and detailed features.
In general, it’s good to choose a geologically close region in terms of a network latency.
However, in a real situation, it may be good to choose not so busy or very powerful region.
You’d better to try some regions and test in what region the instance starts faster.&lt;/p&gt;

&lt;p&gt;Another important point to choose the zone is GPU support.
For Deep Learning, definitely, you should use GPU.
If you look at the Regions and Zones document, it’s clear what zones support GPUs.&lt;/p&gt;

&lt;p&gt;Once the configuration is done, the command shows details in the end.
The command below also shows the current configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ gcloud config list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;create-an-instance&quot;&gt;Create an Instance&lt;/h3&gt;

&lt;p&gt;To create an instance, a lot of options should be specified.
To figure out what those should be, you need to look at multiple documents.&lt;/p&gt;

&lt;p&gt;First, the command to create an instance starts from &lt;code&gt;gcloud compute instances create ...&lt;/code&gt;.
The command reference is: &lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/instances/create&quot;&gt;https://cloud.google.com/sdk/gcloud/reference/compute/instances/create&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The options to be specified are below.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Instance Name&lt;/p&gt;

    &lt;p&gt;As the command reference shows, at least one instance name must be provided.
  The name can be any as long as it satisfies the requirement described in the document,
  &lt;a href=&quot;https://cloud.google.com/compute/docs/instances/custom-hostname-vm&quot;&gt;https://cloud.google.com/compute/docs/instances/custom-hostname-vm&lt;/a&gt;.
  The document says the name should be “matching the regular expression &lt;code&gt;[a-z]([-a-z0-9]*[a-z0-9])?&lt;/code&gt;”.
  Only one instance would be good enough, so only one instance name is good to go.
  The instance name is a hostname to ssh.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Zone&lt;/p&gt;

    &lt;p&gt;This is a zone specified during the config setup.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Image Family&lt;/p&gt;

    &lt;p&gt;For a Machine Learning/Deep Learning purpose,
  GCP provides images which have packages/libraries frequently used in ML/DL.
  Look at the document &lt;a href=&quot;https://cloud.google.com/ai-platform/deep-learning-vm/docs/images&quot;&gt;https://cloud.google.com/ai-platform/deep-learning-vm/docs/images&lt;/a&gt;.
  Combinations of framework/version/processor are the differences of images.
  For example, I’m going to use TensorFlow 2.0 with GPU, my choice is &lt;code&gt;tf2-latest-gpu&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;To choose images for Deep Learning, &lt;code&gt;--image-project=deeplearning-platform-release&lt;/code&gt;
  option should be specified as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Machine Type&lt;/p&gt;

    &lt;p&gt;The detailed information about machine types is:
  &lt;a href=&quot;https://cloud.google.com/compute/docs/machine-types&quot;&gt;https://cloud.google.com/compute/docs/machine-types&lt;/a&gt;.
  Deep Learning tends to need more memory.
  Probably, &lt;code&gt;n1-highmem-4&lt;/code&gt; or &lt;code&gt;n1-highmem-8&lt;/code&gt; are the good choices.
  Also, look at the pricing document which one to choose:
  &lt;a href=&quot;https://cloud.google.com/ml-engine/docs/pricing&quot;&gt;https://cloud.google.com/ml-engine/docs/pricing&lt;/a&gt;.
  The price per hour is $0.2368 for &lt;code&gt;n1-highmem-4&lt;/code&gt; and $0.4736 for &lt;code&gt;n1-highmem-8&lt;/code&gt;.&lt;/p&gt;

    &lt;p&gt;Type the command below to check what machine types are available in your zone.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;  $ gcloud compute machine-types list --zones=ZONE 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Accelerator&lt;/p&gt;

    &lt;p&gt;Type the command below to see what accelerators are supported in what zones.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;  $ gcloud compute accelerator-types list
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;Also, check the pricing document,
  &lt;a href=&quot;https://cloud.google.com/ml-engine/docs/pricing&quot;&gt;https://cloud.google.com/ml-engine/docs/pricing&lt;/a&gt;.
  A budget type NVIDIA_TESLA_K80 is $0.4500/hour,
  and more powerful type NVIDIA_TESLA_P4 costs $0.6000/hour.&lt;/p&gt;

    &lt;p&gt;To use NVIDIA accelerator, &lt;code&gt;--metadata=&quot;install-nvidia-driver=True&quot;&lt;/code&gt; option
  should be specified as well.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Boot Disk Size&lt;/p&gt;

    &lt;p&gt;To train the Deep Learning model, more data leads to better result.
  Given that, &lt;code&gt;200GB&lt;/code&gt; may be a good size.
  Again, check the pricing document,
  &lt;a href=&quot;https://cloud.google.com/compute/disks-image-pricing&quot;&gt;https://cloud.google.com/compute/disks-image-pricing&lt;/a&gt;.
  Depends on the zones, the same disk size costs differently.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Budget Type Setting&lt;/p&gt;

    &lt;p&gt;To save money, &lt;code&gt;--preemptible&lt;/code&gt; is a nice option to have.
  The instance automatically shuts down after 24 hours.
  The details are in the document,
  &lt;a href=&quot;https://cloud.google.com/preemptible-vms/&quot;&gt;https://cloud.google.com/preemptible-vms/&lt;/a&gt;.
  Downside is, the instance stops while using depending on how busy the host machine is.
  If your preemptible instance stops frequently, try a different zone.&lt;/p&gt;

    &lt;p&gt;Another budget option is &lt;code&gt;--maintenance-policy=TERMINATE&lt;/code&gt;.
  The option defines the policy when the host machine goes maintenance.
  This choice is &lt;code&gt;MIGRATE&lt;/code&gt; or &lt;code&gt;TERMINATE&lt;/code&gt;.
  When &lt;code&gt;--preemptible&lt;/code&gt; is specified, the instance never migrates.
  But, it doesn’t harm to specify &lt;code&gt;TERMINATE&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Considering above, the budget type instance creation would become below.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/yokolet/b13272ac6bb4f7b2a7abdaddd5ed175c.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;The instance creation takes a while.
When the prompt returns after typing the command above, go to GCP console,
&lt;a href=&quot;https://console.cloud.google.com/&quot;&gt;https://console.cloud.google.com/&lt;/a&gt;.
You may need to choose the project whose name is the one you set during the configuration.
Then, click the hamburger icon (navigation menu) on the top left, Compute Engine, VM instances.
You’ll see your instance is running.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/vm-instance.png&quot; alt=&quot;vm instance&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Don’t forget to stop the instance.
To stop the instance, click three dots icon on the right side and choose Stop.&lt;/p&gt;

&lt;p&gt;To use again, click the three dots icon and choose Start.&lt;/p&gt;

&lt;p&gt;Alternatively, you can start/stop the instance from the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# $INSTANCE_NAME is an INSTANCE_NAME environment variable
# which is set when above command gets run

$ gcloud compute instances start $INSTANCE_NAME
$ gcloud compute instances stop $INSTANCE_NAME
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;use-the-instance&quot;&gt;Use the Instance&lt;/h3&gt;

&lt;p&gt;Now, the instance is up an running. It’s time to use it.
Since the image is for Deep Learning, it has a setting to start jupyter notebook when the instance is up.
An easy way is to use &lt;strong&gt;ssh tunneling&lt;/strong&gt;.
Type the command below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ gcloud compute ssh jupyter@$INSTANCE_NAME -- -L 8080:localhost:8080
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;jupyter&lt;/code&gt;: default user name on the instance.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;$INSTANCE_NAME&lt;/code&gt;: &lt;code&gt;INSTANCE_NAME&lt;/code&gt; environment variable. The name is given when the instance is created.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If it is the first time to login to the instance, the command line tool asks a password to create ssh key.
The public and private keys are saved as
&lt;code&gt;~/.ssh/google_compute_engine.pub&lt;/code&gt; and &lt;code&gt;~/.ssh/google_compute_engine&lt;/code&gt; on a local machine.&lt;/p&gt;

&lt;p&gt;Once the ssh connection is established, you are logged in to the instance as a user jupyter.
At the same time, jupyter notebook is available to use on a local machine.
Go to the web browser and hit the URL, &lt;code&gt;http://localhost:8080/tree&lt;/code&gt;.
The jupyter notebook below shows up.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/notebook.png&quot; alt=&quot;jupyter notebook&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;access-github-repositories&quot;&gt;Access Github Repositories&lt;/h3&gt;

&lt;p&gt;You may create a Deep Learning stuff only on jupyter notebook.
However, it’s very convenient to have an access to Github repos.
Setting up is as easy as you’ve done on a local machine, laptop whatever.&lt;/p&gt;

&lt;p&gt;The set up starts from generating an ssh key pair.
The good document is,
“&lt;a href=&quot;https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent&quot;&gt;Generating a new SSH key and adding it to the ssh-agent&lt;/a&gt;”.&lt;/p&gt;

&lt;p&gt;Click Linux tab since the instance is Debian Linux. Then, follow the instruction.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Generate a SSH Key on the instance&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; jupyter@my-tf2-instance:~$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Start ssh-agent&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; jupyter@my-tf2-instance:~$ eval &quot;$(ssh-agent -s)&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Add ssh private key&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; jupyter@my-tf2-instance:~$ ssh-add ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Next is to add the generated ssh public key to your GitHub account.
Have a look at the document,
“&lt;a href=&quot;https://help.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account&quot;&gt;Adding a new SSH key to your GitHub account&lt;/a&gt;”.
Follow the instruction and add the public key created on the instance.&lt;/p&gt;

&lt;p&gt;When the set up is finished, you can access GitHub repos from the instance like you do on your local machine.
For example, &lt;code&gt;git clone ...&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt; etc.&lt;/p&gt;

&lt;h3 id=&quot;install-python37&quot;&gt;Install Python3.7&lt;/h3&gt;

&lt;p&gt;The GCP instance comes with Python2.7 and 3.5.
Python3.5 would work well.
However, sometime, an environment setting specifies Python3.7.
Rather than editing such setting, installing Python3.7 makes things easy.&lt;/p&gt;

&lt;p&gt;A helpful explanation is among StackOverflow questions:
“&lt;a href=&quot;https://stackoverflow.com/questions/53468831/how-do-i-install-python-3-7-in-google-cloud-shell&quot;&gt;How do I install Python 3.7 in google cloud shell&lt;/a&gt;”.&lt;/p&gt;

&lt;p&gt;Below is an excerpt from the answer (the version is updated).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# Install requirements
jupyter@my-tf2-instance:~$ sudo apt-get install -y build-essential checkinstall libreadline-gplv2-dev libncursesw5-dev libssl-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev zlib1g-dev openssl libffi-dev python3-dev python3-setuptools wget 

# Prepare to build
jupyter@my-tf2-instance:~$ mkdir /tmp/Python37
jupyter@my-tf2-instance:~$ cd /tmp/Python37

# Pull down Python 3.7, build, and install
jupyter@my-tf2-instance:~$ wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tar.xz
jupyter@my-tf2-instance:~$ tar xvf Python-3.7.4.tar.xz
jupyter@my-tf2-instance:~$ cd /tmp/Python37/Python-3.7.4
jupyter@my-tf2-instance:~$ ./configure
jupyter@my-tf2-instance:~$ sudo make altinstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python3.7 should be installed under &lt;code&gt;/usr/local/bin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, three Pythons are installed in a single instance.
So that three Pythons can be switched, it’s a good idea to install those as alternatives.
The command below does that.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jupyter@my-tf2-instance:~$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2
jupyter@my-tf2-instance:~$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.5 3
jupyter@my-tf2-instance:~$ sudo update-alternatives --install /usr/bin/python python /usr/local/bin/python3.7 4

jupyter@my-tf2-instance:~$ sudo update-alternatives --config python
There are 3 choices for the alternative python (providing /usr/bin/python).

  Selection    Path                      Priority   Status
------------------------------------------------------------
* 0            /usr/local/bin/python3.7   4         auto mode
  1            /usr/bin/python2.7         2         manual mode
  2            /usr/bin/python3.5         3         manual mode
  3            /usr/local/bin/python3.7   4         manual mode

Press &amp;lt;enter&amp;gt; to keep the current choice[*], or type selection number: 0

# Do the same installation for pip

jupyter@my-tf2-instance:~$ sudo rm /usr/bin/pip
jupyter@my-tf2-instance:~$ sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip2 2
jupyter@my-tf2-instance:~$ sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 3
jupyter@my-tf2-instance:~$ sudo update-alternatives --install /usr/bin/pip pip /usr/local/bin/pip3.7 4
jupyter@my-tf2-instance:~$ sudo update-alternatives --config pip
There are 3 choices for the alternative pip (providing /usr/bin/pip).

  Selection    Path                   Priority   Status
------------------------------------------------------------
* 0            /usr/local/bin/pip3.7   4         auto mode
  1            /usr/bin/pip2           2         manual mode
  2            /usr/bin/pip3           3         manual mode
  3            /usr/local/bin/pip3.7   4         manual mode

Press &amp;lt;enter&amp;gt; to keep the current choice[*], or type selection number: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;setup-pipenv&quot;&gt;Setup Pipenv&lt;/h3&gt;

&lt;p&gt;The cloned Deep Learning project may have &lt;code&gt;Pipfile/Pipfile.lock&lt;/code&gt;.
This is a “&lt;strong&gt;&lt;a href=&quot;http://pipenv.kennethreitz.org/en/latest/&quot;&gt;Pipenv&lt;/a&gt;&lt;/strong&gt;” setting file.
The &lt;code&gt;Pipenv&lt;/code&gt; is a Python’s package manager like JavaScript’s npm/yarn or Ruby’s bundler.
Automatically started jupyter notebook doesn’t have &lt;code&gt;Pipenv&lt;/code&gt; setting on the instance.
This section is about to use &lt;code&gt;Pipenv&lt;/code&gt; on the GCP instance.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Look at system services&lt;/p&gt;

    &lt;p&gt;To control the jupyter process, you need to use a &lt;code&gt;systemctl&lt;/code&gt; command.
The &lt;code&gt;systemctl&lt;/code&gt; command controls background processes on Debian Linux.
For example, type below:&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;jupyter@my-tf2-instance:~$ sudo systemctl status
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;The command above lists services controlled by the system.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/systemctl-output.png&quot; alt=&quot;systemctl output&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;The &lt;code&gt;jupyter.service&lt;/code&gt; is among them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Stop and disable &lt;code&gt;jupyter.servce&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;If you recognize &lt;code&gt;Pipfile&lt;/code&gt; in the project, you want to run jupyter notebook under a particular environment.
 GCP’s default jupyter startup service won’t be used in such case.
 Run the commands below to stop and disable jupyter service.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; $ sudo systemctl stop jupyter
 $ sudo systemctl disable jupyter
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create environment&lt;/p&gt;

    &lt;p&gt;Python3.7 comes with virtual environment tool, &lt;code&gt;pyvenv&lt;/code&gt;.
 It is handy to create a project specific environment.
 Go to the directory which has the &lt;code&gt;Pipfile&lt;/code&gt; and run the commands below.
 The command prompt will have a prefix &lt;code&gt;(env)&lt;/code&gt;.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; jupyter@my-tf2-instance:~/intro-to-deep-learning$ python -m venv env
 jupyter@my-tf2-instance:~/intro-to-deep-learning$ source env/bin/activate
 (env) jupyter@my-tf2-instance:~/intro-to-deep-learning$
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Install &lt;code&gt;pipenv&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;For some reason, when &lt;code&gt;pipenv&lt;/code&gt; is simply installed by &lt;code&gt;pip install pipenv&lt;/code&gt;,
 the &lt;code&gt;pipenv install&lt;/code&gt; command raises a confusing error.
 The solution for this error is discussed on the GitHub issue,
 &lt;a href=&quot;https://github.com/pypa/pipenv/issues/3468&quot;&gt;https://github.com/pypa/pipenv/issues/3468&lt;/a&gt;.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; (env) jupyter@my-tf2-instance:~/intro-to-deep-learning$ pip install -e git+https://github.com/pypa/pipenv.git@master#egg=pipenv
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Install &lt;code&gt;pipenv&lt;/code&gt; environment&lt;/p&gt;

    &lt;p&gt;Next is the installation by the &lt;code&gt;pipenv&lt;/code&gt; command to create
 the same runtime environment specified in the &lt;code&gt;Pipfile&lt;/code&gt;.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; (env) jupyter@my-tf2-instance:~/intro-to-deep-learning$ pipenv install
 (env) jupyter@my-tf2-instance:~/intro-to-deep-learning$ pipenv shell

 # Do some more installation, for example
 (env) jupyter@my-tf2-instance:~/intro-to-deep-learning$ jupyter contrib nbextension install --user
 (env) jupyter@my-tf2-instance:~/intro-to-deep-learning$ jupyter nbextensions_configurator enable --user
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Start &lt;code&gt;jupyter notebook&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;Everything is ready. Let’s start up the &lt;code&gt;jupyter notebook&lt;/code&gt;.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; (env) jupyter@my-tf2-instance:~/intro-to-deep-learning$ jupyter notebook
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;Above may raise some errors since newly installed jupyter doesn’t have some extensions installed.
 However, the notebook itself starts running.&lt;/p&gt;

    &lt;p&gt;Be careful about installing extensions, especially labextension.
 The installed extensions may load Python 3.5.
 As a result, whole notebook will use Python 3.5 even though the Python to
 start &lt;code&gt;jupyter notebook&lt;/code&gt; is 3.7.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Connect to &lt;code&gt;jupyter notebook&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;The &lt;code&gt;jupyter notebook&lt;/code&gt; is running on the port 8080.
 The tunneling has been enabled on the port 8080, so like you did already,
 go to the web browser and hit &lt;code&gt;http://localhost:8080/tree&lt;/code&gt;.
 You’ll see project files on the notebook.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deactivate the virtual environment&lt;/p&gt;

    &lt;p&gt;After shutting down the notebook, you should deactivate the virtual environment.
 The command below does that.
 After deactivated, the command line prompt changes.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; (env) jupyter@my-tf2-instance:~/intro-to-deep-learning$ deactivate
 jupyter@my-tf2-instance:~/intro-to-deep-learning$
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;continue-to-work-on-another-day&quot;&gt;Continue to Work on Another Day&lt;/h3&gt;

&lt;p&gt;All installations have been done.
When you continue to work on another day, what to do is much less.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start the instance&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; $ gcloud compute instances start $INSTANCE_NAME
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSH to the instance with tunneling&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; $ gcloud compute ssh jupyter@$INSTANCE_NAME -- -L 8080:localhost:8080
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Activate the environment&lt;/p&gt;

    &lt;p&gt;This memo assumes the environment setting is provided by &lt;code&gt;Pipfile&lt;/code&gt;,
 so go to the project directory which has &lt;code&gt;Pipfile&lt;/code&gt;.
 Then, activate the environment.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; jupyter@my-tf2-instance:~$ cd intro-to-deep-learning
 jupyter@my-tf2-instance:~/intro-to-deep-learning$ source env/bin/activate
 (env) jupyter@my-tf2-instance:~/intro-to-deep-learning$ pipenv shell
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Start &lt;code&gt;jupyter notebook&lt;/code&gt; and use it&lt;/p&gt;

    &lt;p&gt;Start the &lt;code&gt;jupyter notebook&lt;/code&gt;, then go to the web browser.
 The URL is &lt;code&gt;http://localhost:8080&lt;/code&gt;.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; (env) jupyter@my-tf2-instance:~/intro-to-deep-learning$ jupyter notebook 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Add SSH from the instance to GitHub&lt;/p&gt;

    &lt;p&gt;When you login to the instance, the SSH identity to access GitHub repos is not saved.
 Startup ssh authentication agent and add identity.&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; jupyter@my-tf2-instance:~$ eval &quot;$(ssh-agent -s)&quot;
 jupyter@my-tf2-instance:~$ ssh-add ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;After the work&lt;/p&gt;

    &lt;p&gt;Shutdown the notebook, deactivate the virtual environment, and exit the shell.
 Don’t forget to stop the instance.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;in-the-end&quot;&gt;In The End&lt;/h3&gt;

&lt;p&gt;This type of work tends to take time, experience hard time.
Sometime, it is frustrating since some don’t work as in the documents.
Sometime, the document is missing something, or something is different in my box.&lt;/p&gt;

&lt;p&gt;My memo may not help you. My memo may have extra you don’t need.
Often, what people want to do are a bit different from other people do.
Also, there are a couple or many ways to accomplish that.&lt;/p&gt;

&lt;p&gt;This memo is just an example how I set up those.
I’m pretty sure I’ll forget how I did.
This memo will help future myself to recall how I could setup my GCP instance in the past.
If this memo helps you, that’s more than happy to me.&lt;/p&gt;</content><author><name>Yoko Harada</name></author><summary type="html">This post is going to be very different from what I write here. The content is a memo how I create a GCP (Google Cloud Platform) instance for Deep Learning. While I study algorithm stuff, I also have been studying Deep Learning. In my early days, I tried to train my Deep Learning model only on a laptop. My laptop is 2012 model MacBook Pro, so I would say it is reasonably fast. However, when it comes to Deep Learning, the training was quite painful on the such machine. Often, I ran the training over night to get a disappointed result. Still, I didn’t use any of pricey cloud environment since it was my personal study unrelated to my day job. I wanted to save money.</summary></entry></feed>